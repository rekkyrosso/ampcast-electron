"use strict";(globalThis.webpackChunkampcast=globalThis.webpackChunkampcast||[]).push([[595],{9967:(r,n,e)=>{e.r(n),e.d(n,{default:()=>t});const t=[{id:"ldSGRW",name:"25 boxes and a tunnel by movAX13h",shader:"// https://www.shadertoy.com/view/ldSGRW\r\n// 25 boxes, a tunnel based on voronoi, bit encoded patterns, script for 80 seconds (music)\r\n// fragment shader by movAX13h, November 2013\r\n\r\n// NOTE: Patterns start at ~45 seconds.\r\n\r\nfloat rand(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nfloat rand(float n)\r\n{\r\n    return fract(sin(n * 12.9898) * 43758.5453);\r\n}\r\n\r\nvec2 rand2(vec2 p)\r\n{\r\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\r\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\r\n}\r\n\r\nfloat sdBox( vec3 p, vec3 b )\r\n{\r\n\tvec3 d = abs(p) - b;\r\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\n\r\nfloat pattern(float n, vec2 p)\r\n{\r\n\tp = p * 4.0;\r\n\tp = floor(p + 2.5);\r\n\r\n\tif (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y)\r\n\t{\r\n\t\tfloat k = p.x + p.y*5.0;\r\n\t\tif (int(mod(n/(pow(2.0,k)),2.0)) == 1) return 0.0;\r\n\t}\r\n\r\n\treturn 1.0;\r\n}\r\n\r\nstruct Cell\r\n{\r\n\tfloat d;\r\n\tvec2 hash;\r\n\tvec2 pos;\r\n};\r\n\r\nCell Cells(in vec2 p, in float numCells, bool bump)\r\n{\r\n\tp *= numCells;\r\n\r\n\tfloat d = 1.0e20;\r\n\tvec2 hash;\r\n\tvec2 pos;\r\n\r\n\tfor (int dx = -1; dx <= 1; dx++)\r\n\tfor (int dy = -1; dy <= 1; dy++)\r\n\t{\r\n\t\tvec2 tp = floor(p) + vec2(dx, dy);\r\n\t\tvec2 h = rand2(vec2(mod(tp.x, numCells), tp.y)); // repeat x\r\n\t\tfloat m = length(p - tp - h);\r\n\r\n\t\tif (m < d)\r\n\t\t{\r\n\t\t\td = m;\r\n\t\t\thash = h;\r\n\t\t\tpos = tp;\r\n\t\t}\r\n\t}\r\n\r\n\tif (bump) return Cell(d, hash, pos);\r\n\treturn Cell(1.0-d, hash, pos);\r\n}\r\n\r\n\r\nfloat sampleMusic(float f, float bands)\r\n{\r\n\tf = floor(f*bands)/bands;\r\n\tfloat fft = texture( iChannel0, vec2(f,0.0) ).x;\r\n\treturn fft;\r\n}\r\n\r\nfloat sampleMusic()\r\n{\r\n\treturn 0.25 * (\r\n\t\ttexture( iChannel0, vec2( 0.01, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.07, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\r\n}\r\n\r\n\r\n#define L_hi 1613493.0\r\n#define L_smile 10813998.0\r\n#define L_I 14815374.0\r\n#define L_heart 11533764.0\r\n#define L_S 15793695.0\r\n#define L_T 462976.0\r\n\r\n#define L_NONE 0.0\r\n#define L_RANDOM 1.0\r\n\r\nfloat time;\r\n\r\nbool openTunnel = false;\r\nbool bumpTunnel = false;\r\nfloat boxSymbol = L_RANDOM;\r\n\r\nvec4 scene(vec3 p)\r\n{\r\n\tfloat tunnelRadius = 0.38;\r\n\tfloat numCells = 8.0;\r\n\r\n\tfloat d, d1;\r\n\tvec3 q = p;\r\n\r\n\tvec3 col = vec3(0.1, 0.7, 1.0);\r\n\td = 10000.0;\r\n\r\n \t// tunnel\r\n\t#if 1\r\n\tvec2 uv = vec2((atan(p.y, p.x) + 3.14159265) / 6.283185307, -time*0.6 + p.z*0.4);\r\n\tCell cell = Cells(uv, numCells, bumpTunnel);\r\n\tq.xy *= 1.0 + cell.d*0.1;\r\n\td = max(length(q.xy) - tunnelRadius+0.01,-(length(q.xy) - tunnelRadius));\r\n\tif (openTunnel) d = max(-sdBox(p-vec3(-1.2, 0.0, 0.0), vec3(1.0, 1.0, 10.0)), d);\r\n\tfloat m = sampleMusic() * (1.0+smoothstep(0.4, 0.6, sampleMusic(cell.hash.x * cell.hash.y, 4.0)));\r\n\tvec3 c = m*vec3(cell.hash.x*0.9, cell.hash.y*0.3, 0.11)*cell.d;\r\n\tcol = mix(col, c, smoothstep(0.1, 0.0, d));\r\n\t#endif\r\n\r\n\t// letter boxes\r\n\t#if 1\r\n\tfloat ltime = mod(time, 10.0);\r\n\r\n\tif (boxSymbol > 0.0)\r\n\t{\r\n\t\tfor(int i = 0; i < 25; i++)\r\n\t\t{\r\n\t\t\tvec3 pos;\r\n\r\n\t\t\tif (boxSymbol < 1.1) // random boxes\r\n\t\t\t{\r\n\t\t\t\tltime = time*3.0 + float(i)*20.134;\r\n\r\n\t\t\t\tfloat r = rand(float(i)*20.33);\r\n\t\t\t\tfloat z = -6.0+mod(ltime*(r + 0.5), 15.0);\r\n\r\n\t\t\t\tif (!openTunnel && z > 2.0) continue;\r\n\r\n\t\t\t\tpos = vec3(0.04*mod(float(i), 5.0) - 0.08, 0.04*floor(float(i)/5.0) - 0.08, z);\r\n\t\t\t\td1 = sdBox(p-pos,  vec3(0.009)); // ugly boxes\r\n\t\t\t\tif (d1 < d)\r\n\t\t\t\t{\r\n\t\t\t\t\td = d1;\r\n\t\t\t\t\tcol = vec3(0.1, 0.6, 0.9)*(r+0.2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse // symbol mode\r\n\t\t\t{\r\n\t\t\t\tfloat z = 0.5+0.2*tan(-time - float(i)*0.04);\r\n\t\t\t\tif (z > 1.0) continue;\r\n\r\n\t\t\t\tvec3 shift = min(z-0.5, 0.0) * vec3(0.08*sin(time + 0.2*float(i)), 0.08*cos(time + 0.4 * float(i)), 0.0);\r\n\t\t\t\tpos = vec3(0.04*mod(float(i), 5.0) - 0.08, 0.04*floor(float(i)/5.0) - 0.08, z);\r\n\t\t\t\td1 = sdBox(p-pos-shift,  vec3(0.009)); // ugly boxes\r\n\t\t\t\tif (d1 < d)\r\n\t\t\t\t{\r\n\t\t\t\t\tfloat lv = pattern(boxSymbol, (p.xy-shift.xy)*6.2);\r\n\t\t\t\t\td = d1;\r\n\t\t\t\t\tif (lv > 0.5) col = vec3(0.216, 0.106, 0.173);\r\n\t\t\t\t\telse col = vec3(0.820, 0.839, 0.906);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t#endif\r\n\treturn vec4(col, d);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\r\n\r\n    float focus = 3.14;\r\n    float far = 5.5;\r\n\r\n\ttime = iTime;\r\n\r\n\tvec3 ct = vec3(0.0);\r\n\tvec3 cp;\r\n\tvec3 cu  = vec3(0.0, 1.0, 0.0);\r\n\r\n\tif (time < 12.7)\r\n\t{\r\n\t\tcp = vec3(0.2*sin(time*0.4), -0.02+0.2*cos(time*0.2), 1.5);\r\n\t}\r\n\telse if (time < 27.8)\r\n\t{\r\n\t\tcp = vec3(-0.2*sin(time*0.4), 0.02+0.2*sin(time*0.2), 1.5);\r\n\t}\r\n\telse if (time < 35.4)\r\n\t{\r\n\t\tbumpTunnel = true;\r\n\t\tboxSymbol = L_NONE;\r\n\t\tcp = vec3(0.6, sin(time*0.4-35.4), 1.5);\r\n\t}\r\n\telse if (time < 44.9)\r\n\t{\r\n\t\topenTunnel = true;\r\n\t\tcp = vec3(-2.0, 0.0, 3.5);\r\n\t}\r\n\telse if (time < 45.2)\r\n\t{\r\n\t\tboxSymbol = L_NONE;\r\n\t\tcp = vec3(0.0, 0.0, 1.5);\r\n\t}\r\n\telse if (time < 63.7)\r\n\t{\r\n\t\tcp = vec3(0.0, 0.0, 1.5);\r\n\t\tcu  = vec3(0.1*sin(time), 1.0, 0.1*cos(time));\r\n\r\n\t\tfloat id = mod(floor((time - 45.2) / 3.1415), 6.0);\r\n\t\tif (id == 0.0) boxSymbol = L_hi;\r\n\t\telse if (id == 1.0) boxSymbol = L_smile;\r\n\t\telse if (id == 2.0) boxSymbol = L_I;\r\n\t\telse if (id == 3.0) boxSymbol = L_heart;\r\n\t\telse if (id == 4.0) boxSymbol = L_S;\r\n\t\telse if (id == 5.0) boxSymbol = L_T;\r\n\t}\r\n\telse if (time < 79.3)\r\n\t{\r\n\t\tboxSymbol = L_NONE;\r\n\t\tcu  = vec3(sin(time), 1.0, cos(time));\r\n\t\tcp = vec3(0.0, 0.0, 1.5);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tboxSymbol = L_RANDOM;\r\n\t\tcp = vec3(0.2*sin(time*0.4), -0.02+0.2*cos(time*0.2), 1.5);\r\n\t\tcu  = vec3(sin(time*0.8), 1.0, cos(time*0.6));\r\n\t}\r\n\r\n\t#if 0\r\n\tif (iMouse.z > 0.0) // debug\r\n\t{\r\n\t\tfloat d = (iResolution.y-iMouse.y)*0.01+3.0;\r\n\t\tcp = vec3(sin(iMouse.x*0.01)*d, .0, cos(iMouse.x*0.01)*d);\r\n\t}\r\n\t#endif\r\n\r\n\tvec3 cd = normalize(ct-cp);\r\n\tvec3 cs = cross(cd, cu);\r\n\tvec3 dir = normalize(cs*pos.x + cu*pos.y + cd*focus);\r\n\r\n    vec4 s;\r\n\tfloat dist = 0.0;\r\n\tvec3 ray = cp;\r\n\r\n    for(int i=0; i < 40; i++)\r\n\t{\r\n        s = scene(ray);\r\n\r\n        dist += s.w;\r\n        ray += dir * s.w;\r\n\r\n        if(s.w < 0.01) break;\r\n\r\n        if(dist > far)\r\n\t\t{\r\n\t\t\tdist = far;\r\n\t\t\tbreak;\r\n\t\t}\r\n    }\r\n\r\n    float b = 1.0 - dist/far;\r\n\tvec3 col = b * s.rgb;\r\n\r\n\t// fake lights\r\n\tcol *= pow(1.3 + smoothstep(0.6, 0.0, abs(sin(ray.z+time*2.0))), 2.0);\r\n\r\n\t// vignetting & grain\r\n\tcol *= 1.0-smoothstep(0.0, 2.0, length(pos.xy));\r\n\tcol -= 0.03*rand(pos.xy);\r\n\r\n\tfragColor = vec4(col*1.2, 1.0);\r\n}\r\n"},{id:"sslXzX",name:"MandelKoch - Music Visualiser by Pelegefen",shader:"// https://www.shadertoy.com/view/sslXzX\r\n// ----------------CAUTION!!!--- FLASHING BRIGHT LIGHTS!!!-------------------------\r\n\r\n\r\n\r\n// Credits - fractal zoom with smooth iter count adapted from - iq (Inigo quilez) - https://iquilezles.org/articles/msetsmooth\r\n// Koch Snowflake symmetry from tutorial by Martijn Steinrucken aka The Art of Code/BigWings - 2020 - https://www.youtube.com/watch?v=il_Qg9AqQkE&ab_channel=TheArtofCode\r\n//music - Sajanka (Official) Sajanka - Sun Is Coming\r\n\r\n//Some notes - color is determined by date and not time - hour of day dependent.\r\n//Move the mouse on the Y axis to change the symmetry.\r\n\r\n//----------------------------------------------------------------------------------\r\n\r\n//uncomment to sample audio input from MIC instead of SoundCloud.\r\n//#define MIC_INPUT\r\n\r\n//comment to make it less trippy and noisy.\r\n//#define EXTRA_DMT\r\n\r\n\r\n#define PI 3.14159265359\r\n\r\n\r\n\r\n#define date iDate\r\n#define time iTime\r\n#define resolution iResolution\r\n\r\nfloat freqs[4];\r\n\r\n\r\nvec2 rot(vec2 p,float a){\r\n\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n\r\n    mat2 m = mat2(c,-s,s,c);\r\n\r\n    p*=m;\r\n    return p  ;\r\n}\r\n\r\nfloat localTime(){\r\n\r\nfloat d = date.w / date.x;\r\nreturn d;\r\n\r\n}\r\n\r\nvec3 randomCol(float sc){\r\n\r\n float d = localTime();\r\n\tfloat r = sin(sc * 1. * d)*.5+.5;\r\n\tfloat g = sin(sc * 2. * d)*.5+.5;\r\n\tfloat b = sin(sc * 4. * d)*.5+.5;\r\n\r\n\tvec3 col = vec3(r,g,b);\r\n\tcol = clamp(col,0.,1.);\r\n\r\n\treturn col;\r\n\t}\r\n\r\n\r\n//--------------------------------------------------mandelbrot generator-----------https://iquilezles.org/articles/msetsmooth\r\n\r\n\tfloat mandelbrot(vec2 c )\r\n{\r\n    #if 1\r\n    {\r\n        float c2 = dot(c, c);\r\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\r\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\r\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\r\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\r\n    }\r\n    #endif\r\n\r\n\r\n    const float B = 128.0;\r\n    float l = 0.0;\r\n    vec2 z  = vec2(0.0);\r\n    for( int i=0; i<256; i++ )\r\n    {\r\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\r\n        if( dot(z,z)>(B*B) ) break;\r\n        l += 1.0;\r\n    }\r\n\r\n    if( l>255.0 ) return 0.0;\r\n\r\n\r\n    // equivalent optimized smooth interation count\r\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\r\n\r\n\r\n\r\n     return sl;\r\n }\r\n\r\n\r\nvec3 mandelbrotImg(vec2 p)\r\n{\r\n\r\n    //uncomment to see unmaped set\r\n\t//p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    float mtime =  time;\r\n    mtime -= freqs[3];\r\n    float zoo = 0.62 + 0.38*cos(.1*mtime);\r\n   float coa = cos( 0.015*(1.0-zoo)*mtime );\r\n   float sia = sin( 0.015*(1.0-zoo)*mtime );\r\n   zoo = pow( zoo,6.0);\r\n   vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\r\n   vec2 c = vec2(-.745,.186) + xy*zoo;\r\n\r\n        float l = mandelbrot(c);\r\n\r\n\r\n\tvec3 col1 = 0.5 + 0.5*cos( 3.0 + l*.15 + randomCol(.1));\r\n    #ifdef EXTRA_DMT\r\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 / randomCol(.1));\r\n    #else\r\n    vec3 col2 = 0.5 + 0.5*cos( 3.0 + l*.15 * randomCol(.1));\r\n    #endif\r\n    vec3 col = mix(col1,col2,sin(mtime)*.5+.5);\r\n\r\n\r\n\r\n\r\nreturn col;\r\n}\r\n\r\n//-----------------functions-----------\r\n\r\nfloat remap(float a1, float a2 ,float b1, float b2, float t)\r\n{\r\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\r\n}\r\n\r\n\r\nvec2 remap(float a1, float a2 ,float b1, float b2, vec2 t)\r\n{\r\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\r\n}\r\n\r\n\r\nvec4 remap(float a1, float a2 ,float b1, float b2, vec4 t)\r\n{\r\n\treturn b1+(t-a1)*(b2-b1)/(a2-a1);\r\n}\r\n\r\n\r\n\r\n\r\n\r\nvec2 N(float angle) {\r\n    return vec2(sin(angle), cos(angle));\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n//--------get soundtrack frequencies----\r\n\r\n\r\n    #ifdef MIC_INPUT\r\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\r\n    #else\r\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\r\n    #endif\r\n    float avgFreq = (freqs[0] +freqs[1] +freqs[2] +freqs[3])/4.;\r\n\r\n//--------image part---------\r\n    vec2 uv = (fragCoord.xy-.5*resolution.xy)/resolution.y;\r\n\tvec2 mouse = 1. - iMouse.xy/resolution.xy; // 0 1\r\n\tvec2 ouv = uv;\r\n    //uv.y -= .05;\r\n\r\n    uv = rot(uv,(sin(iTime*.1) / freqs[0]*.1  ) * PI  ) ;\r\n\tuv *= 4.0 - (avgFreq * 1.5  );\r\n\r\n    uv.x = abs(uv.x);\r\n\r\n    vec3 col = vec3(0);\r\n    float d;\r\n\r\n    float angle = 0.;\r\n    vec2 n = N((5./6.)*3.1415);\r\n\r\n    uv.y += tan((5./6.)*3.1415)*.5;\r\n   \td = dot(uv-vec2(.5, 0), n);\r\n    uv -= max(0.,d)*n*2.;\r\n\r\n    float scale = 1.;\r\n\r\n    n = N( freqs[0]*(2./3.)*3.1415);\r\n    uv.x += .5;\r\n    for(int i=0; i<10; i++) {\r\n        uv *= 3.;\r\n        scale *= 3.;\r\n        uv.x -= 1.5;\r\n\r\n        uv.x = abs(uv.x);\r\n        uv.x -= .5;\r\n        d = dot(uv, n);\r\n        uv -= min(0.,d)*n*2.;\r\n    }\r\n\r\n    d = length(uv/ clamp(freqs[2],0.1,.9 )- vec2(clamp(uv.x,-1., 1.), 0));\r\n    col += smoothstep(10./resolution.y, .0, d/scale);\r\n    uv /= scale;\t// normalization\r\n\r\n\r\n\tvec3 manCol = mandelbrotImg(uv);\r\n\t col += manCol;\r\n\r\n\r\n \t\t// vignette effect\r\n\t  col *= 1.0 - 0.5*length(uv *0.5) * freqs[1];\r\n\r\n\r\n    fragColor = vec4( col,1.0);\r\n}\r\n"},{id:"XsXXDn",name:"Creation by Silexars / Danilo Guanabara",shader:"// https://noisehack.com/build-music-visualizer-web-audio-api/ (adapted from)\r\n// https://www.shadertoy.com/view/XsXXDn\r\n// http://www.pouet.net/prod.php?which=57245\r\n// If you intend to reuse this shader, please add credits to 'Danilo Guanabara'\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\r\n    vec3 c;\r\n    float z = 0.1 * iTime;\r\n    vec2 uv = fragCoord.xy / iResolution;\r\n    vec2 p = uv - 0.5;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    float l = 0.2 * length(p);\r\n    for (int i = 0; i < 3; i++) {\r\n        z += 0.07;\r\n        uv += p / l * (sin(z) + 1.0) * abs(sin(l * 9.0 - z * 2.0));\r\n        c[i] = 0.01 / length(abs(mod(uv, 1.0) - 0.5));\r\n    }\r\n    float intensity = texture(iChannel0, vec2(l, 0.5)).x;\r\n    fragColor = vec4(c / l * intensity, iTime);\r\n}\r\n"},{id:"MdXGz4",name:"Nautilus by weyland",shader:"// Nautilus by weyland\r\n// https://www.shadertoy.com/view/MdXGz4\r\n\r\n\r\n// Nautilus 1k ...\r\n\r\nfloat e(vec3 c)\r\n{\r\n\tc=cos(vec3(cos(c.r+iTime/8.)*c.r-cos(c.g+iTime/9.)*c.g,c.b/3.*c.r-cos(iTime/7.)*c.g,c.r+c.g+c.b/1.25+iTime));\r\n\treturn dot(c*c,vec3(1.))-1.0;\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 c=-1.+2.*fragCoord.xy / iResolution.xy;\r\n    vec3 o=vec3(c.r,c.g+cos(iTime/2.)/30.,0),g=vec3(c.r+cos(iTime)/30.,c.g,1)/64.;\r\n    float m=1.0;\r\n\tfloat t=0.0;\r\n    for(int j=0;j<333;j++)\r\n    {\r\n        if( m>.4)\r\n\t\t{\r\n            t = (1.0+float(j))*2.0;\r\n   \t\t\tm = e(o+g*t);\r\n\t\t}\r\n    }\r\n    vec3 r=vec3(.1,0.,0.);\r\n\tvec3 n=m-vec3( e(vec3(o+g*t+r.rgg)),\r\n                   e(vec3(o+g*t+r.grg)),\r\n                   e(vec3(o+g*t+r.ggr)) );\r\n    vec3 v=vec3(dot(vec3(0,0,-.5),n)+dot(vec3(0.0,-.5,.5),n));\r\n    // edited below (ampcast)\r\n    vec2 uv = fragCoord.xy / iResolution;\r\n    vec2 p = uv - 0.5;\r\n    p.x *= iResolution.x / iResolution.y;\r\n    float l = 0.1 * length(p);\r\n    float intensity = texture(iChannel0, vec2(l, 0.5)).x;\r\n\tfragColor=vec4(v + intensity * vec3(.1+cos(iTime/14.)/8.,.1,.1-cos(iTime/3.)/19.)*(t/41.),iTime);\r\n}\r\n"},{id:"4sXfzj",name:"Quasicrystal Visualizer by Ebanflo",shader:"// Quasicrystal Visualizer by Ebanflo\r\n// https://www.shadertoy.com/view/4sXfzj\r\n\r\n\r\nconst int numWaves = 6;\r\nconst float numStripes = 1.0;\r\nconst float numFreqs = 8.0;\r\nconst float meanFreq = 4.0;\r\nconst float stdDev = 2.0;\r\nconst float period = 3.0;\r\nconst float pi = 4.0 * atan(1.0);\r\nconst float pi2 = 2.0 * pi;\r\nconst float ln2 = log(2.0);\r\nconst float mean = meanFreq * .69314718;\r\n\r\nfloat wavething(int n, float x){\r\n    float l = ln2 * float(n) + log(x);\r\n    l -= mean;\r\n    return exp(-l * l / stdDev) / 2.0;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    fragColor = vec4(0.0);\r\n    float scale = exp2(-fract(iTime / period));\r\n    float sum1 = 0.0;\r\n    for(int n = 0; n < int(numFreqs); n++){\r\n        sum1 += wavething(n, scale + 0.5*float(n));\r\n    }\r\n    vec2 xy = pi2 * numStripes\r\n        * ((2.0 * fragCoord - iResolution.xy) / iResolution.y);\r\n\r\n    float sum2 = 0.0;\r\n    for(int n = 0; n < numWaves; n++){\r\n        float theta = pi * float(n) / float(numWaves);\r\n        vec2 waveVec = vec2(cos(theta), sin(theta));\r\n        float phase = dot(xy, waveVec);\r\n        for(int k = 0; k < int(numFreqs); k++){\r\n            sum2 += cos(phase * scale * exp2(float(k))) * wavething(k, scale + 0.5*float(n));\r\n        }\r\n    }\r\n    fragColor += vec4(1.0 - sum2 / sum1);\r\n    xy /= pi2 * numStripes;\r\n    float r = length(xy);\r\n    fragColor.x *= texture(iChannel0, vec2(.161616 * r, .2)).x;\r\n    fragColor.y *= texture(iChannel0, vec2(.161616 * r + .161616, .2)).x;\r\n    fragColor.z *= texture(iChannel0, vec2(.161616 * r + .333333, .2)).x;\r\n    fragColor = 1.0 - fragColor;\r\n    fragColor = 1.0 - (r + 1.0) * fragColor;\r\n    if(length(fragColor) > 3.0) fragColor = vec4(0.0);\r\n}\r\n"},{id:"ttfGzH",name:"🎶 Rainbow soundviz 🎶 by avin",shader:"// https://www.shadertoy.com/view/ttfGzH\r\n#define PI 3.1415926\r\n#define PI2 6.2831852\r\n\r\n#define hue(h)clamp(abs(fract(h + vec4(3, 2, 1, 0) / 3.0) * 6.0 - 3.0) - 1.0 , 0.0, 1.0)\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n {\r\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\r\n\r\n    float CIRCLES = 20.0;\r\n    float cS = 0.375;\r\n\r\n    float sm = 1.0 / iResolution.y * 2.0; // smooth\r\n    float ps = 1.0 / iResolution.y * sqrt(iResolution.y) * 0.225; // circle thin\r\n\r\n    float d = length(uv);\r\n\r\n    float a = atan(uv.y, uv.x);\r\n    a = a < 0.0 ? PI + (PI - abs(a)) : a;\r\n\r\n    float lPos = a /PI2;\r\n\r\n    float m = 0.0;\r\n    float partSize = 1.0 / CIRCLES;\r\n    vec3 col;\r\n    for (float i = 20.0; i > 1.0; i -= 1.0) {\r\n        float ilPos = fract(lPos + i*0.1 + iTime * 0.1);\r\n        float cPos = partSize * i + ilPos * partSize;\r\n        float invPos = partSize * (i + 1.0) - ilPos * partSize;\r\n        float nzF = (1.0 - ilPos);\r\n        float mP0 = texture(iChannel0, vec2(partSize * i, 0.0)).x;\r\n        float mP = texture(iChannel0, vec2(cPos, 0.0)).x;\r\n        float mPInv = texture(iChannel0, vec2(invPos, 0.0)).x;\r\n\r\n        mP = (mP + mPInv) / 2.0;\r\n\r\n        float rDiff = i*(1.0 / CIRCLES * 0.35);\r\n        float r = mP * (1.0 / CIRCLES * 3.0) - rDiff;\r\n\r\n        float subm = smoothstep(cS - ps + r, cS - ps + sm + r, d) * smoothstep(cS + r, cS - sm + r, d);\r\n\r\n        if (subm > 0.0) {\r\n            col = hue(i / CIRCLES * 0.5 + iTime * 0.05 + mP0 * 0.84).rgb;\r\n        }\r\n\r\n        m += subm;\r\n    }\r\n\r\n    m = clamp(m, 0.0, 1.0);\r\n\r\n    float r = (sin(iTime * 0.5) * 0.5 + 0.5);\r\n    float b = (cos(iTime * 0.5) * 0.5 + 0.5);\r\n    vec3 backCol = vec3(r, 0.0, b) * length(uv * 0.75) * 0.5;\r\n\r\n    col = mix(backCol, col, m);\r\n\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"wd3XzS",name:"Audio-Visualizer by CoolerZ",shader:"// https://www.shadertoy.com/view/wd3XzS\r\nfloat sigmoid(float x)\r\n{\r\n    return 1. / (1. + exp(x));\r\n}\r\n\r\nvec3 sigmoid(vec3 xyz)\r\n{\r\n    return vec3(sigmoid(xyz.x), sigmoid(xyz.y), sigmoid(xyz.z));\r\n}\r\n\r\nfloat sample_at(float f)\r\n{\r\n    return texture(iChannel0, vec2(f / 16.0, 0.)).x;\r\n}\r\n\r\nfloat sample_multiple(float f)\r\n{\r\n    float delta = .1;\r\n    return 0.2 * (sample_at(f - 2. * delta) + sample_at(f - delta) + sample_at(f) + sample_at(f + delta) + sample_at(f + 2. * delta));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord.xy - 0.5) / iResolution.xy;\r\n    uv = 2. * uv - 1.;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n\r\n    vec2 center = vec2(0.);// 0.5 * vec2(cos(iTime), sin(iTime));\r\n    float d = length(uv - center);\r\n\r\n    float amplitude = sample_multiple(d * d);\r\n    d -= amplitude;\r\n    float weird = sigmoid(abs(uv.x) * abs(uv.y));\r\n    float speed = 6. * amplitude * sin(iTime * weird * 0.005) * 0.001;\r\n    float dist_diagonal = abs(abs(uv.x) - abs(uv.y));\r\n    dist_diagonal += d * amplitude;\r\n    dist_diagonal *= dist_diagonal;\r\n    amplitude += .1 / (.1 + smoothstep(1., 0.1, dist_diagonal));\r\n    float brightness = 3. * amplitude * sigmoid(sin(d * d * 16. - speed * iTime + 2. * speed * amplitude));\r\n\r\n    vec3 col = sigmoid(vec3(uv, sin(iTime)));\r\n\r\n    fragColor = vec4(col * brightness,1.0);\r\n}\r\n"},{id:"4sVBWy",name:"Radiant by Hazel Quantock",shader:"// https://www.shadertoy.com/view/4sVBWy\r\n// Radiant Music Visualiser\r\n// by Hazel Quantock 2018\r\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\r\n\r\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\r\n\r\n    float l = length(uv)/length(iResolution.xy/iResolution.y);\r\n    float a = atan(uv.x,uv.y)+iTime;\r\n    float s = texture(iChannel0,vec2(abs(fract(5.*a/6.283)*2.-1.),.75)).r;\r\n\r\n    float A = .4;\r\n    float B = .45;\r\n    if ( iMouse.z > 0. )\r\n    {\r\n        A = iMouse.x / iResolution.x; // strength of chromatic dispersion\r\n        B = iMouse.y / iResolution.y; // strength of waveform\r\n    }\r\n    A *= A; // apply a curve so mouse movements feel better\r\n    B *= B;\r\n\r\n    fragColour.r = texture(iChannel0,vec2(pow(mix(mix(l,.0,A),    s ,B),2.),.25)).r;\r\n    fragColour.g = texture(iChannel0,vec2(pow(mix(mix(l,.5,A),(1.-s),B),2.),.25)).r;\r\n    fragColour.b = texture(iChannel0,vec2(pow(mix(mix(l,1.,A),    s ,B),2.),.25)).r;\r\n\r\n    // tweak the contrast\r\n    fragColour.rgb = smoothstep(.05,1.,fragColour.rgb+.2*l);\r\n    fragColour.rgb = pow( fragColour.rgb, vec3(2) );\r\n\r\n    fragColour.a = 1.;\r\n}\r\n"},{id:"ltc3WH",name:"ambilight visualization 2.0 by MillhausVKodi",shader:'// https://www.shadertoy.com/view/ltc3WH\r\nconst float bands = 20.0;\r\nconst float leds = 25.0;\r\nconst float colorRange = 0.3; // >0. (=1. full color range, >1. repeat colors)\r\n\r\n\r\n//convert HSV to RGB\r\nvec3 hsv2rgb(vec3 c){\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // middle = (0/0)\r\n    vec2 k=(fragCoord.xy-.5*iResolution.xy)/(max(iResolution.x,iResolution.y));\r\n\r\n\r\n\r\n    //distance from the middle\r\n    float dis = distance(k , vec2(0));\r\n\r\n    //and approximated by "leds"\r\n    float disA = floor(dis*leds)/leds;\r\n    //disA = dis;\r\n\r\n\r\n    //degree from bottom 0 and top 1.0.  /left right symetric\r\n    float deg = acos(k.y/dis)/3.14;\r\n\r\n    //and approximated by "bands"\r\n    float degA = floor(deg*bands)/bands;\r\n\r\n\r\n\r\n   //colorwheel, dark in the middle, changing colors over time\r\n    vec3 color = hsv2rgb(  vec3( degA*colorRange + iTime*0.07 , 1.0 , smoothstep(0.0, 0.6, disA) )  );\r\n\r\n\r\n\r\n\t//brightness of a band by fourier (degree to frequency / magnitude to brightness)\r\n    float bandBrightness = texture( iChannel0, vec2(degA,0.25)).x;\r\n\r\n\r\n    //more blinky blinky x^2\r\n    color*=bandBrightness*bandBrightness;\r\n\r\n    //brighter\r\n    color*=4.;\r\n\r\n\r\n\r\n    float deltaDeg = fract((deg-degA)*bands) - 0.5;\r\n    float deltaDis = fract((dis-disA)*leds) - 0.5;\r\n\r\n    float shape = smoothstep(0.5, 0.35, abs(deltaDeg)) *\r\n                smoothstep(0.5, 0.35, abs(deltaDis));\r\n\r\n\r\n    color*=shape;\r\n\r\n\t//return\r\n    fragColor = vec4(color, 1.0);\r\n}\r\n'},{id:"llXBWB",name:"Bubbles music visualizer by liyouvane",shader:"// https://www.shadertoy.com/view/llXBWB\r\n// reference : https://github.com/ashima/webgl-noise\r\n// reference : I/O fragment shader by movAX13h, August 2013\r\n// https://www.shadertoy.com/view/XsfGDS\r\n\r\n#define SHOW_BLOCKS\r\n\r\nvec4 mod289(vec4 x)\r\n{\r\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\r\n}\r\n\r\nvec4 permute(vec4 x)\r\n{\r\n  return mod289(((x*34.0)+1.0)*x);\r\n}\r\n\r\nvec4 taylorInvSqrt(vec4 r)\r\n{\r\n  return 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nvec2 fade(vec2 t) {\r\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\r\n}\r\n\r\n// Classic Perlin noise\r\nfloat cnoise(vec2 P)\r\n{\r\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\r\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\r\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\r\n  vec4 ix = Pi.xzxz;\r\n  vec4 iy = Pi.yyww;\r\n  vec4 fx = Pf.xzxz;\r\n  vec4 fy = Pf.yyww;\r\n\r\n  vec4 i = permute(permute(ix) + iy);\r\n\r\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\r\n  vec4 gy = abs(gx) - 0.5;\r\n  vec4 tx = floor(gx + 0.5);\r\n  gx = gx - tx;\r\n\r\n  vec2 g00 = vec2(gx.x,gy.x);\r\n  vec2 g10 = vec2(gx.y,gy.y);\r\n  vec2 g01 = vec2(gx.z,gy.z);\r\n  vec2 g11 = vec2(gx.w,gy.w);\r\n\r\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\r\n  g00 *= norm.x;\r\n  g01 *= norm.y;\r\n  g10 *= norm.z;\r\n  g11 *= norm.w;\r\n\r\n  float n00 = dot(g00, vec2(fx.x, fy.x));\r\n  float n10 = dot(g10, vec2(fx.y, fy.y));\r\n  float n01 = dot(g01, vec2(fx.z, fy.z));\r\n  float n11 = dot(g11, vec2(fx.w, fy.w));\r\n\r\n  vec2 fade_xy = fade(Pf.xy);\r\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\r\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\r\n  return 2.3 * n_xy;\r\n}\r\n\r\n\r\nfloat rand(float x)\r\n{\r\n    return fract(sin(x) * 4358.5453123);\r\n}\r\n\r\nfloat rand(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357);\r\n}\r\n\r\nfloat circle(vec2 p, vec2 b, float r)\r\n{\r\n  return length(p-b)-r;\r\n}\r\n\r\nfloat box(vec2 p, vec2 b, float r)\r\n{\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\nfloat sampleMusic()\r\n{\r\n\treturn 0.5 * (\r\n//\t\ttexture( iChannel0, vec2( 0.01, 0.25 ) ).x +\r\n//\t\ttexture( iChannel0, vec2( 0.07, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tconst float speed = 0.4;\r\n\tconst float ySpread = 1.6;\r\n\tconst int numBlocks = 30;\r\n\tconst int numBubbles = 50;\r\n\tfloat pulse = sampleMusic();\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tfloat aspect = iResolution.x / iResolution.y;\r\n\tvec3 baseColor = uv.x > 0.0 ? vec3(0.0,0.3, 0.3) : vec3(0.3, 0.0, 0.3);\r\n\r\n\tvec3 color = 5. * pulse*baseColor*0.5*(0.9-cos(uv.x*8.0));\r\n\tuv.x *= aspect;\r\n\r\n\tfor (int i = 0; i < numBubbles; i++)\r\n\t{\r\n\t\tfloat z = 1.0-0.7*rand(float(i)*1.4333); // 0=far, 1=near\r\n\t\tfloat tickTime = iTime*z*speed + float(i)*1.23753;\r\n\t\tfloat tick = floor(tickTime);\r\n\r\n\t\tvec2 pos = vec2(0.6*aspect*(rand(tick)-0.5), -abs(sign(uv.x))*ySpread*(0.5-fract(tickTime)));\r\n\t\tpos.x += 0.18*sign(pos.x); // move aside\r\n\t\tif (abs(pos.x) < 0.1) pos.x++; // stupid fix; sign sometimes returns 0\r\n\r\n\t\tvec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1*rand(tick+0.2));\r\n\t\tfloat b = circle(uv, pos, 0.01 + 0.15 * pulse);\r\n\t\tfloat dust = z*smoothstep(0.22, 0.0, b)*pulse*0.5;\r\n\t\tfloat block = 0.2*z*smoothstep(0.012, 0.0, b);\r\n\t\tfloat shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\r\n        float u_Scale = 9.;\r\n        float noise = sin(abs(cnoise(u_Scale * uv.xy)+0.5*cnoise(2. * u_Scale * uv.xy)+0.25*cnoise(4. * u_Scale * uv.xy)+0.125*cnoise(8. * u_Scale * uv.xy)));\r\n\t\tcolor += dust*baseColor*(1.+3. * noise) + block*z + shine;\r\n\t}\r\n    baseColor = vec3(0.1, 0.3, 0.0);\r\n    for (int i = 0; i < numBlocks; i++)\r\n\t{\r\n\t\tfloat z = 1.0-0.7*rand(float(i)*1.4333); // 0=far, 1=near\r\n\t\tfloat tickTime = iTime*z*speed + float(i)*1.23753;\r\n\t\tfloat tick = floor(tickTime);\r\n\r\n\t\tvec2 pos = vec2(0.6*aspect*(rand(tick)-0.5), -abs(sign(uv.x))*ySpread*(0.5-fract(tickTime)));\r\n\t\tpos.x += 0.24*sign(pos.x); // move aside\r\n\t\tif (abs(pos.x) < 0.1) pos.x++; // stupid fix; sign sometimes returns 0\r\n\r\n\t\tvec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1*rand(tick+0.2));\r\n\t\tfloat b = circle(uv-pos, size, 0.02);\r\n\t\tfloat dust = z*smoothstep(0.22, 0.0, b)*pulse*0.5;\r\n\t\tfloat block = 0.2*z*smoothstep(0.002, 0.0, b);\r\n\t\tfloat shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\r\n        float u_Scale = 9.;\r\n        float noise = sin(abs(cnoise(u_Scale * uv.xy)+0.5*cnoise(2. * u_Scale * uv.xy)+0.25*cnoise(4. * u_Scale * uv.xy)+0.125*cnoise(8. * u_Scale * uv.xy)));\r\n\t\tcolor += dust*baseColor*(1.+noise) + block*z + shine;\r\n\t}\r\n\tcolor /= 1.5;\r\n\tcolor -= rand(uv)*0.04;\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"XtVSDt",name:"Soap Bubble Music Visualizer #1 by Ruzzyr",shader:"// https://www.shadertoy.com/view/XtVSDt\r\nmat3 rotateYmat(float ang)\r\n{\r\n    return mat3(cos(ang), 0.0, sin(ang),\r\n                0.0, 1.0, 0.0,\r\n                -sin(ang), 0.0, cos(ang));\r\n}\r\nmat3 rotateXmat(float ang)\r\n{\r\n    return mat3(1.0, -0.0, 0.0,\r\n                0.0, cos(ang), -sin(ang),\r\n                0.0, sin(ang), cos(ang));\r\n}\r\n\r\nmat3 rotateZmat(float ang)\r\n{\r\n    return mat3(cos(ang), -sin(ang), 0.0,\r\n                sin(ang), cos(ang), 0.0,\r\n                0.0, 0.0, 1.0);\r\n}\r\n\r\nfloat map( vec3 p, vec3 origin, float s )\r\n{\r\n    vec3 offset = vec3(sin(p.x*2. + iTime*2.),cos(p.z*10. + iTime*2.),1.0)*0.1;\r\n\tfloat d = length(p + offset - origin)- s;\r\n\toffset = vec3(sin(p.x*3. + iTime*2.),cos(p.z*2. + iTime*2.),1.0)*0.2;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n\r\n        float prism2 = length(p + offset*float(i) - origin)- s;\r\n        d = max(d, -prism2);\r\n    }\r\n  \treturn d;\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy/iResolution.xy;\r\n    uv = uv*2.0-1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n\r\n    mat3 rotation = //mat3(1.0);\r\n      rotateXmat(iTime*0.4)*rotateYmat(iTime*0.5);\r\n    vec3 direction = normalize(vec3(uv.x,uv.y, 1.0)*rotation);\r\n\r\n\r\n\r\n\r\n    float t = 0.0;\r\n\tvec3 p;\r\n    vec3 finalColor;\r\n\r\n    vec3 origin = vec3(0.,0.,-4.)*rotation;\r\n    vec3 offset;\r\n    vec3 sphereOrigin = vec3(0., 0., 0.0);\r\n\r\n    vec4 sound = texture (iChannel0,vec2(fragCoord.x/iResolution.x, 0.75));\r\n    float soundColor = texture (iChannel0,vec2(0.5, 0.75)).x;\r\n\r\n    vec3 color = vec3(.5 + sin(uv.x+iTime +soundColor*50.)*.4,.5 +cos(uv.y+iTime + soundColor*5.)*.5,.5);\r\n    for (int k = 0; k <15; k++)\r\n    {\r\n        p = origin + t*direction;\r\n        float d = map(p,sphereOrigin, 2.0);\r\n\r\n        {\r\n            vec3 directionalOffset = -normalize(p)*sound.x*normalize(vec3(uv, 1.0));\r\n            vec3 position = p + directionalOffset;\r\n            float radius = 0.1+float(k)*.5;\r\n            float lineThickness = 0.02 + float(k)*0.01;\r\n            //position.y += position.y*abs(uv.x);\r\n            float distanceFromCenter = length(position);\r\n            float condition = step( distanceFromCenter, radius)\r\n                - step(distanceFromCenter, radius - lineThickness);\r\n            finalColor += color*condition;\r\n        }\r\n\r\n        t += d;\r\n    }\r\n    float fog = 1.0/(1.0+t*t*0.1);\r\n    fragColor = vec4(finalColor+color*vec3(fog), fog);\r\n\r\n}\r\n"},{id:"XsBXWt",name:"Fractal Land by Kali",shader:'// https://www.shadertoy.com/view/XsBXWt\r\n// "Fractal Cartoon" - former "DE edge detection" by Kali\r\n\r\n// There are no lights and no AO, only color by normals and dark edges.\r\n\r\n// update: Nyan Cat cameo, thanks to code from mu6k: https://www.shadertoy.com/view/4dXGWH\r\n\r\n\r\n//#define SHOWONLYEDGES\r\n// #define NYAN\r\n#define WAVES\r\n#define BORDER\r\n\r\n#define RAY_STEPS 150\r\n\r\n#define BRIGHTNESS 1.2\r\n#define GAMMA 1.4\r\n#define SATURATION .65\r\n\r\n\r\n#define detail .001\r\n#define t iTime*.5\r\n\r\n\r\nconst vec3 origin=vec3(-1.,.7,0.);\r\nfloat det=0.0;\r\n\r\n\r\n// 2D rotation function\r\nmat2 rot(float a) {\r\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\r\n}\r\n\r\n// "Amazing Surface" fractal\r\nvec4 formula(vec4 p) {\r\n\t\tp.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\r\n\t\tp.y-=.25;\r\n\t\tp.xy*=rot(radians(35.));\r\n\t\tp=p*2./clamp(dot(p.xyz,p.xyz),.2,1.);\r\n\treturn p;\r\n}\r\n\r\n// Distance function\r\nfloat de(vec3 pos) {\r\n#ifdef WAVES\r\n\tpos.y+=sin(pos.z-t*6.)*.15; //waves!\r\n#endif\r\n\tfloat hid=0.;\r\n\tvec3 tpos=pos;\r\n\ttpos.z=abs(3.-mod(tpos.z,6.));\r\n\tvec4 p=vec4(tpos,1.);\r\n\tfor (int i=0; i<4; i++) {p=formula(p);}\r\n\tfloat fr=(length(max(vec2(0.),p.yz-1.5))-1.)/p.w;\r\n\tfloat ro=max(abs(pos.x+1.)-.3,pos.y-.35);\r\n\t\t  ro=max(ro,-max(abs(pos.x+1.)-.1,pos.y-.5));\r\n\tpos.z=abs(.25-mod(pos.z,.5));\r\n\t\t  ro=max(ro,-max(abs(pos.z)-.2,pos.y-.3));\r\n\t\t  ro=max(ro,-max(abs(pos.z)-.01,-pos.y+.32));\r\n\tfloat d=min(fr,ro);\r\n\treturn d;\r\n}\r\n\r\n\r\n// Camera path\r\nvec3 path(float ti) {\r\n\tti*=1.5;\r\n\tvec3  p=vec3(sin(ti),(1.-sin(ti*2.))*.5,-ti*5.)*.5;\r\n\treturn p;\r\n}\r\n\r\n// Calc normals, and here is edge detection, set to variable "edge"\r\n\r\nfloat edge=0.;\r\nvec3 normal(vec3 p) {\r\n\tvec3 e = vec3(0.0,det*5.,0.0);\r\n\r\n\tfloat d1=de(p-e.yxx),d2=de(p+e.yxx);\r\n\tfloat d3=de(p-e.xyx),d4=de(p+e.xyx);\r\n\tfloat d5=de(p-e.xxy),d6=de(p+e.xxy);\r\n\tfloat d=de(p);\r\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\r\n\tedge=min(1.,pow(edge,.55)*15.);\r\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\r\n}\r\n\r\n\r\n// Used Nyan Cat code by mu6k, with some mods\r\n\r\nvec4 rainbow(vec2 p)\r\n{\r\n\tfloat q = max(p.x,-0.1);\r\n\tfloat s = sin(p.x*7.0+t*70.0)*0.08;\r\n\tp.y+=s;\r\n\tp.y*=1.1;\r\n\r\n\tvec4 c;\r\n\tif (p.x>0.0) c=vec4(0,0,0,0); else\r\n\tif (0.0/6.0<p.y&&p.y<1.0/6.0) c= vec4(255,43,14,255)/255.0; else\r\n\tif (1.0/6.0<p.y&&p.y<2.0/6.0) c= vec4(255,168,6,255)/255.0; else\r\n\tif (2.0/6.0<p.y&&p.y<3.0/6.0) c= vec4(255,244,0,255)/255.0; else\r\n\tif (3.0/6.0<p.y&&p.y<4.0/6.0) c= vec4(51,234,5,255)/255.0; else\r\n\tif (4.0/6.0<p.y&&p.y<5.0/6.0) c= vec4(8,163,255,255)/255.0; else\r\n\tif (5.0/6.0<p.y&&p.y<6.0/6.0) c= vec4(122,85,255,255)/255.0; else\r\n\tif (abs(p.y)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\r\n\tif (abs(p.y-1.)-.05<0.0001) c=vec4(0.,0.,0.,1.); else\r\n\t\tc=vec4(0,0,0,0);\r\n\tc.a*=.8-min(.8,abs(p.x*.08));\r\n\tc.xyz=mix(c.xyz,vec3(length(c.xyz)),.15);\r\n\treturn c;\r\n}\r\n\r\nvec4 nyan(vec2 p)\r\n{\r\n\tvec2 uv = p*vec2(0.4,1.0);\r\n\tfloat ns=3.0;\r\n\tfloat nt = iTime*ns; nt-=mod(nt,240.0/256.0/6.0); nt = mod(nt,240.0/256.0);\r\n\tfloat ny = mod(iTime*ns,1.0); ny-=mod(ny,0.75); ny*=-0.05;\r\n\tvec4 color = texture(iChannel1,vec2(uv.x/3.0+210.0/256.0-nt+0.05,.5-uv.y-ny));\r\n\tif (uv.x<-0.3) color.a = 0.0;\r\n\tif (uv.x>0.2) color.a=0.0;\r\n\treturn color;\r\n}\r\n\r\n\r\n// Raymarching and 2D graphics\r\n\r\nvec3 raymarch(in vec3 from, in vec3 dir)\r\n\r\n{\r\n\tedge=0.;\r\n\tvec3 p, norm;\r\n\tfloat d=100.;\r\n\tfloat totdist=0.;\r\n\tfor (int i=0; i<RAY_STEPS; i++) {\r\n\t\tif (d>det && totdist<25.0) {\r\n\t\t\tp=from+totdist*dir;\r\n\t\t\td=de(p);\r\n\t\t\tdet=detail*exp(.13*totdist);\r\n\t\t\ttotdist+=d;\r\n\t\t}\r\n\t}\r\n\tvec3 col=vec3(0.);\r\n\tp-=(det-d)*dir;\r\n\tnorm=normal(p);\r\n#ifdef SHOWONLYEDGES\r\n\tcol=1.-vec3(edge); // show wireframe version\r\n#else\r\n\tcol=(1.-abs(norm))*max(0.,1.-edge*.8); // set normal as color with dark edges\r\n#endif\r\n\ttotdist=clamp(totdist,0.,26.);\r\n\tdir.y-=.02;\r\n\tfloat sunsize=7.-max(0.,texture(iChannel0,vec2(.6,.2)).x)*3.; // responsive sun size\r\n\tfloat an=atan(dir.x,dir.y)+iTime*1.5; // angle for drawing and rotating sun\r\n\tfloat s=pow(clamp(1.0-length(dir.xy)*sunsize-abs(.2-mod(an,.4)),0.,1.),.1); // sun\r\n\tfloat sb=pow(clamp(1.0-length(dir.xy)*(sunsize-.2)-abs(.2-mod(an,.4)),0.,1.),.1); // sun border\r\n\tfloat sg=pow(clamp(1.0-length(dir.xy)*(sunsize-4.5)-.5*abs(.2-mod(an,.4)),0.,1.),3.); // sun rays\r\n\tfloat y=mix(.45,1.2,pow(smoothstep(0.,1.,.75-dir.y),2.))*(1.-sb*.5); // gradient sky\r\n\r\n\t// set up background with sky and sun\r\n\tvec3 backg=vec3(0.5,0.,1.)*((1.-s)*(1.-sg)*y+(1.-sb)*sg*vec3(1.,.8,0.15)*3.);\r\n\t\t backg+=vec3(1.,.9,.1)*s;\r\n\t\t backg=max(backg,sg*vec3(1.,.9,.5));\r\n\r\n\tcol=mix(vec3(1.,.9,.3),col,exp(-.004*totdist*totdist));// distant fading to sun color\r\n\tif (totdist>25.) col=backg; // hit background\r\n\tcol=pow(col,vec3(GAMMA))*BRIGHTNESS;\r\n\tcol=mix(vec3(length(col)),col,SATURATION);\r\n#ifdef SHOWONLYEDGES\r\n\tcol=1.-vec3(length(col));\r\n#else\r\n\tcol*=vec3(1.,.9,.85);\r\n#ifdef NYAN\r\n\tdir.yx*=rot(dir.x);\r\n\tvec2 ncatpos=(dir.xy+vec2(-3.+mod(-t,6.),-.27));\r\n\tvec4 ncat=nyan(ncatpos*5.);\r\n\tvec4 rain=rainbow(ncatpos*10.+vec2(.8,.5));\r\n\tif (totdist>8.) col=mix(col,max(vec3(.2),rain.xyz),rain.a*.9);\r\n\tif (totdist>8.) col=mix(col,max(vec3(.2),ncat.xyz),ncat.a*.9);\r\n#endif\r\n#endif\r\n\treturn col;\r\n}\r\n\r\n// get camera position\r\nvec3 move(inout vec3 dir) {\r\n\tvec3 go=path(t);\r\n\tvec3 adv=path(t+.7);\r\n\tfloat hd=de(adv);\r\n\tvec3 advec=normalize(adv-go);\r\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\r\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\r\n    an=advec.y*1.7;\r\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\r\n\tan=atan(advec.x,advec.z);\r\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\r\n\treturn go;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\r\n\tvec2 oriuv=uv;\r\n\tuv.y*=iResolution.y/iResolution.x;\r\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\r\n\tif (iMouse.z<1.) mouse=vec2(0.,-0.05);\r\n\tfloat fov=.9-max(0.,.7-iTime*.3);\r\n\tvec3 dir=normalize(vec3(uv*fov,1.));\r\n\tdir.yz*=rot(mouse.y);\r\n\tdir.xz*=rot(mouse.x);\r\n\tvec3 from=origin+move(dir);\r\n\tvec3 color=raymarch(from,dir);\r\n\t#ifdef BORDER\r\n\tcolor=mix(vec3(0.),color,pow(max(0.,.95-length(oriuv*oriuv*oriuv*vec2(1.05,1.1))),.3));\r\n\t#endif\r\n\tfragColor = vec4(color,1.);\r\n}\r\n'},{id:"4s33Rj",name:"Music MandelBox Colour by pixelbeast",shader:"// https://www.shadertoy.com/view/4s33Rj\r\n\r\n// Iain Melvin, 2015\r\n// fft distortions of mandlebox 3d, colour\r\n// with help from:\r\n// https://www.shadertoy.com/view/XsB3Rm  // Original Raymarch tutorial (iq)\r\n// https://www.shadertoy.com/view/ldSGRK  // for mandlebox formula (klems)\r\n// Raymarch tutorial: - iq/2013\r\n\r\n\r\nfloat mandel3D(vec3 z,float fft){\r\n  const float scale=3.5; //2.0; // -1.5\r\n  const float r=0.5;\r\n  const float f=1.125;\r\n  vec3 offset = z;\r\n  const int niter = 13;\r\n  float dr = 1.0;\r\n  for (int i=0;i<niter;i++){\r\n\t//fold\r\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\r\n\t//warp\r\n\tfloat l = length(z);\r\n\tif (l<r){\r\n\t  z/=r*r;\r\n\t}else if (l<1.0){\r\n\t  z/=l*l;\r\n\t}\r\n\tz*=scale;\r\n\tdr = dr * abs(scale) + 1.0;\r\n\t// scale by fft\r\n\tfloat fft_scale = 1.0-(fft*0.34);\r\n\tz*=fft_scale;\r\n\t//dr = dr * fft_scale; // I think there is something to do here\r\n\tz+=offset;\r\n  }\r\n  float zr = length(z);\r\n  return zr / abs(dr);\r\n}\r\n\r\nvec2 map( in vec3 pos ) {\r\n    float d = length(pos);\r\n    float fft = 0.8*texture(iChannel0, vec2((d/32.0),0.3) )[0];\r\n\treturn vec2(mandel3D(pos*1.5,fft),fft);\r\n}\r\n\r\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ){\r\n\tfloat precis = 0.015;\r\n    float h=precis*2.0;\r\n    float t = 0.0;\r\n    float m = -1.0;\r\n    for( int i=0; i<120; i++ )\r\n    {\r\n        if( abs(h)<precis||t>maxd ) break;\r\n        t += h;\r\n\t    vec2 res = map( ro+rd*t );\r\n        h = res.x; //dist to solid\r\n\t    m = res.y; //fft\r\n    }\r\n    if (t>maxd) { t=-0.5; m=0.0; }\r\n    return vec2( t, m );\r\n}\r\n\r\nvec3 calcNormal( in vec3 pos ){\r\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\r\n\tvec3 nor = vec3(\r\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\r\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\r\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\r\n\treturn normalize(nor);\r\n}\r\n\r\n// iq's smooth hsv to rgb\r\nvec3 hsv2rgb( in vec3 c ){\r\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\r\n\trgb = rgb*rgb*(3.0-2.0*rgb);\r\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 col = vec3(0.0);\r\n    vec2 res = castRay(ro,rd,15.0);\r\n    float t = res.x; // dist to func\r\n\tfloat m = res.y; // fft intense at collision\r\n    vec3 pos = ro + t*rd;\r\n    vec3 nor = calcNormal( pos );\r\n    if (t==-0.5) { nor=vec3(1.0,0.0,0.0); }\r\n\r\n\tcol = hsv2rgb(vec3(m*2.0,1.0,1.0)); // hue sat lum\r\n\r\n    float ao = 1.0;\r\n\r\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\r\n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\r\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\r\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\r\n\tfloat sh = 1.0;\r\n\r\n\tvec3 brdf = vec3(0.0);\r\n\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\r\n    brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\r\n    brdf += 2.20*dif*vec3(1.00,0.90,0.70);\r\n\r\n\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\r\n\tfloat spe = sh*pow(pp,16.0);\r\n\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\r\n\r\n\tcol = col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\r\n\r\n\treturn vec3( clamp(col,0.0,10.0) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 q = fragCoord.xy/iResolution.xy;\r\n    vec2 p = -1.0+2.0*q;\r\n\tp.x *= iResolution.x/iResolution.y;\r\n    vec2 mo = iMouse.xy/iResolution.xy;\r\n\r\n\tfloat time = -55.0; //+ iTime;\r\n\r\n    vec3 d = vec3(0.25*mo.x,0.25*mo.y,0.0);\r\n\r\n    d.x += 5.5*(1.0-cos(0.6*iTime));\r\n    d.y += 2.5*(1.0-cos(0.05*iTime));\r\n\r\n\t// camera\r\n\tvec3 ro = vec3( d.x, d.y, 6.0 );\r\n    vec3 ta = vec3( -0.0, -0.0, 0.0 );\r\n\r\n\t// camera tx\r\n\tvec3 cw = normalize( ta-ro );\r\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\r\n\tvec3 cu = normalize( cross(cw,cp) );\r\n\tvec3 cv = normalize( cross(cu,cw) );\r\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\r\n\r\n    vec3 col = render( ro, rd );\r\n\tcol = sqrt( col );\r\n\r\n    fragColor=vec4( col, 1.0 );\r\n}\r\n"},{id:"4lyXWW",name:"FFT-IFS by nshelton",shader:"// https://www.shadertoy.com/view/4lyXWW\r\n//#define MAX_ITER 20\r\n#define MAX_ITER 50\r\n\r\nmat3 rotationMatrix(vec3 axis, float angle) {\r\n    float s = sin(angle);\r\n    float c = cos(angle);\r\n    float oc = 1.0 - c;\r\n\r\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\r\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\r\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\r\n}\r\n\r\n\r\nfloat udBox( vec3 p, vec3 b )\r\n{\r\n  return length(max(abs(p)-b,0.0));\r\n}\r\n\r\nmat3 ir;\r\n\r\nfloat DE(vec3 p)\r\n{\r\n\tvec3 p_o = p;\r\n    float d = 1e10;\r\n\r\n    float s = 1.; //sin(iTime /60.0) / 10.0 + 0.6;\r\n    vec3 t = vec3(0.1 + 0.2 * iMouse.xy/iResolution.xy, 0.1 + 0.1 * sin(iTime/200.));\r\n\r\n    float fftVal = texture(iChannel0,vec2(length(p/5.), 0.2)).x *0.1;\r\n    vec3 dim = vec3( fftVal, 0.9, fftVal);\r\n\r\n    for ( int i = 0; i < 6; i ++)\r\n    {\r\n        p -= t*s;\r\n        p = (ir * (p-t/s));\r\n\r\n     \t//d = min\t(d, udBox(p*s, dim/s) /s);\r\n\r\n \t\tp = abs(p);\r\n\r\n\r\n\r\n        float circleSize = fftVal + 0.03 * (sin(iTime + length(p_o) * 5.) )\r\n            + 0.01;\r\n        d = min(d, length(p - t) - circleSize/s);\r\n        s *= s;\r\n\r\n    }\r\n\r\n\r\n    return d;\r\n}\r\n\r\n\r\nfloat lighting( in vec3 ro, in vec3 rd)\r\n{\r\n    float res = 1.0;\r\n    float t = 0.01;\r\n\r\n    float k = 12.0;\r\n\r\n    for( int i = 0; i < 2; i++ )\r\n    {\r\n        float h = DE(ro + rd*t);\r\n        if( h<0.001 )\r\n            return 0.0;\r\n\r\n        res = min( res,k * h/t );\r\n        t += h;\r\n    }\r\n    return res;\r\n}\r\n\r\nvec3 gradient(vec3 p) {\r\n\tvec2 e = vec2(0., 0.0001);\r\n\r\n\treturn normalize(\r\n\t\tvec3(\r\n\t\t\tDE(p+e.yxx) - DE(p-e.yxx),\r\n\t\t\tDE(p+e.xyx) - DE(p-e.xyx),\r\n\t\t\tDE(p+e.xxy) - DE(p-e.xxy)\r\n\t\t)\r\n\t);\r\n}\r\n\r\n\r\n\r\n\r\n//https://iquilezles.org/articles/fog\r\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\r\n               in float distance, // camera to point distance\r\n               in vec3  rayDir,   // camera to point vector\r\n               in vec3  sunDir )  // sun light direction\r\n{\r\n    float b = .9 + 20.0 / float(MAX_ITER);\r\n    float fogAmount = 1.0 - exp( -distance*b );\r\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\r\n    vec3  fogColor  = mix( vec3(0.1,0.1,0.0),\r\n                           vec3(1.0,0.9,0.7),\r\n                           pow(sunAmount,8.0) );\r\n    return mix( rgb, fogColor, fogAmount );\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    uv -= 0.5;\r\n    float aspect = iResolution.x/iResolution.y;\r\n    uv.x *= aspect;\r\n\r\n    vec3 cam = vec3(0,0, - sin(iTime /32. ) - 2.0);\r\n    vec3 ray = normalize( vec3(uv, 1.0));\r\n\r\n    vec3 color = vec3(0.1, 0.1, 0.2);\r\n    vec3 p;\r\n    float depth = 0.0;\r\n    bool hit = false;\r\n    float iter = 0.0;\r\n\r\n    float fog = 0.0;\r\n    vec3 sun = normalize( vec3(1,1,1));\r\n\r\n    ir = rotationMatrix(normalize(vec3(sin(iTime/50.0),sin(iTime/100.0),sin(iTime/150.0))), 1.5 + iTime/30.0);\r\n\r\n    mat3 mv = rotationMatrix(vec3(0,1,0), iTime/10.0);\r\n\r\n    cam = mv * cam;\r\n    ray = mv * ray;\r\n\r\n    for( int i= 0; i < MAX_ITER; i ++) {\r\n        p = depth * ray + cam;\r\n        float dist = DE(p);\r\n\r\n\r\n        \tdepth += dist * 0.9;\r\n\r\n\r\n        if ( dist < 0.001)\r\n        {\r\n        \thit = true;\r\n            break;\r\n        }\r\n\r\n        iter ++;\r\n    }\r\n    float fakeAO = 1.0 - iter / float(MAX_ITER);\r\n    vec3 n = gradient(p);\r\n\r\n\r\n    if (hit) {\r\n    \tcolor = vec3(fakeAO + dot(-ray,n) / 2.0);\r\n    }\r\n\r\n\r\n\tcolor = applyFog(color, depth, ray, sun) ;\r\n\r\n   //color *= vec3(1.0 - fog);\r\n\r\n    color = pow(color, vec3(0.6));\r\n\r\n\r\n\tfragColor = vec4(color ,1.0);\r\n}\r\n"},{id:"XsfGDS",name:"I/O by movAX13h",shader:"// https://www.shadertoy.com/view/XsfGDS\r\n// I/O fragment shader by movAX13h, August 2013\r\n\r\n#define SHOW_BLOCKS\r\n\r\nfloat rand(float x)\r\n{\r\n    return fract(sin(x) * 4358.5453123);\r\n}\r\n\r\nfloat rand(vec2 co)\r\n{\r\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5357);\r\n}\r\n\r\nfloat box(vec2 p, vec2 b, float r)\r\n{\r\n  return length(max(abs(p)-b,0.0))-r;\r\n}\r\n\r\nfloat sampleMusic()\r\n{\r\n\treturn 0.5 * (\r\n\t\t//texture( iChannel0, vec2( 0.01, 0.25 ) ).x +\r\n\t\t//texture( iChannel0, vec2( 0.07, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tconst float speed = 0.7;\r\n\tconst float ySpread = 1.6;\r\n\tconst int numBlocks = 70;\r\n\r\n\tfloat pulse = sampleMusic();\r\n\r\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\r\n\tfloat aspect = iResolution.x / iResolution.y;\r\n\tvec3 baseColor = uv.x > 0.0 ? vec3(0.0,0.3, 0.6) : vec3(0.6, 0.0, 0.3);\r\n\r\n\tvec3 color = pulse*baseColor*0.5*(0.9-cos(uv.x*8.0));\r\n\tuv.x *= aspect;\r\n\r\n\tfor (int i = 0; i < numBlocks; i++)\r\n\t{\r\n\t\tfloat z = 1.0-0.7*rand(float(i)*1.4333); // 0=far, 1=near\r\n\t\tfloat tickTime = iTime*z*speed + float(i)*1.23753;\r\n\t\tfloat tick = floor(tickTime);\r\n\r\n\t\tvec2 pos = vec2(0.6*aspect*(rand(tick)-0.5), sign(uv.x)*ySpread*(0.5-fract(tickTime)));\r\n\t\tpos.x += 0.24*sign(pos.x); // move aside\r\n\t\tif (abs(pos.x) < 0.1) pos.x++; // stupid fix; sign sometimes returns 0\r\n\r\n\t\tvec2 size = 1.8*z*vec2(0.04, 0.04 + 0.1*rand(tick+0.2));\r\n\t\tfloat b = box(uv-pos, size, 0.01);\r\n\t\tfloat dust = z*smoothstep(0.22, 0.0, b)*pulse*0.5;\r\n\t\t#ifdef SHOW_BLOCKS\r\n\t\tfloat block = 0.2*z*smoothstep(0.002, 0.0, b);\r\n\t\tfloat shine = 0.6*z*pulse*smoothstep(-0.002, b, 0.007);\r\n\t\tcolor += dust*baseColor + block*z + shine;\r\n\t\t#else\r\n\t\tcolor += dust*baseColor;\r\n\t\t#endif\r\n\t}\r\n\r\n\tcolor -= rand(uv)*0.04;\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"MlySWd",name:"Otherworldy by lherm",shader:"// https://www.shadertoy.com/view/MlySWd\r\n#define T iTime\r\n\r\n#define PSD (abs(texture(iChannel0, vec2(.5)).r)*abs(texture(iChannel0, vec2(.5)).r))\r\n\r\n// HG_SDF rotate function\r\n#define r(p, a) {p = cos(a)*p + sin(a)*vec2(p.y,-p.x);}\r\n\r\n// Cabbibo's HSV\r\nvec3 hsv(float h, float s, float v) {return mix( vec3( 1.0 ), clamp( ( abs( fract(h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;}\r\n\r\nvoid mainImage( out vec4 c, in vec2 w )\r\n{\r\n\tvec2 u = (-iResolution.xy+2.*w.xy) / iResolution.y;\r\n    vec3 ro = vec3(u, 1.), rd = normalize(vec3(u, -1.)), p; // Camera and ray dir\r\n    float d = 0., m; // Distance for march\r\n    for (float i = 1.; i > 0.; i-=0.02)\r\n    {\r\n        p = ro + rd * d;\r\n        r(p.zy, T);\r\n        r(p.zx, T);\r\n        m = length(cos(abs(p)+sin(abs(p))+T))-(PSD + .5); // Distance function\r\n        d += m;\r\n        c = vec4(hsv(T, 1.,1.)*i*i, 1.);\r\n        if (m < 0.02) break;\r\n    }\r\n\r\n}\r\n"},{id:"7tGfRD",name:"Converted Plasma Visualizer by MrHAX00",shader:"// https://www.shadertoy.com/view/7tGfRD\r\n#define pi 3.14159\r\nconst vec2 vp = vec2(320.0, 200.0);\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float Freq = texture(iChannel0, vec2(0.)).r;\r\n\tfloat t = iTime * 10.0 + iMouse.x + Freq * 80.;\r\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.xy * (.7 + Freq * .3);\r\n    float Rotate = cos(Freq * 5.) * .2;\r\n    uv *= mat2(cos(Rotate), -sin(Rotate), sin(Rotate), cos(Rotate));\r\n    uv += iTime * .3;\r\n\r\n    vec2 p0 = (uv - 0.5) * vp;\r\n    vec2 hvp = vp * 0.5;\r\n\tvec2 p1d = vec2(cos( t / 98.0),  sin( t / 178.0)) * hvp - p0;\r\n\tvec2 p2d = vec2(sin(-t / 124.0), cos(-t / 104.0)) * hvp - p0;\r\n\tvec2 p3d = vec2(cos(-t / 165.0), cos( t / 45.0))  * hvp - p0;\r\n    float sum = 0.5 + 0.5 * (\r\n\t\tcos(length(p1d) / 40.0) +\r\n\t\tcos(length(p2d) / 30.0) +\r\n\t\tsin(length(p3d) / 35.0) * sin(p3d.x / 20.0) * sin(p3d.y / 15.0)\r\n    );\r\n    vec3 Color = vec3(cos(Freq + uv.x * 3. + iTime + pi * .333333) * .5 + .5, cos(Freq + uv.y * 3. + iTime + pi * .666666) * .5 + .5, -cos(Freq + length(uv) * 3. + iTime) * .5 + .5);\r\n    fragColor = vec4(Color * texture(iChannel0, vec2(fract(sum + iTime), 0.)).r, 1.);\r\n}\r\n"},{id:"3lsXRf",name:"All Night by alyd",shader:'// https://www.shadertoy.com/view/3lsXRf\r\n#define steps 10000.\r\n#define opacity .5\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n        vec4 color;\r\n        vec2 res=iResolution.xy;\r\n        float t = iTime;\r\n        float radialdist;\r\n    \tvec2 st = fragCoord/iResolution.xy;\r\n\r\n\r\n    for (int i=0;i<3;i+=2) {\r\n        vec2 uv,pos=fragCoord.xy/res;\r\n        uv=pos;\r\n        pos-=.5; //centers the image so it\'s radial. pos is relative to screen width so 0.5 is halfway\r\n        pos.x*=res.x/res.y; //scales the aspect ratio\r\n        radialdist=length(pos);\r\n\r\n        //SOUND\r\n        // the pow causes the rings in the center to be thicker.\r\n        // raising radialdist to the power of totalsound creates thinner rings ie more\r\n        // fragmentation at the center when the song gets more intense.\r\n        float totalsound = texture(iChannel0,vec2(0,0)).r;\r\n        float freq_bin = floor(steps*pow(radialdist,2.+1.*totalsound))/steps; //which bin this ring falls into.\r\n        float sound = texture(iChannel0,vec2(1.0-freq_bin,0)).r; //get the sound amplitude at this bin.\r\n        t += 1.*sound; //jump the "time" forward at this bin\r\n\r\n        uv+=pos/radialdist*(sin(t))*sin(radialdist*9.-t*2.);\r\n        color[i]=.01/length(abs(uv-0.5-0.2*(sin(t))));\r\n\r\n        //make a more purple color\r\n        if (i==2){\r\n            color[0]+=.005/length(abs(uv-0.5-0.2*(sin(t))));\r\n            color[2]+=.01/length(abs(uv-0.5-0.2*(sin(t))));\r\n        }\r\n    }\r\n    color[3]=1.0;\r\n    fragColor = color;\r\n}\r\n'},{id:"3sdfDB",name:"Audio Waveform Visualizer v4 by oneshade",shader:"// https://www.shadertoy.com/view/3sdfDB\r\n/*\r\nVersion four of my Audio Waveform Visualizer.\r\nAdded some cool but rather trippy coloring.\r\n*/\r\n\r\n// 0 for frequency mode, 1 for amplitude mode:\r\n#define VIEW_MODE 0\r\n\r\nfloat samplePiecewiseSmooth(in float x, in float res) {\r\n    float xTimesRes = x * res;\r\n\r\n    // Left sample point:\r\n    float x1 = floor(xTimesRes) / res;\r\n    float y1 = texture(iChannel0, vec2(x1, VIEW_MODE)).x;\r\n\r\n    // Right sample point:\r\n    float x2 = ceil(xTimesRes) / res;\r\n    float y2 = texture(iChannel0, vec2(x2, VIEW_MODE)).x;\r\n\r\n    // Prevent small breaks in the line:\r\n    x2 += 0.001;\r\n\r\n    // Fit half of a sine wave between sample points:\r\n    float sine = sin(((x - x1) / (x2 - x1) * 2.0 - 1.0) * 1.5707963267);\r\n    return y1 + (0.5 + 0.5 * sine) * (y2 - y1);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    float curSample = samplePiecewiseSmooth(uv.x, 20.0);\r\n    // How close the pixel is to the wave:\r\n    float smoothError = smoothstep(0.03, 0.0, abs(uv.y - curSample));\r\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    if (smoothError > 0.0) {\r\n        // Mix red and white based on closeness:\r\n        fragColor = vec4(mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), smoothError), 1.0);\r\n    }\r\n\r\n    // Multiply by some changing colors:\r\n    fragColor.rgb *= 0.5 + 0.5 * cos(iTime + uv.xyx * vec3(20.0, 1.0, 1.0) + vec3(0.0, 2.0, 4.0));\r\n}\r\n"},{id:"DtfSDH",name:"Basic Audio Visualizer Modified by Spheroidon",shader:"// https://www.shadertoy.com/view/DtfSDH\r\n/* Simple audio visualizer by chronos\r\n// Feel free to use any part of the code and/or improve it further\r\n// Drop a link in the comments! :)\r\n//\r\n// Recommended tracks:\r\n// https://soundcloud.com/kubbi/pathfinder\r\n// https://soundcloud.com/wearecastor/rad\r\n// https://soundcloud.com/jco-de/coronoid-soundtrack\r\n//\r\n*/\r\n\r\n#define WIDTH 1.0\r\n\r\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.25) ).x; }\r\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.75) ).x; }\r\n\r\nvec3 B2_spline(vec3 x) { // returns 3 B-spline functions of degree 2\r\n    vec3 t = 3.0 * x;\r\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\r\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\r\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\r\n\treturn 0.5 * (\r\n    \tb0 * pow(t, vec3(2.0)) +\r\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) +\r\n    \tb2 * pow(3.0-t,vec3(2.0))\r\n    );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 centered = 2.0 * uv - 1.0;\r\n    centered.x *= iResolution.x / iResolution.y;\r\n\r\n    float dist2 = dot(centered, centered);\r\n    float clamped_dist = smoothstep(0.0, 1.0, dist2);\r\n    float arclength    = abs(atan(centered.y, centered.x) / radians(360.0))+0.01;\r\n\r\n    // Color variation functions\r\n    float t = iTime / 100.0;\r\n    float polychrome = (1.0 + sin(t*10.0))/2.0; // 0 -> uniform color, 1 -> full spectrum\r\n    vec3 spline_args = fract(vec3(polychrome*uv.x-t) + vec3(0.0, -1.0/3.0, -2.0/3.0));\r\n    vec3 spline = B2_spline(spline_args);\r\n\r\n    float f = abs(centered.y);\r\n    vec3 base_color  = vec3(1.0, 1.0, 1.0) - f*spline;\r\n    vec3 flame_color = pow(base_color, vec3(3.0));\r\n    vec3 disc_color  = 0.20 * base_color;\r\n    vec3 wave_color  = 0.10 * base_color;\r\n    vec3 flash_color = 0.05 * base_color;\r\n\r\n    float sample1 = audio_freq(iChannel0, abs((uv.x - .5) / WIDTH) + 0.01);\r\n    float sample2 = audio_ampl(iChannel0, clamped_dist);\r\n    float sample3 = audio_ampl(iChannel0, arclength);\r\n\r\n    float disp_dist = smoothstep(-0.2, -0.1, sample3-dist2);\r\n    disp_dist *= (1.0 - disp_dist);\r\n\r\n    vec3 color = vec3(0.0);\r\n\r\n    // spline debug\r\n    // vec3 s = smoothstep(-0.01, 0.01, spline-uv.y); color += (1.0-s) * s;\r\n\r\n    float v = abs(uv.y - 0.5);\r\n    color += flame_color * smoothstep(v, v*8.0, sample1);\r\n    color += disc_color  * smoothstep(0.5, 1.0, sample2) * (1.0 - clamped_dist);\r\n    color += flash_color * smoothstep(0.5, 1.0, sample3) * clamped_dist;\r\n    color += wave_color  * disp_dist;\r\n    color = pow(color, vec3(0.4545));\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"slc3WX",name:"Fork Waves Remi gchipunov 002 by gchipunov",shader:"// https://www.shadertoy.com/view/slc3WX\r\n// oringal createor https://www.shadertoy.com/user/ADOB\r\n// remixer coder: https://www.shadertoy.com/user/gchipunov\r\nfloat squared(float value) { return value * value; }\r\n\r\nfloat getAmp(float frequency) { return texture(iChannel0, vec2(frequency / 512.0, 0)).x; }\r\n\r\nfloat getWeight(float f) {\r\n    return (+ getAmp(f-2.0) + getAmp(f-1.0) + getAmp(f+2.0) + getAmp(f+1.0) + getAmp(f)) / 5.0; }\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uvTrue = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = -1.0 + 2.0 * uvTrue;\r\n\r\n\tfloat lineIntensity;\r\n    float glowWidth;\r\n    vec3 color = vec3(0.0);\r\n\r\n\tfor(float i = 0.0; i < 5.0; i++) {\r\n\r\n\t\tuv.y += (0.2 * sin(uv.x + i*7.0 - iTime * 5.6));\r\n        float Y = uv.y + getWeight(squared(i) * 50.0) *\r\n            (texture(iChannel0, vec2(uvTrue.x, 1)).x - 0.5);\r\n        lineIntensity = 0.4 + squared(2.6 * abs(mod(uvTrue.x + i / 0.3 + iTime,2.0) - 1.0));\r\n\t\tglowWidth = abs(lineIntensity / (100.0 * Y));\r\n       // float k = i;\r\n        if(i== 0.)\r\n       {\r\n\t\tcolor += vec3(glowWidth * (2.0 + tan(iTime * 0.13)),\r\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\r\n                 //     glowWidth * (2.0 - cos(iTime * 0.19)));\r\n                       glowWidth * (2.0 - tan(iTime * 0.19)));\r\n       }\r\n           else   if(i== 1.)\r\n        {\r\n \t\tcolor += vec3(glowWidth * (2.0 + sin(iTime * 0.13)),\r\n                      glowWidth * (2.0 - sin(iTime * 0.01)),\r\n                      glowWidth * (2.0 - cos(iTime * 0.01)));\r\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));\r\n        }\r\n         else   if(i== 2.)\r\n        {\r\n \t\tcolor += vec3(glowWidth * (2.0 + cos(iTime * 0.13)),\r\n                      glowWidth * (2.0 - sin(iTime * 0.23)),\r\n                      glowWidth * (2.0 - cos(iTime * 0.19)));\r\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));\r\n        }\r\n        else\r\n        {\r\n \t\tcolor += vec3(glowWidth/2.0 * (2.0 + tan(iTime * 0.13)),\r\n                      glowWidth/2.0 * (2.0 - sin(iTime * 0.23)),\r\n                      glowWidth/2.0 * (2.0 - cos(iTime * 0.19)));\r\n               //        glowWidth * (2.0 - tan(iTime * 0.19)));\r\n        }\r\n\r\n\t}\r\n\tcolor = color + cos(color)/44.0;\r\n    color = color - tan(iTime * 0.13)/555.0;\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"cdtGW7",name:"barebones music visualizer by rucksack",shader:"// https://www.shadertoy.com/view/cdtGW7\r\nconst float bpm = 120.;\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n\r\n    vec3 col;\r\n\r\n    // Bin x into bars\r\n    float p = .05;\r\n    float frequency = round((uv.x + p/2.)/p)*p;\r\n\r\n    // Find music values\r\n    float amplitude = texture(iChannel0, vec2(frequency, 0.)).r;\r\n    float beat_length = 60./bpm;\r\n\r\n    // Base color depends on UV\r\n    // TODO do the green modulation of 2. based on actual beat of the song maybe\r\n    vec3 base = vec3(1.-uv.x+.1, uv.x, uv.y + .5*(sin(2.*beat_length*3.1415*iTime)+.5));\r\n\r\n    // Draw bar or background\r\n    if (uv.y <= amplitude) {\r\n        col = amplitude * base;\r\n    } else {\r\n        col = .4*uv.y * base + vec3(.01, .1, .05) * sqrt(2.*amplitude);\r\n    }\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"tlcGRH",name:"Inversions Kreis by ShadingAlpaca",shader:"// https://www.shadertoy.com/view/tlcGRH\r\nbool swi = false;\r\nfloat speed = 1.;\r\n\r\nfloat getAnim(float t){\r\n    return tan(speed*t)*1.;\r\n}\r\n\r\nfloat farbe(float t){\r\n    float anim = cos(speed*t);\r\n    if(abs(anim)==1.)\r\n       swi = swi ? false : true;\r\n\r\n    if(swi)\r\n        return (anim<0.?1.:-1.);\r\n    else\r\n        return (anim>=0.?1.:-1.);\r\n}\r\n\r\nvec2 ri = vec2(0.25,0.25);\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = ( fragCoord - .5*iResolution.xy) /iResolution.y;\r\n    float sen = 0.25;\r\n    float fft  = (\r\n        texture(iChannel0, vec2(.0,sen*20.)).x +\r\n        texture(iChannel0, vec2(.3,sen)).x +\r\n        texture(iChannel0, vec2(.6,sen)).x +\r\n        texture(iChannel0, vec2(.9,sen)).x\r\n    );\r\n    float high = (\r\n        texture(iChannel0, vec2(.7,sen)).x +\r\n        texture(iChannel0, vec2(.9,sen*2.)).x\r\n    );\r\n    float low = (\r\n        texture(iChannel0, vec2(.0,sen)).x+\r\n        texture(iChannel0, vec2(.05,sen)).x+\r\n        texture(iChannel0, vec2(.1,sen)).x\r\n    );\r\n\r\n\r\n    //float b = 2.0-length(vec2(uv.x,uv.y));\r\n    float b = texture(iChannel0, vec2(1.2*length(vec2(uv.x,uv.y))\r\n                                      //Kreisverlauf A\r\n                                      //-1.5*(mod(iTime*0.125, 1.)*2. - 1.)\r\n                                      //Kreisverlauf B\r\n                                      -0.2*sin(iTime*0.5)+.1\r\n                                      -0.1*low,sen*1.2)).x;\r\n    float g = length(vec2(uv.x,uv.y))-0.5\r\n        >\r\n        (0.09)*low//*(sin(3.*(atan(uv.x-aspect/2.,uv.y-1./2.)+sin(iTime)))+1.)\r\n        -.2*getAnim(iTime)\r\n        ? 1.+1.5*(farbe(iTime))*b : 1.-1.5*(farbe(iTime))*b;\r\n\r\n    // Time varying pixel color\r\n    float red = (iFrameColor.r)*abs(sin(iTime*0.1));\r\n    float green = (iFrameColor.g)*abs(sin(iTime*0.11));\r\n    float blue = (iFrameColor.b)*abs(sin(iTime*0.12))+0.2;\r\n    vec3 col = vec3(g*red,g*green,g*blue);\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"cslSRr",name:"Audio-reactive scene 1st attempt by kishimisu",shader:"// https://www.shadertoy.com/view/cslSRr\r\n/* @kishimisu - 2022\r\n\r\n   First attempt at raymarching scenes\r\n   that react to audio input !\r\n\r\n   I realized that it's really hard\r\n   to isolate the notes in order to\r\n   have different parts of the scene\r\n   react to different sounds without\r\n   manual fine-tuning. I'll try to\r\n   improve on it, any reference on\r\n   this subject is welcome !\r\n*/\r\n\r\n// Set to 1 if you have a really good PC\r\n#define HIGH_PERF 0\r\n\r\n#if HIGH_PERF\r\n    #define iterations           50.\r\n    #define max_dist            500.\r\n// numbers of neighbor lights to check, very expensive so default to 0.\r\n    #define light_neighbors_check 1.\r\n#else\r\n    #define iterations           30.\r\n    #define max_dist            100.\r\n    #define light_neighbors_check 0.\r\n#endif\r\n\r\nfloat lightRep = 12.;    // lights spacing\r\nfloat attenuation = 20.; // light attenuation\r\n\r\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\r\n#define rep(p,r) (mod(p+r/2.,r)-r/2.)\r\n#define rid(p,r) floor((p+r/2.)/r)\r\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1 , 113.5,271.9,124.6) ) *43758.5453123)\r\n\r\nfloat hash11(float p) {\r\n    p = fract(p * .1031);\r\n    p *= p + 33.33;\r\n    return fract(2.*p*p);\r\n}\r\n\r\nvec3 getLight(float d, vec3 color) {\r\n    return max(vec3(0.), color / (1. + pow(abs(d * attenuation), 1.3)) - .001*0.);\r\n}\r\n\r\nfloat getLevel(float x) {\r\n    return texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r;\r\n}\r\n\r\n// The next functions are borrowed from https://www.shadertoy.com/view/7lVBRw\r\n// because they seem to better retrieve the musical aspects from the FFT\r\nfloat getPitch(float freq, int octave){\r\n   return getLevel(pow(2.0, float(octave)) * freq / 12000.0);\r\n}\r\nfloat logX(float x, float a, float c){\r\n   return 1.0 / (exp(-a*(x-c)) + 1.0);\r\n}\r\nfloat logisticAmp(float amp){\r\n   float c = 1.0 - (0.25);\r\n   float a = 20.0 * (1.0 - iMouse.y / iResolution.y);\r\n   a = 20.;\r\n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\r\n}\r\nfloat getAudioIntensityAt(float x) {\r\n    x = abs(fract(x));\r\n    float freq = pow(2., x*3.) * 261.;\r\n    return iChannelTime[0] <= 0. ? hash11(x) : logisticAmp(getPitch(freq, 1));\r\n}\r\n\r\nfloat map(vec3 p, inout vec3 col) {\r\n    //p.z = abs(p.z);\r\n    p.y = abs(p.y) - 13. - getAudioIntensityAt(0.)*1.2;\r\n\r\n    vec2 id = rid(p.xz, 2.);\r\n    p.y += sin( length(sin(id/5.23 - iTime) * cos(id/10.45 + iTime))  ) * 8.;\r\n\r\n    vec3 fp = rep(p, lightRep);\r\n    fp.y = p.y;\r\n\r\n    const float r = light_neighbors_check;\r\n    for (float j = -r; j <= r; j++)\r\n    for (float i = -r; i <= r; i++) {\r\n        vec3 off = vec3(i, 0., j) * lightRep;\r\n        vec3 nid = rid(p - off, lightRep);\r\n        float d = length( fp + off )-1.;\r\n\r\n        // assign more red to lower frequencies, more green to middle and more blue to upper frequencies\r\n        vec3 c = hash33(nid);\r\n        vec3 light = vec3(getAudioIntensityAt(c.r*.33), getAudioIntensityAt(c.g*.33+.33), 4.*getAudioIntensityAt(c.b*.33+.67));\r\n        // make the intensity vary depending on a random frequency (always the same for each light)\r\n        light *= getAudioIntensityAt(c.r+c.b+c.g)+(c.r+c.b+c.g);\r\n        col += getLight(d, light);\r\n    }\r\n\r\n    p.xz = rep(p.xz, 2.);\r\n    return length(p) - 1.;\r\n}\r\n\r\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\r\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.;\r\n    ro = vec3(iTime*8. -6., 0., 0.);\r\n\r\n    float t = -iTime*.15*0.;\r\n    vec3 f = normalize(vec3(cos(t),0,sin(t)));\r\n    vec3 r = normalize(cross(vec3(0,1,0), f));\r\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\r\n}\r\n\r\nvoid mainImage(out vec4 O, in vec2 F) {\r\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\r\n    vec3 p, ro, rd, col;\r\n\r\n    initRayOriginAndDirection(uv, ro, rd);\r\n\r\n    float t = 0.;\r\n\r\n    for (float i = 0.; i < iterations; i++) {\r\n        p = ro + t*rd;\r\n        //p.yz *= rot(-t*mix(-.01, .01, sin(iTime*.1)*.5+.5));\r\n        t += map(p, col);\r\n        if (t > max_dist) break;\r\n    }\r\n\r\n    col = pow(col, vec3(.45));\r\n    O = vec4(col, 1.0);\r\n}\r\n"},{id:"tdXcRl",name:"Clair De Lune by Agneseion",shader:"// https://www.shadertoy.com/view/tdXcRl\r\n#define PI 3.141592653589793238462643383279502884197169399375105820974\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float contribution = 0.0;\r\n    fragColor = vec4(0.0);\r\n    float phase = .5 * (1.0 + sin(iTime / (2.0 * PI)));\r\n    phase = phase * phase;\r\n    float scale = 1.0;\r\n    for (int i = 0; i < 9; i++)\r\n    {\r\n        vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\r\n\r\n        float offset = phase * uv.x + uv.y;\r\n\r\n        float distanceFromMiddle = length(uv) * .5 * (1.0 + sin(offset + iTime / scale * 0.25));\r\n\r\n        // Time varying pixel color\r\n        vec4 music = texture(iChannel0, vec2(distanceFromMiddle));\r\n        vec3 col = length(music.rgb) * cos(scale*iTime/10.0+vec3(0,2,4));\r\n\r\n        // Output to screen\r\n        float colourfulness = clamp(length(col) + phase, 0.0, 1.0);\r\n        float colourlessness = 1.0 - colourfulness;\r\n\r\n        float localContribution = scale / (1.0 + pow(distanceFromMiddle, -phase));\r\n        vec3 colourVector = clamp(col, .5 - scale, .5 + scale);\r\n        vec3 colourlessVector = vec3(length(colourVector));\r\n\r\n        fragColor += localContribution*vec4(colourfulness * colourVector + colourlessness * colourlessVector, 1.0);\r\n        contribution += localContribution;\r\n        scale /= 2.0;\r\n    }\r\n    fragColor /= contribution;\r\n}\r\n"},{id:"dd2Xzm",name:"PHONK by Poisson",shader:"// https://www.shadertoy.com/view/dd2Xzm\r\n// press pause and play if there's no music\r\n\r\n// music frequency\r\nfloat freq;\r\n\r\n// hash vec2 to float\r\nfloat hash21(vec2 p) {\r\n    p = fract(p*vec2(452.127,932.618));\r\n    p += dot(p, p+123.23);\r\n    return fract(p.x*p.y);\r\n}\r\n\r\n// noise function by me\r\nfloat noise(vec2 p) {\r\n    vec2 q = floor(p);\r\n    vec2 f = fract(p);\r\n    return mix(mix(hash21(q+vec2(0,0)),hash21(q+vec2(1,0)),f.x),\r\n               mix(hash21(q+vec2(0,1)),hash21(q+vec2(1,1)),f.x),f.y);\r\n}\r\n\r\n// fractal noise\r\nfloat fbm(vec2 p) {\r\n    float f = 0.;\r\n    f +=     .5*noise(p);\r\n    f +=    .25*noise(p*2.);\r\n    f +=   .125*noise(p*4.);\r\n    f +=  .0625*noise(p*8.);\r\n    f += .03125*noise(p*16.);\r\n    return f;\r\n}\r\n\r\n// background noise\r\nfloat func(vec2 p) {\r\n    return fbm(vec2(sin(iTime*.8),cos(iTime*.8))+p*fbm(p+.2*iTime)+noise(p+noise(p+noise(p))));\r\n}\r\n\r\n// rendering function\r\nvec3 render(vec2 p) {\r\n    p *= .55+.2*freq; // bounce\r\n\r\n    // background\r\n    vec3 colA = vec3(0,.18,0);\r\n    vec3 colB = vec3(1.15,.75,.83);\r\n    float k = pow(func(9.*p),1.2);\r\n    vec3 col = smoothstep(colA,colB,vec3(k));\r\n\r\n    // ball\r\n    float x = atan(p.x,p.y); // polar x value\r\n    // frequencies\r\n    float f = texture(iChannel0, vec2(x*.018+.4,.25)).r;\r\n    // radius\r\n    float r = .2+4.*min(pow(f,8.),.1)*clamp(p.y+.06,0.,1.);\r\n    // hollow circle\r\n    float m = abs(length(p)-r)-.02;\r\n\r\n    // draw the ball\r\n    float b = fwidth(m); // blur value\r\n    col = mix(col, vec3(1), smoothstep(b,-b,m));\r\n\r\n    return clamp(col,0.,1.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // pixel coordinates centered at the origin\r\n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\r\n    // normalized pixel coordinates\r\n    vec2 q = fragCoord/iResolution.xy;\r\n\r\n    // music frequency\r\n    freq = texture(iChannel0, vec2(.01,.25)).r;\r\n\r\n    // render with chromatic aberration\r\n    vec2 off = (q-.5) * .03*pow(freq,4.); // CA offset\r\n    vec3 col = vec3(render(p+off).r,\r\n                    render(p).g,\r\n                    render(p-off).b);\r\n\r\n    col += .5*col*pow(freq,8.); // flash\r\n    // vignette\r\n    col *= .5+.5*pow(64.*q.x*q.y*(1.-q.x)*(1.-q.y),.1);\r\n\r\n    col *= 1.-exp(-iTime*2.); // fade\r\n\r\n    // output\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"fsKyzd",name:"purple sound visualizer by TonyIlersich",shader:"// https://www.shadertoy.com/view/fsKyzd\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float majorAxis = max(iResolution.x, iResolution.y);\r\n    vec2 uv = fragCoord/majorAxis;\r\n    vec2 center = iResolution.xy/2.0/majorAxis;\r\n    vec2 rel = uv-center;\r\n    vec2 disp = abs(rel) * 1.2 + length(rel) * .8;\r\n    float d = max(disp.x,disp.y);\r\n    d += 0.01 * d * cos(12.0 * atan(rel.y, rel.x));\r\n    int n = int(512.0 * pow(d*.9+.1, 2.0));\r\n\r\n    float fft = texelFetch(iChannel0, ivec2(n, 0), 0).x;\r\n\r\n    vec3 col = vec3(\r\n        pow(fft*1.2, 11.0 + 2.0*(1.0-d)),\r\n        pow(fft*1.1, 12.0 + 2.0*(1.0-d)),\r\n        pow(fft*1.3, 12.0 + 2.0*(1.0-d)));\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"4t2cR1",name:"♫ Sailing Beyond - Hyper Tunnel by patu",shader:'// https://www.shadertoy.com/view/4t2cR1\r\n/*\r\n\r\n    Hyper Tunnel from "Sailing Beyond" (demoscene producion)\r\n\r\n    https://www.youtube.com/watch?v=oITx9xMrAcM&\r\n\thttps://www.pouet.net/prod.php?which=77899\r\n\r\n\r\n*/\r\n\r\n\r\n/*\r\n\thttp://bit.ly/shadertoy-plugin\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n#pragma optimize(off)\r\n\r\n\r\n\r\n\r\n\r\n#define getNormal getNormalHex\r\n\r\n#define FAR 1e3\r\n#define INFINITY 1e32\r\n\r\n#define T iTime\r\n#define mt (iChannelTime[0] > 0. ? iChannelTime[0] : iTime)\r\n#define FOV 70.0\r\n#define FOG .06\r\n\r\n#define PI 3.14159265\r\n#define TAU (2*PI)\r\n#define PHI (1.618033988749895)\r\n\r\nfloat vol = 0.;\r\n\r\nfloat hash12(vec2 p) {\r\n\tfloat h = dot(p,vec2(127.1,311.7));\r\n    return fract(sin(h)*43758.5453123);\r\n}\r\n\r\n// 3d noise\r\nfloat noise_3(in vec3 p) {\r\n    vec3 i = floor(p);\r\n    vec3 f = fract(p);\r\n\tvec3 u = 1.-(--f)*f*f*f*-f;\r\n\r\n    vec2 ii = i.xy + i.z * vec2(5.0);\r\n    float a = hash12( ii + vec2(0.0,0.0) );\r\n\tfloat b = hash12( ii + vec2(1.0,0.0) );\r\n    float c = hash12( ii + vec2(0.0,1.0) );\r\n\tfloat d = hash12( ii + vec2(1.0,1.0) );\r\n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n\r\n    ii += vec2(5.0);\r\n    a = hash12( ii + vec2(0.0,0.0) );\r\n\tb = hash12( ii + vec2(1.0,0.0) );\r\n    c = hash12( ii + vec2(0.0,1.0) );\r\n\td = hash12( ii + vec2(1.0,1.0) );\r\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\r\n\r\n    return max(mix(v1,v2,u.z),0.);\r\n}\r\n\r\nfloat fbm(vec3 x)\r\n{\r\n    float r = 0.0;\r\n    float w = 1.0, s = 1.0;\r\n    for (int i=0; i<4; i++)\r\n    {\r\n        w *= 0.25;\r\n        s *= 3.;\r\n        r += w * noise_3(s * x);\r\n    }\r\n    return r;\r\n}\r\n\r\nfloat yC(float x) {\r\n \treturn cos(x * -.134) * 1. * sin(x * .13) * 15.+ fbm(vec3(x * .1, 0., 0.) * 55.4);\r\n}\r\n\r\nvoid pR(inout vec2 p, float a) {\r\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\r\n}\r\n\r\nstruct geometry {\r\n    float dist;\r\n    vec3 hit;\r\n    int iterations;\r\n};\r\n\r\n\r\n// Cylinder with infinite height\r\nfloat fCylinderInf(vec3 p, float r) {\r\n\treturn length(p.xz) - r;\r\n}\r\n\r\ngeometry map(vec3 p) {\r\n    p.x -= yC(p.y * .1) * 3.;\r\n    p.z += yC(p.y * .01) * 4.;\r\n\r\n    float n = pow(abs(fbm(p * .06 )) * 12., 1.3);\r\n    float s = fbm(p * 0.01 + vec3(0., T * 0.14, 0.)) * 128.;\r\n\r\n    geometry obj;\r\n\r\n    obj.dist = max(0., -fCylinderInf(p, s + 18. -n));\r\n\r\n    p.x -= sin(p.y * .02) * 34. + cos(p.z * 0.01) * 62.;\r\n\r\n    obj.dist = max(obj.dist, -fCylinderInf(p, s + 28. + n * 2.));\r\n\r\n    return obj;\r\n}\r\n\r\n\r\nfloat t_min = 10.0;\r\nfloat t_max = FAR;\r\nconst int MAX_ITERATIONS = 100;\r\n\r\ngeometry trace(vec3 o, vec3 d) {\r\n    float omega = 1.3;\r\n    float t = t_min;\r\n    float candidate_error = INFINITY;\r\n    float candidate_t = t_min;\r\n    float previousRadius = 0.;\r\n    float stepLength = 0.;\r\n    float pixelRadius = 1./ 1000.;\r\n\r\n    geometry mp = map(o);\r\n\r\n    float functionSign = mp.dist < 0. ? -1. : +1.;\r\n    float minDist = FAR;\r\n\r\n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\r\n\r\n        mp = map(d * t + o);\r\n\t\tmp.iterations = i;\r\n\r\n        float signedRadius = functionSign * mp.dist;\r\n        float radius = abs(signedRadius);\r\n        bool sorFail = omega > 1. &&\r\n        \t(radius + previousRadius) < stepLength;\r\n\r\n        if (sorFail) {\r\n            stepLength -= omega * stepLength;\r\n            omega = 1.;\r\n        } else {\r\n        \tstepLength = signedRadius * omega;\r\n        }\r\n        previousRadius = radius;\r\n        float error = radius / t;\r\n\r\n        if (!sorFail && error < candidate_error) {\r\n            candidate_t = t;\r\n            candidate_error = error;\r\n        }\r\n\r\n        if (!sorFail && error < pixelRadius || t > t_max) break;\r\n\r\n        t += stepLength * .5; // ;(\r\n   \t}\r\n\r\n    mp.dist = candidate_t;\r\n\r\n    if (\r\n        (t > t_max || candidate_error > pixelRadius)\r\n    \t) mp.dist = INFINITY;\r\n\r\n\r\n    return mp;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n    vec2 ouv = fragCoord.xy / iResolution.xy;\r\n    vec2 uv = ouv - .5;\r\n\r\n    uv *= tan(radians (FOV) / 2.0) * 4.;\r\n\r\n    vec3\r\n        vuv = normalize(vec3(cos(T), sin(T * .11), sin(T * .41))), // up\r\n    \tro = vec3(0., 30. + iTime * 100., -.1);\r\n\r\n    ro.x += yC(ro.y * .1) * 3.;\r\n    ro.z -= yC(ro.y * .01) * 4.;\r\n\r\n    vec3 vrp =  vec3(0., 50. + iTime * 100., 2.);\r\n\r\n    vrp.x += yC(vrp.y * .1) * 3.;\r\n    vrp.z -= yC(vrp.y * .01) * 4.;\r\n\r\n    vec3\r\n\t\tvpn = normalize(vrp - ro),\r\n    \tu = normalize(cross(vuv, vpn)),\r\n    \tv = cross(vpn, u),\r\n    \tvcv = (ro + vpn),\r\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\r\n    \trd = normalize(scrCoord - ro),\r\n        oro = ro;\r\n\r\n    vec3 sceneColor = vec3(0.);\r\n\r\n    geometry tr = trace(ro, rd);\r\n\r\n    tr.hit = ro + rd * tr.dist;\r\n\r\n    vec3 col = vec3(1., 0.5, .4) * fbm(tr.hit.xzy * .01) * 20.;\r\n    col.b *= fbm(tr.hit * .01) * 10.;\r\n\r\n    sceneColor += min(.8, float(tr.iterations) / 90.) * col + col * .03;\r\n    sceneColor *= 1. + .9 * (abs(fbm(tr.hit * .002 + 3.) * 10.) * (fbm(vec3(0.,0.,iTime * .05) * 2.)) * 1.);\r\n    sceneColor = pow(sceneColor, vec3(1.)) * (iChannelTime[0] > 0. ? texelFetch(iChannel0, ivec2(128, 0), 0).r * min(1., mt * .1) : 0.6);\r\n\r\n    vec3 steamColor1 = vec3(.0, .4, .5);\r\n\tvec3 rro = oro;\r\n\r\n    ro = tr.hit;\r\n\r\n    float distC = tr.dist, f = 0., st = .9;\r\n\r\n    for (float i = 0.; i < 24.; i++) {\r\n        rro = ro - rd * distC;\r\n        f += fbm(rro * vec3(.1, .1, .1) * .3) * .1;\r\n        distC -= 3.;\r\n        if (distC < 3.) break;\r\n    }\r\n\r\n    steamColor1 *= iChannelTime[0] > 0. ? texelFetch(iChannel0, ivec2(32, 0), 0).r : 1.;\r\n    sceneColor += steamColor1 * pow(abs(f * 1.5), 3.) * 4.;\r\n\r\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.), 0.0, 1.0), 1.0);\r\n    fragColor = pow(abs(fragColor / tr.dist * 130.), vec4(.8));\r\n\r\n}\r\n'},{id:"WdKyzd",name:"swirly rainbow sound visualizer by TonyIlersich",shader:"// https://www.shadertoy.com/view/WdKyzd\r\n#define tao 6.283185307179586476925286766559\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/max(iResolution.x, iResolution.y);\r\n    vec2 ctr = iResolution.xy/2.0/max(iResolution.x, iResolution.y);\r\n    vec2 disp = uv - ctr;\r\n\r\n    vec2 polar = vec2(length(disp)*2.0, atan(disp.y, disp.x)/tao+.5);\r\n\r\n    vec2 wave = texture(iChannel0, vec2(polar.x*2.0, 1)).xy;\r\n\r\n    float smallAmp = .1*polar.x*pow(wave.x, 5.0);\r\n    float bigAmp = .6*pow(polar.x, .9)*pow(wave.x, 7.0);\r\n\r\n    float targetF =\r\n        (1.0-abs(smallAmp+bigAmp))*polar.x\r\n        -smallAmp*sin(iTime+polar.y*tao*24.0)\r\n        -bigAmp*sin((.125+polar.y)*tao*2.0);\r\n    float f = pow(targetF, 2.5);\r\n\r\n    vec2 freq = texture(iChannel0, vec2(f, 0)).xy;\r\n\r\n    vec3 col = 0.5 + 0.5*cos(\r\n        .4*iTime\r\n        -tao*(polar.x*sqrt(1.0+wave.x)+polar.y)\r\n        +vec3(tao*.0,tao*.33,tao*.67)\r\n   \t);\r\n\r\n    col *= vec3(.9, .9, 1.0);\r\n\r\n    col *= pow(freq.x, 4.0);\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"7ldczN",name:"Tangerine Dream Visualizer 2 by gurudevbk",shader:"// https://www.shadertoy.com/view/7ldczN\r\n#define freq(f) texture(iChannel0, vec2(f, 0.25)).x * 0.8\r\n\r\nfloat avgBassFreq() {\r\n    float div = 0.0;\r\n    float total = 0.0;\r\n    for (float pos = 0.0; pos < 0.1; pos += 0.01) {\r\n        div += 1.0;\r\n        total += freq(pos);\r\n    }\r\n    return total / div;\r\n}\r\n\r\nfloat avgMedFreq() {\r\n    float div = 0.0;\r\n    float total = 0.0;\r\n    for (float pos = 0.1; pos < 0.6; pos += 0.01) {\r\n        div += 1.0;\r\n        total += freq(pos);\r\n    }\r\n    return total / div;\r\n}\r\n\r\nfloat avgTopFreq() {\r\n    float div = 0.0;\r\n    float total = 0.0;\r\n    for (float pos = 0.6; pos < 1.0; pos += 0.01) {\r\n        div += 1.0;\r\n        total += freq(pos);\r\n    }\r\n    return total / div;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n\r\n\r\n    float aspect = iResolution.y/iResolution.x; //aspect ratio of viewport\r\n    float value; //var\r\n\tvec2 uv = fragCoord.xy / iResolution.x; //vec ratio of fragment coordinate to width of viewport\r\n\r\n    float bassFreq = pow(avgBassFreq(), 0.85);\r\n    float medFreq = pow(avgMedFreq(), 0.85);\r\n    float topFreq = pow(avgTopFreq(), 0.85);\r\n\r\n    float rot = radians(45.0); // radians(45.0*sin(iTime)); //radians(45.0)\r\n    float rot2 = radians(45.0*sin(iTime)); // radians(45.0*sin(iTime)); //radians(45.0)\r\n\r\n    uv -= vec2(0.5, 0.5*aspect); //transform\r\n\r\n\r\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\r\n   \tuv  = m * uv;\r\n    uv *= vec2(1., 1.7*aspect);\r\n    uv.y+=0.01*(2.0-aspect);\r\n    vec2 pos = 200.0*uv;\r\n    vec2 rep = fract(-0.9*tan(rot2)+cos(rot2/2.0)*pos);\r\n    float dist = min(min(rep.x, rep.x), min(rep.y, 1.0-rep.y));\r\n    float squareDist = length((floor(pos)+vec2(0.5)) - vec2(1.0) );\r\n\r\n    float edge = 4.*sin(squareDist)*0.5+0.5;\r\n\r\n    edge = ((iTime+bassFreq+medFreq)/20.-squareDist*((iTime*medFreq+topFreq)/50000.))*.4;\r\n    edge = (medFreq)/(topFreq)*fract(edge*squareDist);\r\n    //value = medFreq*abs(dist-bassFreq);\r\n    //value = pow(dist, 2.0);\r\n    value = fract (dist*2.0);\r\n    value = mix(value, 1.0-value, step(1.0, edge));\r\n    //value *= 1.0-0.5*edge;\r\n    edge = pow(abs(1.0-edge), 2.0);\r\n\r\n    edge = .5*(medFreq)-abs(1.0-edge)+topFreq;\r\n    //value = smoothstep( edge-0.25, edge, 0.55*value);\r\n\r\n\r\n    value += squareDist*.1;\r\n    //fragColor = vec4(value);\r\n    fragColor = mix(vec4(1.0,edge/2.,value/4.,1.0)*(cos(rot2)/4.0),vec4(0.5,0.75,1.0,1.), edge);\r\n    fragColor.a = 0.25*clamp(edge, 0.0, 1.0);\r\n    fragColor.b += sin(iTime+medFreq)*.5+.5;\r\n    fragColor.r /= .8*bassFreq+sin(iTime+medFreq)*.1+.2;\r\n    fragColor.g += topFreq*.1;\r\n}\r\n"},{id:"Wll3Df",name:"Simple rainbow by avin",shader:"// https://www.shadertoy.com/view/Wll3Df\r\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\r\n#define BLACK_COL vec3(32,43,51)/255.\r\n\r\nfloat line(vec2 p,vec2 size){\r\n\tfloat mask =\r\n        smoothstep(size.x, size.x-.1, abs(p.x)) *\r\n        smoothstep(size.y, size.y-.1, abs(p.y));\r\n\r\n    return smoothstep(.45, .5, mask);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.y;\r\n\r\n    vec2 aRatio = vec2(30., 1.);\r\n    vec2 guv = uv * aRatio;\r\n    vec2 id = floor(guv);\r\n    guv = fract(guv);\r\n    guv -= .5;\r\n\r\n    vec2 muzUV = floor(uv * aRatio) / aRatio;\r\n    vec4 muz = texture(iChannel0, muzUV * .5);\r\n    muz.x +=  (sin(iTime + id.x*.25)*.5+.5)*.25;\r\n    vec2 size = vec2(0.75, muz.x*.3 + .05);\r\n\r\n    vec2 sf = aRatio * .025;\r\n    float mask =\r\n        smoothstep(size.x, size.x-sf.x, abs(guv.x)) *\r\n        smoothstep(size.y, size.y-sf.y, abs(guv.y));\r\n\r\n    float m = smoothstep(.25, .5, mask);\r\n\r\n    vec3 col = hue(fract(size.y*5. + iTime*.05)).rgb;\r\n\r\n    col = mix(BLACK_COL, col, m);\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"ddy3DD",name:"🎶 Tequilla Rainbow by wj",shader:'// https://www.shadertoy.com/view/ddy3DD\r\n// "Tequilla Rainbow" by wj\r\n// based on avin\'s "Rainbow soundviz": https://www.shadertoy.com/view/ttfGzH\r\n// license: CC-BY-NC-SA\r\n\r\n\r\n#define PI 3.1415926\r\n#define PI2 6.2831852\r\n\r\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\r\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\r\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\r\n}\r\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\r\n//  Macro version of above to enable compile-time constants\r\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\r\n\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n {\r\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\r\n\r\n    float CIRCLES = 9.;\r\n    float cS = .93275;\r\n\r\n    float sm = 1.0 / iResolution.y * 25.0;\r\n    float ps = 1.0 / iResolution.y * sqrt(iResolution.y) * 1.9;\r\n\r\n    float d = length(uv);\r\n\r\n    float a = atan(uv.y, uv.x);\r\n    a = a < 0.0 ? PI + (PI - abs(a)) : a;\r\n\r\n    float lPos = a /PI2;\r\n\r\n    float m = 0.0;\r\n    float partSize = 1.0 / CIRCLES * 1.05;\r\n    vec3 col;\r\n\r\n    float t= iTime;\r\n\r\n    for(float i = 9.; i > 1.0; i -= 1.0) {\r\n\r\n        float ilPos = fract(lPos + i*0.1 + t * 0.1);\r\n        float cPos = partSize * i + ilPos * partSize;\r\n        float invPos = partSize * (i + 1.0) - ilPos * partSize;\r\n        float nzF = (1.0 - ilPos);\r\n        float mP0 = texture(iChannel0, vec2(partSize * i, 0.0)).x * 0.8;\r\n        float mP = texture(iChannel0, vec2(cPos, 0.0)).x * 0.8;\r\n        float mPInv = texture(iChannel0, vec2(invPos, 0.0)).x * 0.8;\r\n\r\n        mP = (mP + mPInv) * .5 ;\r\n\r\n        float rDiff = i*(1.0 / CIRCLES * .8);\r\n        float r = mP * (1.0 / CIRCLES * 5.0) - rDiff;\r\n\r\n        float subm = smoothstep(cS - ps + r, cS - ps + sm + r, d) * smoothstep(cS + r, cS - sm + r, d);\r\n\r\n        if (subm > 0.0) {\r\n//            col += HSV2RGB(vec3(i / CIRCLES * 0.5 + t * 0.05 + mP0 * 0.184, 0.95, .0025))*400.;   // cycle hue\r\n            col += HSV2RGB(vec3(i / CIRCLES * 0.5 + 14.4*0.05 + mP0 * 0.184, 0.95, .0025))*400.;\r\n            m += subm;\r\n        }\r\n    }\r\n\r\n    m = clamp(m, 0.0, 1.0);\r\n\r\n    float r =  (sin(t * 0.5) * 0.5 + 0.5);\r\n    float b = (cos(t * 0.5) * 0.5 + 0.5);\r\n    vec3 backCol = vec3(r, 0.0, b) * length(uv * 0.75) * 0.5;\r\n\r\n    col = mix(backCol, col, m);\r\n\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n'},{id:"WtV3Dd",name:"Trippy Visualizer by MinimilisticBits",shader:"// https://www.shadertoy.com/view/WtV3Dd\r\n//const float pi = 3.14159265358979323846264338327950288419716939937510; //just pi\r\nconst float ni = 3.0778979877877658472;\r\n\r\n/*vec2 rot(vec2 a, float c){\r\nfloat g = c*pi/180.0;\r\nvec2 b = vec2(cos(g),sin(g));\r\nreturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\r\n}*/\r\n\r\nvec2 rot(vec2 a, float c){ //mine\r\n//acos 1 to -1 = 0 to pi\r\nfloat p = length(a);\r\na = normalize(a);\r\nfloat ang_x = atan(a.y,a.x);\r\nang_x +=  c*ni/180.0;\r\nreturn vec2(p*cos(ang_x), p*sin(ang_x));\r\n}\r\n\r\n\r\nfloat box(vec3 p, vec3 s){//mine\r\nvec3 a = abs(p)-s;\r\nreturn max(max(a.x, a.y),a.z);\r\n}\r\n\r\n/*\r\nvec3 r(vec3 p, vec3 c){//not originally thought by me\r\nreturn mod(p,c)-0.5*c;\r\n}\r\n*/\r\n\r\nvec3 r(vec3 p, vec3 c){\r\nreturn ((p/c - floor(p/c))*c)-0.5*c;\r\n}\r\n\r\n\r\nfloat dis(vec3 p){\r\nreturn min(length(mod(p,8.0)-4.0)-1.3,\r\n          box(r(vec3(0.0, -4.0, 0.0)-p, vec3(20.0,20.0,3.0)), vec3(40.0,0.5,0.5))\r\n          );\r\n}\r\n\r\nbool trac(out vec3 p, vec3 d, out float dd){\r\n    for(int i = 0; i < 40; i++){\r\n        dd = dis(p);\r\n        if(dd < 0.01){return true;}\r\n        p+=d*dd;\r\n    }\r\n    return false;\r\n}\r\n\r\n/*\r\nvec3 norm(vec3 p){//not originally by me\r\nvec2 k = vec2(0.1,0.0);\r\nreturn normalize(\r\nvec3(\r\ndis(p+k.xyy)-dis(p-k.xyy),\r\ndis(p+k.yxy)-dis(p-k.yxy),\r\ndis(p+k.yyx)-dis(p-k.yyx)\r\n));\r\n}\r\n*/\r\n\r\nvec3 norm(vec3 p, float dist){\r\n    return normalize(vec3(dist-dis(vec3(p.x-0.1,p.yz)),dist-dis(vec3(p.x,p.y-0.1,p.z)),\r\n                          dist-dis(vec3(p.xy,p.z-0.1))));\r\n}\r\n\r\n\r\n\r\nvec3 shadow(vec3 p, vec3 lig){\r\n    vec3 d = normalize(lig - p);\r\n    float dist,lgg;\r\n    for(int i = 0; i < 40; i++){\r\n     lgg = length(lig-p)-1.3;\r\n     dist = min(lgg, dis(p));\r\n     if(dist < 0.01)break;\r\n     p+=d*dist;\r\n    }\r\n    if(dist < 0.01 && dist == lgg){\r\n    return vec3(1.0);\r\n    }\r\n\r\n    vec3 n = norm(p,dist);\r\n    float ang = 1.0-dot(-d,n);\r\n    vec3 c = vec3((cos(iTime-ang*2.0)+1.0)*0.5, (sin(iTime+ang*12.0)+1.0)*0.5, 0.5);\r\n    return c*ang;\r\n}\r\n\r\nvec3 volumetrics(vec3 prevp, vec3 p, vec3 lig){\r\n    const int iter = 7;\r\n    vec3 dp = (p-prevp)/float(iter);\r\n\r\n    vec3 vcol;\r\n\r\n    for(int i = 0; i < iter; i++){\r\n    vcol += shadow(prevp+dp*float(i+1), lig);\r\n    }\r\n\r\n    return vcol/float(iter);\r\n}\r\n\r\nfloat rough(float a, float c){\r\nreturn exp(-pow(12.0*(1.0-a)*(c-1.0) - a ,2.0))/(ni*a);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float sp = texture(iChannel0, vec2(0.0 / 512.0, 0.0)).x;\r\n\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n    uv -= vec2(0.5);\r\n    uv.x *= iResolution.x/iResolution.y;\r\n    uv *= vec2(2.0+sp*2.0);\r\n\r\n    vec3 d = normalize(vec3(uv.x, 1.0, uv.y));\r\n    vec2 mouse = iMouse.xy / iResolution.xy;\r\n    mouse = mouse * 2.0 - 1.0;\r\n\r\n    d = abs(-vec3(rot(d.xz, iTime*6.0),d.y));\r\n    d.yz = rot(d.yz, cos(iTime*0.4 - sp*1.6)*90.0);\r\n    d.xy = rot(d.xy, sin(iTime*0.2 + sp*1.3)*180.0);\r\n    vec3 p = vec3(0.0);\r\n    vec3 prevp = p;\r\n    vec3 col = vec3(0.0);\r\n    vec3 lig = vec3(sin(iTime)*5.0,10.0,2.0+cos(iTime)*6.0);\r\n    float dd;\r\n    if(trac(p,d,dd)){\r\n        vec3 n = norm(p,dd);\r\n        vec3 light = normalize(lig-p);\r\n\r\n        col = vec3(0.6)*max(dot(n,light),0.1);\r\n        col+= rough(0.4, dot(reflect(d,n),light));\r\n        col*=shadow(p-d*0.1, lig);\r\n    }\r\n\r\n    col += volumetrics(prevp,p, lig)*0.7;\r\n    //col = mix(volumetrics(prevp,p, lig), col, 0.5);\r\n\r\n    float dist = abs(length(vec2(0.5) - fragCoord/iResolution.xy));\r\n    col-= dist*dist*0.6;\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"Mst3Wl",name:"Music visualiser by Ruzzyr",shader:"// https://www.shadertoy.com/view/Mst3Wl\r\nmat3 rotateYmat(float ang)\r\n{\r\n    return mat3(cos(ang), 0.0, sin(ang),\r\n                0.0, 1.0, 0.0,\r\n                -sin(ang), 0.0, cos(ang));\r\n}\r\nmat3 rotateXmat(float ang)\r\n{\r\n    return mat3(1.0, -0.0, 0.0,\r\n                0.0, cos(ang), -sin(ang),\r\n                0.0, sin(ang), cos(ang));\r\n}\r\n\r\nfloat sdSphere( vec3 p, float s )\r\n{\r\n    vec3 o = vec3(sin(p.x*2. + iTime*2.),cos(p.z*10. + iTime*2.),1.0)*0.1;\r\n\tfloat d = length(p + o)- s;\r\n\to = vec3(sin(p.x*3. + iTime*2.),cos(p.z*2. + iTime*2.),1.0)*0.2;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        float prism2 = length(p + o*float(i))- s;\r\n        d = max(d, -prism2);\r\n    }\r\n  \treturn d;\r\n}\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy/iResolution.xy;\r\n    uv = uv*2.0-1.0;\r\n    uv.x *= iResolution.x/iResolution.y;\r\n\r\n    vec3 dir = normalize(vec3(uv, 1.0))*rotateYmat(iTime)*rotateXmat(iTime);\r\n\r\n    float t = 0.0;\r\n\tvec3 p;\r\n    vec3 fc;\r\n        vec3 o = vec3(0.,0.,-4.)*rotateYmat(iTime)*rotateXmat(iTime);\r\n        vec4 s = texture (iChannel0,vec2(fragCoord.x/iResolution.x-0.01, 0.75));\r\n\t\tvec3 cl = vec3(.5 + sin(uv.x+iTime +s.x*5.)*.4,.5 +cos(uv.y+iTime + s.x*5.)*.5,.5);\r\n        for (int k = 0; k <15; k++)\r\n        {\r\n            p = o + t*dir;\r\n            float d = sdSphere(p, 2.0);\r\n\r\n            {\r\n                vec3 position = p;\r\n                float radius = 0.1+float(k)*0.5+clamp(s.x, 0.0, 1.0)*1.;\r\n                float lineThickness = 0.02 + float(k)*0.01;\r\n\r\n                vec3 o = vec3(sin(position.x*10. + iTime*0.9),sin(position.y*10. + iTime ),cos(position.z*10. + iTime*1.9))*0.5;\r\n                float condition = step(length(position + o) , radius)\r\n                                      - step(length(position + o), radius - lineThickness);\r\n                fc += cl*condition;\r\n            }\r\n\r\n            t += d;\r\n        }\r\n    fragColor = min(vec4(fc+cl*vec3(1.0/(1.0+t*t*0.1)), 1.0), vec4(1.0));\r\n}\r\n"},{id:"fssXD4",name:"Audio pulsar by atutahi",shader:"// https://www.shadertoy.com/view/fssXD4\r\nfloat Catmull_Rom(float x, float v0,float v1, float v2,float v3)\r\n{\r\n\tfloat c2 = -.5 * v0\t+ 0.5*v2;\r\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\r\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\r\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\r\n}\r\n\r\nfloat sampleFFT(float fftCoord)\r\n{\r\n    float atten = smoothstep(0.0, 0.05, 1.0 - fftCoord) * smoothstep(0.0, 0.05, fftCoord);\r\n    return atten * texture( iChannel0, vec2(fftCoord,0.25) ).x;\r\n}\r\n\r\nvec2 opRep( in vec2 p, in vec2 c)\r\n{\r\n    return mod(p+0.5*c,c)-0.5*c;\r\n}\r\n\r\n#define PI 3.14159\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec3 col = vec3(0.0);\r\n\r\n    // create pixel coordinates\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    uv = uv * 2. - 1.;\r\n    uv.x /= iResolution.y / iResolution.x;\r\n    uv += 0.3 * vec2(sin(-iTime * 0.3), cos(iTime * 0.5));\r\n    // second texture row is the sound wave\r\n\r\n\tfloat wave = texture( iChannel0, vec2(0.5,0.75) ).x;\r\n\r\n    float angle = atan(uv.y, uv.x);  // atan2\r\n    vec2 range = vec2(-PI, PI);  // The range of atan2 is [-pi / 1; pi / 1]\r\n    float theta = smoothstep(range[0], range[1], angle);  // Normalize the range of atan to [0;1]\r\n    theta = mod(theta + iTime * 0.05, 1.0);\r\n\r\n    float ro = length(uv);\r\n    ro *= 3.0 - 0.2 * clamp(0.0, 1.0, (pow(wave, 0.4)));\r\n    uv = vec2(theta, ro);\r\n\r\n    uv.y -= iTime * 0.65;\r\n    uv.y = opRep(uv, vec2(1.5)).y;\r\n\r\n    // Small perturbation of base circle\r\n    uv.y += 0.005 * (sin(-iTime * 1.8 + theta * 8.0 * PI) + sin(iTime * 4.0 + theta * 32.0 * PI));\r\n\r\n    float fftFreq = wave * clamp(0.0, 1.0, ro * 1.0) * 2.0 + 64.0;//10.0 + wave * 128.0;\r\n    float fftX = floor(uv.x * fftFreq);\r\n    float fftCoord1 = clamp(0.0, 1.0, fftX / fftFreq);\r\n\tfloat fft1 = sampleFFT(fftCoord1);\r\n\r\n    float fftCoord = (fftX - 1.0) / fftFreq;\r\n    float fft = sampleFFT(fftCoord);\r\n\r\n    float fftCoord2 = (fftX + 1.0) / fftFreq;\r\n    float fft2 = sampleFFT(fftCoord2);\r\n\r\n    float fftCoord3 = (fftX + 2.0) / fftFreq;\r\n    float fft3 = sampleFFT(fftCoord3);\r\n\r\n    float f = 0.6 * Catmull_Rom(fract(uv.x * fftFreq), fft, fft1, fft2, fft3);\r\n\r\n    float s = (0.01 + 1.6 * f) / abs(f-uv.y);\r\n    s = pow(s, 2.0 - wave * 0.6 - ro * 0.45 * (0.8 + 0.4 * wave));\r\n    s *= smoothstep(0.8, 0.0, uv.y);\r\n    s *= smoothstep(0.8, 0.0, -uv.y);\r\n\r\n\tcol += s;\r\n    col += 1.0 - smoothstep(0.0, 0.1, ro);\r\n    //col += fft - uv.y;\r\n    col *= vec3(0.1 + f * 1.5, 0.2,1.0 - f * 1.0);\r\n\r\n\t// output final color\r\n\tfragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"XsXGRf",name:"Psychedelic lines by Andre",shader:"// https://www.shadertoy.com/view/XsXGRf\r\n#define StepSize .5\r\n#define LineCount 30\r\n\r\n//Function to draw a line, taken from the watch shader\r\nfloat line(vec2 p, vec2 a, vec2 b, float thickness, float extend )\r\n{\r\n\tvec2 pa = p - a;\r\n\tvec2 ba = b - a;\r\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba),-extend,1.0 + extend);\r\n\treturn 1.0 - smoothstep(thickness * 0.8, thickness * 1.2, length(pa - ba * h));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\r\n\r\n\tvec2 wav = vec2(length(texture(iChannel0, vec2(uv.x, 1)).xyz),\r\n\t\t\t\t\tlength(texture(iChannel0, vec2(uv.y, 1)).xyz));\r\n    // wav *= 3.0;\r\n    //vec4 spec = texture(iChannel0, vec2(uv.y, 0));\r\n\r\n\tuv *= 2.0 - 1.0 ;\r\n    float extend  = wav.y;\r\n\r\n\t// convert the input coordinates by a cosinus\r\n\t// warpMultiplier is the frequency\r\n\tfloat warpMultiplier = (6.0 + 1.5 * sin(iTime * 0.125));\r\n\tvec2 warped = cos(uv * 6.28318530718 * warpMultiplier)-cos(uv.yx*17.77*sin(iTime)+iTime)+ 0.1*wav.xy-sin(uv.xy+iTime);\r\n\r\n\r\n\tfloat gt = iTime*2.0;//floor(iTime * 20.0) * StepSize;\r\n\r\n\r\n\t// blend between the warpeffect and no effect\r\n\t// don't go all the way to the warp effect\r\n\tfloat warpornot = smoothstep(.5, 18.0, 2.0*sin(iTime * .25)+warped.x+warped.y)*0.15;\r\n\r\n\t// Variate the thickness of the lines\r\n\tfloat thickness = pow(1.5- 1.45 * cos(iTime), 2.0) / iResolution.x - wav.x*0.003 + wav.y*0.003;\r\n\t// thickness *= .1 + (warpMultiplier * warpornot)  + wav.x + wav.y;\r\n\r\n    float brighness = .2/pow(thickness,.5);\r\n\t// Add 10 lines to the pixel\r\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\r\n\tfor (int i = 0; i < LineCount; i++)\r\n\t{\r\n\t\tgt += StepSize;\r\n\r\n\t\tthickness *= 1.25;\r\n        brighness *= 1.0/1.25;\r\n\t\tuv = mix(uv, warped, warpornot);\r\n\r\n\t\t//Calculate the next two points\r\n\t\tvec2 point1 = vec2(sin(gt * 0.39), cos(gt * 0.23));\r\n\t\tvec2 point2 = vec2(cos(gt * 0.29), sin(gt * 0.22));\r\n\r\n\t\t// Add new line\r\n\t\tcolor.rgb += line(\tuv,\r\n\t\t\t\t\t\t\tpoint1, point2,\r\n\t\t\t\t\t\t\tthickness,extend)\r\n\t\t\t\t\t//With color\r\n\t\t\t\t\t* ( brighness +\r\n\t\t\t\t\t\tbrighness * vec3(\tsin(gt * 1.73),\r\n\t\t\t\t\t\t\t\t\tcos(gt * 2.19),\r\n\t\t\t\t\t\t\t\t\tsin(gt * 1.67)));\r\n}\r\n\r\n\t// Clamp oversaturation\r\n\tfragColor = clamp(color, 0.0, 1.0);\r\n}\r\n"},{id:"4ltcDj",name:"skulls by nabr",shader:"// https://www.shadertoy.com/view/4ltcDj\r\n// nabr\r\n// https://www.shadertoy.com/view/4ltcDj\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\r\n\r\n\r\n\r\n#define time iTime\r\n#define _ vec2((fragCoord.xy*2.001-iResolution.xy )/iResolution.y)\r\n\r\n#define pi 3.14159265359\r\n#define pi2 6.28318530718\r\n\r\nfloat music(vec2 r){\r\n\r\n    // ----- music texture https://www.shadertoy.com/view/Xds3Rr\r\n\r\n \t// the sound texture is 512x2\r\n    int tx = int( r.x * 512.0);\r\n\r\n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\r\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x ;\r\n\r\n    // second row is the sound wave, one texel is one mono sample\r\n    return texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // music texture\r\n    float m = (music( abs(_) / 22.001 ))* .5 +.5 ;\r\n\r\n    // make a tunnel\r\n    float a = (.5+atan( length ( _ ), 1. ) * pi2);\r\n    float r = clamp(  a - acos(  _.y * 1.18 ) / pi2, 0., 1.);\r\n\r\n    // animate\r\n    // https://en.wikipedia.org/wiki/Shadertoy#Usage\r\n    vec2 uv =  vec2( 1./r + 0.2* time, m+a );\r\n    float f = sin(uv.x) * cos ( time  - uv.y);\r\n\r\n    // grid overlay\r\n    float grid = abs(0.01/ sin(  f + _.x * 12.) - f * cos( _.y))\r\n        \t\t - uv.y * abs(0.0015 / sin( f - _.y * 12.) - .081/cos(f*_.x));\r\n\r\n    // shade\r\n    vec3 col = (grid * 0.5) + (0.25 * cos(time- 0.25 + (pi2 * grid) + vec3( -pi/2., pi/2.6, pi )));\r\n\r\n    fragColor.rgb =  grid + pow(col + 0.2 , 2.2 / vec3( uv.x, uv.y , 1.-(uv.x+uv.y) ) );\r\n    fragColor.a = 1.;\r\n}\r\n"},{id:"WlSyWt",name:"PsyTrance by arminkz",shader:"// https://www.shadertoy.com/view/WlSyWt\r\nvec2 path(float t) {\r\n    float a = 1.,b=sin(t*.2);\r\n    return vec2(a*2., a*b);\r\n}\r\n\r\nfloat getSound(float i) {\r\n    return texture( iChannel0, vec2( 0.05 + 0.5*i/16.0, 0.25 ) ).x;\r\n}\r\n\r\nmat2 r2d(float a) {\r\n    float c=cos(a+7.*getSound(3.)+4.*getSound(1.)),s=sin(a+2.*getSound(3.)+4.*getSound(1.));\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nvoid mo(inout vec2 p, vec2 d) {\r\n    p.x = abs(p.x) - d.x;\r\n    p.y = abs(p.y) - d.y;\r\n    if(p.y>p.x)p=p.yx;\r\n}\r\n\r\nfloat g=0.;\r\nfloat de(vec3 p) {\r\n\r\n    vec3 q = p;\r\n    q.x += q.z*.1;\r\n    q.z += iTime*.1;\r\n    q = mod(q-1., 2.)-1.;\r\n    float s = length(q) - .001 + sin(iTime*40.)*.005;\r\n\r\n    p.xy -= path(p.z);\r\n\r\n    p.xy *= r2d(p.z*.9);\r\n    mo(p.xy, vec2(.6, .12));\r\n    mo(p.xy, vec2(.9, .2));\r\n\r\n    p.xy *= r2d(p.z*.5);\r\n\r\n    mo(p.zy, vec2(.1, .2));\r\n    p.x = abs(p.x) - .4;\r\n    float d = length(p.xy) - .02 - (.5+.5*sin(p.z))*.05;\r\n\r\n    d = min(d, s);\r\n\r\n\r\n    g+=.01/(.01+d*d);\r\n    return d;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.xy -.5;\r\n    uv.x*=iResolution.x/iResolution.y;\r\n\r\n    float dt = iTime * 6. + .5*sin(getSound(10.));\r\n    vec3 ro = vec3(0,0, -3. + dt);\r\n    vec3 ta = vec3(0, 0, dt);\r\n\r\n    ro.xy += path(ro.z);\r\n    ta.xy += path(ta.z);\r\n\r\n    vec3 fwd = normalize(ta -ro);\r\n    vec3 left = cross(vec3(0,1.0,0),fwd);\r\n    vec3 up = cross(fwd, left);\r\n\r\n    vec3 rd = normalize(fwd + left*uv.x+up*uv.y);\r\n\r\n    vec3 p;\r\n    float ri,t=0.;\r\n    for(float i=0.;i<1.;i+=.01) {\r\n    \tri = i;\r\n        p=ro+rd*t;\r\n        float d = de(p);\r\n        if(d<.001) break;\r\n        t+=d*.2;\r\n    }\r\n\tvec3 bg =  vec3(sin(0.5*dt), cos(dt+getSound(9.)), sin(getSound(6.)))*.3;\r\n    vec3 col = mix(vec3(.1, sin(dt), cos(dt)), bg,ri);\r\n    col += g*(.02);\r\n\r\n    col = mix(col, bg, 1.-exp(-.01*t*t));\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"ssXfD7",name:"My light show by Effickx",shader:"// https://www.shadertoy.com/view/ssXfD7\r\n#define yellow vec3(248.0, 223.0, 118.0)/256.0\r\n#define gray vec3(69.0, 41.0, 52.0)/256.0\r\n#define red vec3(255.0, 74.0, 68.0)/256.0\r\n#define green vec3(0.0, 255.0, 0.0)/256.0\r\n#define blue vec3(.0, 74.0, 255.0)/256.0\r\n\r\nvec3 circles(\r\n    vec2 uv,\r\n    vec2 position,\r\n    vec3 circles_color\r\n) {\r\n    return circles_color *\r\n    smoothstep(\r\n        (cos(iTime)+1.0)/4.0+0.5,\r\n        0.0,\r\n        length((uv+position)*length(fract(uv*5.0)-0.5))\r\n    );\r\n}\r\n\r\nmat2 rotate2d(float _angle){\r\n    return mat2(cos(_angle),-sin(_angle),\r\n                sin(_angle),cos(_angle));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float lowf=texelFetch( iChannel0, ivec2(0,0), 0 ).x;\r\n    float medf=texelFetch( iChannel0, ivec2(127,0), 0 ).x;\r\n    float highf=texelFetch( iChannel0, ivec2(511,0), 0 ).x;\r\n\r\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\r\n    uv=uv+vec2(cos(iTime/3.),sin(iTime/5.0));\r\n    uv=uv*rotate2d(iTime/3.0);\r\n\r\n    vec3 color=vec3(0);\r\n\r\n    color+=circles(\r\n        uv,\r\n        vec2(cos(iTime/5.0*4.0), sin(iTime/5.0*3.0)),\r\n        blue\r\n    )*highf*4.;\r\n\r\n    color+=circles(\r\n        uv,\r\n        vec2(cos(iTime/5.0*6.0), sin(iTime/5.0*7.0)),\r\n        green\r\n    )*lowf;\r\n\r\n    color+=circles(\r\n        uv,\r\n        vec2(cos(iTime/5.0*2.0), sin(iTime/5.0*5.0)),\r\n        red\r\n    )*medf*5.;\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"7lscWM",name:"abstract_audio_react by leamlld",shader:"// https://www.shadertoy.com/view/7lscWM\r\n// HELLO\r\n\r\n#define sound (texture(iChannel0, vec2(0.001,0.25)).x)\r\n\r\n\r\n//FORMES\r\n\r\nfloat sdSphere(vec3 c,vec3 p, float r)\r\n{\r\n    //return distance(p, c) - r + texture(iChannel1,(p.xy/p.xz/p.xx/p.xx)*(p.zx/p.zy/p.zz)*(p.yx/p.yy/p.yz)*clamp(sound,0.2,0.8)).r;\r\n    return distance(p, c) - r + (p.x/p.x/p.x/p.x/p.x)+(p.z/p.z/p.z/p.z/p.z)+(p.y/p.y/p.y/p.y/p.y)+clamp(sound,0.2,1.)*sound*2. ;\r\n}\r\n\r\n//DISPL\r\nfloat getDist(vec3 p)\r\n{\r\n    // Setup scene\r\n    return sdSphere(vec3(1.),p, 1.);\r\n}\r\n\r\n// ROTATION\r\n\r\nmat4 rotation3d(vec3 axis, float angle) {\r\n  axis = normalize(axis);\r\n  float s = sin(angle);\r\n  float c = cos(angle);\r\n  float oc = 1.0 - c;\r\n\r\n  return mat4(\r\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\r\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\r\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\r\n        0.0,                                0.0,                                0.0,                                1.0\r\n    );\r\n}\r\n\r\nvec3 rotate(vec3 v, vec3 axis, float angle) {\r\n    return (rotation3d(axis, angle) * vec4(v, 1.0)).xyz;\r\n}\r\n\r\n\r\n// PALETTES\r\n\r\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\r\n{\r\n    return a + b*cos( 61.28318*(c*t+d) );\r\n}\r\n\r\n\r\nfloat map(vec3 pos) // position 3d de la marche\r\n{\r\n\r\n\r\n\r\n    float volume = 0.0;\r\n\r\n    pos.x+= sin(iTime);\r\n    pos.y += cos(iTime);\r\n\r\n    pos.z +=sound;\r\n    float sphere = sdSphere( vec3(5.), pos +vec3(1.,-2.,0.) , 2.5);\r\n\r\n    volume=sphere;\r\n    return volume;\r\n}\r\n\r\n\r\nfloat CastRay(vec3 ro, vec3 rd)\r\n{\r\n\r\n\r\n    float c = 0.0; // contact\r\n    for (int i = 0; i<60;i++)\r\n    { // nombre de pas du ray\r\n        float ray = map(ro+rd*c);\r\n        if(ray<(0.0001*c))// distance min = contact\r\n        {\r\n            return float(i)/32.;\r\n        }\r\n\r\n        c+= ray;\r\n    }\r\n\r\n    return -1.0;\r\n\r\n}\r\n\r\nvec3 render(vec3 ro, vec3 rd)\r\n{\r\n\r\n\r\n    float contact = CastRay(ro,rd); // appel du raycast\r\n    vec3 col = vec3(0.0); // couleur de base du pixel\r\n\r\n    if (contact ==-1.)// sil ny a pas de contact\r\n    {\r\n\r\n        col=vec3(0.);// couleur du fond\r\n\r\n    }\r\n    else\r\n    {\r\n        //vec3 nor = GetNormal(ro+rd * contact);\r\n        //col= vec3(1.-contact); // couleur du volume (blanc)\r\n\r\n        float depth = vec3(1.-contact).r;\r\n        col = palette(depth ,vec3(0.5),vec3(0.5),vec3(1.),vec3(clamp(sound,0.1,0.8),0.3,0.37));\r\n\r\n\r\n    }\r\n\r\n    return col;\r\n\r\n}\r\n\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\r\n\r\n    vec2 uv = 2.* fragCoord/iResolution.xy -1.;\r\n    uv.x*=iResolution.x/iResolution.y;\r\n    //vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\r\n\r\n\r\n    // parametres camera\r\n    vec3 cameraPos = vec3(10., 10., 10.);;\r\n\r\n\r\n    vec3 cameraTar = vec3(0.0, 2.0, 0.0);\r\n\r\n    // vecteur de direction depuis la cam\r\n\r\n    vec3 forward= normalize(cameraTar- cameraPos);\r\n    vec3 right = normalize (cross(vec3(0.,-1.,0.),forward));\r\n    vec3 up = normalize (cross(right,forward));\r\n    vec3 viewDir = normalize (uv.x* right + uv.y * up + 2. * forward);\r\n\r\n\r\n    ///vec3 col;\r\n    vec3 col = render(cameraPos,viewDir);\r\n\r\n\r\n\r\n    //affichage des uv\r\n    //vec3 col = render(cameraPos,viewDir);\r\n\r\n    fragColor =vec4 (col,1.);\r\n\r\n\r\n\r\n\r\n}\r\n"},{id:"ldsXWH",name:"solarDance [mod1] by entropynine",shader:"// https://www.shadertoy.com/view/ldsXWH\r\n// based on https://www.shadertoy.com/view/lsf3RH by\r\n// trisomie21 (THANKS!)\r\n// modified only for learning fun\r\n\r\nfloat snoise(vec3 uv, float res)\t// code modded from trisomie21\r\n{\r\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\r\n\r\n\tuv *= res;\r\n\r\n\tvec3 uv0 = floor(mod(uv, res))*s;\r\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\r\n\r\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\r\n\r\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\r\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\r\n\r\n\tvec4 r = fract(sin(v*1e-3)*1e5);\r\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\r\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\r\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\r\n\r\n\treturn mix(r0, r1, f.z)*2.-1.;\r\n}\r\n\r\nfloat freqs[4];\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\r\n\r\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\r\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\r\n\tfloat invRadius \t= 1.0/radius;\r\n\r\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\r\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\r\n\tfloat time\t\t= iTime * 0.1;\r\n\tfloat aspect\t= iResolution.x/iResolution.y;\r\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\r\n\tvec2 p \t\t\t= -0.5 + uv;\r\n\tp.x *= aspect;\r\n\r\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.5 );\r\n\tfloat fVal1\t\t= 1.0 - fade;\r\n\tfloat fVal2\t\t= 1.0 - fade;\r\n\r\n\tfloat angle\t\t= atan( p.x, p.y )/6.2832;\r\n\tfloat dist\t\t= length(p);\r\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\r\n\r\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\r\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\r\n\tfor( int i=1; i<=7; i++ ){\r\n\t\tfloat power = pow( 2.0, float(i + 1) );\r\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\r\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\r\n\t}\r\n\r\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\r\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.5*sin(iTime) ), 2.0 ) * 50.0;\r\n\tcorona\t\t\t\t*= 1.2 - newTime1;\r\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\r\n\tvec3 dir \t\t\t= vec3( 0.0 );\r\n\tvec3 center\t\t\t= vec3( 0.5, 0.5*sin(iTime), 1.0 );\r\n\tvec3 starSphere\t\t= vec3( 0.0 );\r\n\r\n\tvec2 sp = -1.0 + 2.0 * uv;\r\n\tsp.x *= aspect;\r\n\tsp *= ( 2.0 - brightness );\r\n  \tfloat r = dot(sp,sp);\r\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5*sin(iTime);\r\n\tif( dist < radius ){\r\n\t\tcorona\t\t\t*= pow( dist * invRadius, 24.0 );\r\n  \t\tvec2 newUv;\r\n \t\tnewUv.x = sp.x*f;\r\n  \t\tnewUv.y = sp.y*f;\r\n\t\tnewUv += vec2( time, 0.0 );\r\n\r\n\t\tvec3 texSample \t= texture( iChannel1, newUv ).rgb;\r\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\r\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\r\n\t\tstarSphere\t\t= texture( iChannel1, starUV ).rgb;\r\n\t}\r\n\r\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\r\n\t//fragColor.rgb\t= vec3( r );\r\n\tfragColor.rgb\t= vec3( f * ( 0.75 + brightness * 0.3 ) * orange ) + starSphere + corona * orange + starGlow * orangeRed;\r\n\tfragColor.a\t\t= 1.0;\r\n}\r\n"},{id:"7slGWj",name:"Beat of broken hearts by Hultsborn10",shader:"// https://www.shadertoy.com/view/7slGWj\r\nfloat RAYS = 54.0;\r\n//https://soundcloud.com/castorcinema/beat-of-broken-hearts-feat\r\n//https://soundcloud.com/clemenswenners/africa\r\n//https://soundcloud.com/noa-edwardsson/we-are-the-ones\r\n//https://soundcloud.com/br-ndon-kucharek/rings-of-saturn-utopia\r\n//https://soundcloud.com/mukunda-mtandari/smooth-and-sexy-smooth-jazz-for-lovers\r\n\r\nfloat R21(vec2 uv)\r\n{\r\n    float a = abs(sin(uv.x*1.1));\r\n    float b = abs(cos(uv.y*104.7));\r\n    return(a*b);\r\n}\r\n\r\n\r\n//Avståndet mellan punkten p och linjen från a till b\r\nfloat DistLine(vec2 p, vec2 a, vec2 b)\r\n{\r\n    vec2 ap = p-a;\r\n    vec2 ab = b-a;\r\n    //Längden av skuggan av ap utmed ab\r\n    float lShadow = dot(ap, ab);\r\n    //Längden av ab\r\n    float lab = dot(ab, ab);\r\n    //Låt t bli kvoten (andelen) av ab som skuggan utgör\r\n    //Se till att den inte blir negativ\r\n    float t = clamp(lShadow/lab, 0.0, 1.0);\r\n    //Ta fram vektorn från punkten p till toppen av skuggan,\r\n    vec2 sp = ap - ab*t;\r\n    //returnera längden av den nya vektorn\r\n    return length(sp);\r\n}\r\n\r\nfloat GetDist(vec2 uv, vec2 rayP)\r\n{\r\n    vec2 origin = vec2(0.0,0.0);\r\n    float d = DistLine(uv, origin, rayP);\r\n    float w = 0.05;\r\n    float wz = 0.01;\r\n    float c = smoothstep(w/RAYS, w/RAYS+wz, d);\r\n    /*\r\n    vec2 top = vec2(0.0, 5.0 );\r\n    vec2 bottom = vec2(0.0, -5.0);\r\n    vec2 lef = vec2(-5.0, 0.0);\r\n    vec2 rig = vec2(5.0, 0.0);\r\n    float d1 = DistLine(uv, top, bottom);\r\n    float d2 = DistLine(uv, lef, rig);\r\n    c = min(d1,d2);\r\n    */\r\n    //return smoothstep(0.5, 0.0, c);\r\n    return c;\r\n}\r\n\r\nvec2 GetRayPoint(float rayNumber, float length)\r\n{\r\n    float angle = rayNumber/RAYS*6.28;\r\n    float x = cos(angle)*length;\r\n    float y = sin(angle)*length;\r\n    vec2 p = vec2(x,y);\r\n    return p;\r\n}\r\n\r\nvec2 Rotate(vec2 uv, float angle){\r\n    float s = sin(angle);\r\n    float c = cos(angle);\r\n    float x = c*uv.x + s*uv.y;\r\n    float y = s*uv.x - c*uv.y;\r\n    return vec2(x,y);\r\n}\r\n\r\nfloat GetRayNumber(vec2 uv)\r\n{\r\n    //Beräkna en vinkel som går från -0.5 till 0.5\r\n    float angle = (atan(uv.y, uv.x)/6.28);\r\n    //Multiplicera med antalet strålar\r\n    float ray = angle*RAYS;\r\n    return ray;\r\n}\r\n\r\nfloat GetRayWheel(vec2 uv, float freqOffset, float raylength, float rotate)\r\n{\r\n    uv = Rotate(uv, rotate);\r\n    float ray = GetRayNumber(uv);\r\n    //Raycenter är ett heltal från -antal strålar/2 till +RAYS/2\r\n    float raycenter = floor(ray);\r\n    //Ta fram längden på strålen från frekvensspektrat i musiken\r\n    float frequency = raycenter + RAYS/2.0;\r\n    if (frequency < 0.1) frequency = RAYS;\r\n    frequency += freqOffset;\r\n    float fft = raylength * texelFetch(iChannel0, ivec2(frequency, 0), 0).x;\r\n\r\n    //Beräkna avståndet till de två närmaste strålarna\r\n    vec2 p = GetRayPoint(raycenter, fft);\r\n    float d = (1.0-GetDist(uv, p));\r\n    //Första halva topp-punkten\r\n    float pSize = 0.99;\r\n    float pc = smoothstep(pSize, 1.0, 1.0-length(uv-p));\r\n    //Blinkning till topp-punkten\r\n    float pcBlink = 0.5 + 0.5*sin(iTime*20.0+raycenter);\r\n    pc *=pcBlink;\r\n\r\n    raycenter = ceil(ray);\r\n    frequency = raycenter + RAYS/2.0;\r\n    if (frequency < 0.1) frequency = RAYS;\r\n    frequency += freqOffset;\r\n    //Ta fram längden på strålen från frekvensspektrat i musiken\r\n    fft = raylength * texelFetch(iChannel0, ivec2(frequency, 0), 0).x;\r\n    p = GetRayPoint(raycenter, fft);\r\n    d += (1.0-GetDist(uv, p));\r\n    float c = d*length(uv);\r\n    //Blinkning till topp-punkten\r\n    if ((RAYS/2.0-raycenter)<0.1) raycenter = -raycenter;\r\n    pcBlink = 0.5 + 0.5*sin(iTime*20.0+raycenter);\r\n    //Andra halvan av topp-punkten\r\n    pc += smoothstep(pSize, 1.0, 1.0-length(uv-p))*pcBlink;\r\n    c *= R21(uv);\r\n    return 10.0*c+25.0*pc;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from -0.5 to 0.5 vertically)\r\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\r\n    //uv*=0.5;\r\n    uv = Rotate(uv,-iTime*0.1);\r\n    //vec3 col = vec3(0.9, 0.2 , 0.1);//röd-orange\r\n    vec3 col = 0.3+0.3*vec3(sin(iTime*0.5),sin(iTime*0.4),sin(iTime*0.3));\r\n    float c = GetRayWheel(uv, 0.0, 1.0, 0.0);\r\n    //float rotation = 3.14/RAYS;\r\n    //\r\n    float rotation = -iTime*0.1;\r\n    c += 1.4*GetRayWheel(uv, 2.0*RAYS, 0.4, rotation);\r\n    //\r\n    rotation = -iTime*0.2;\r\n    c += 1.4*GetRayWheel(uv, RAYS, 0.75, rotation);\r\n    col *= c;\r\n    //en ljus cirkel\r\n    float d = 1.0-length(uv);\r\n    vec3 dcol = vec3(0.5, 0.5, 0.1);\r\n    col += d*dcol;\r\n    //en vit cirkel\r\n    d = smoothstep(0.8, 1.0,1.0-length(uv));\r\n    dcol = vec3(.5);\r\n    col += d*dcol;\r\n    //col = d*dcol;\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"3sfXRj",name:"Issues - Don Toliver by IsaacAndersen",shader:"// https://www.shadertoy.com/view/3sfXRj\r\nfloat line(vec2 p, vec2 p0, vec2 p1)\r\n{\r\n    vec2 a = p-p0; // the vector that we want to project on b\r\n    vec2 b = p1-p0; // this line is our goal.\r\n\r\n    vec2 proj = clamp((dot(a,b)/dot(b,b)),0.0,1.0)*b; // vector projection of a onto b\r\n    vec2 rejc = a-proj; // vector rejection or distance in other words\r\n\r\n    return smoothstep(0.0,1.2,1.0-dot(rejc, rejc)*1e4);\r\n} // stolen: https://www.shadertoy.com/view/4d3fWr\r\n\r\nvec2 random12(float i) {\r\n    return normalize(vec2(sin(329.34+131.8*sin(722.1*i+8.23)),\r\n                sin(494.34+2871.1*sin(431.1*i+415.39))));\r\n}\r\n\r\nfloat random (in vec2 _st) {\r\n    return fract(sin(dot(_st.xy,\r\n                         vec2(12.9898,78.233)))*\r\n        43758.5453123);\r\n}\r\n\r\n// Based on Morgan McGuire @morgan3d\r\n// https://www.shadertoy.com/view/4dS3Wd\r\nfloat noise (in vec2 _st) {\r\n    vec2 i = floor(_st);\r\n    vec2 f = fract(_st);\r\n\r\n    // Four corners in 2D of a tile\r\n    float a = random(i);\r\n    float b = random(i + vec2(1.0, 0.0));\r\n    float c = random(i + vec2(0.0, 1.0));\r\n    float d = random(i + vec2(1.0, 1.0));\r\n\r\n    vec2 u = f * f * (3.0 - 2.0 * f);\r\n\r\n    return mix(a, b, u.x) +\r\n            (c - a)* u.y * (1.0 - u.x) +\r\n            (d - b) * u.x * u.y;\r\n}\r\n\r\n#define NUM_OCTAVES 5\r\n\r\nfloat fbm ( in vec2 _st) {\r\n    float v = 0.0;\r\n    float a = 0.5;\r\n    vec2 shift = vec2(100.0);\r\n    // Rotate to reduce axial bias\r\n    mat2 rot = mat2(cos(0.5), sin(0.5),\r\n                    -sin(0.5), cos(0.50));\r\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\r\n        v += a * noise(_st);\r\n        _st = rot * _st * 2.0 + shift;\r\n        a *= 0.5;\r\n    }\r\n    return v;\r\n}\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 R = iResolution.xy;\r\n    vec2 uv = ( U - 0.5*R) / R.y;\r\n    float t = iTime/2.;\r\n\r\n    float angle1 = (3.1415)* (t/4.0);\r\n\r\n    float s1 = sin(angle1);\r\n    float c1 = cos(angle1);\r\n\r\n    uv *= mat2(c1, -s1, s1, c1);\r\n\r\n\r\n  \tvec2 bgUV = uv * 10.;\r\n\r\n\tvec3 col = vec3(124,41,212)/255.0;\r\n\r\n\r\n\r\n    float m = texture( iChannel0, vec2(1.,0.25) ).x;;\r\n\r\n    float col_1 = -fbm(bgUV + vec2(t,0.)+fbm(bgUV + t));\r\n\r\n\tcol += col_1;\r\n\r\n    vec3 col2 = vec3(0);\r\n\r\n    float numChannels = 16.; // all 512 seems overkill\r\n    float maxFreq = 0.;\r\n    for(float i = 0.; i < 1.; i += 0.0625) {\r\n        float fft  = texture( iChannel0, vec2(i,0.25) ).x;\r\n\r\n        for(float j = 0.; j < 4.;j+= 1.) {\r\n            vec2 segment = random12(i+j)*fft;\r\n            col2 += line(uv, vec2(0),segment*fbm(segment+t))*fft;\r\n        }\r\n\r\n    }\r\n\r\n    col2 *= 0.4 + 0.6*sin(18.*smoothstep(-1.,1.,m)*(1.0-length(uv)));\r\n\r\n    col += col2;\r\n\r\n\t// output final color\r\n\tO = vec4(col,1.0);\r\n}\r\n"},{id:"3t3yRl",name:"Shamosis - Dinopwaur by z0rg",shader:"// https://www.shadertoy.com/view/3t3yRl\r\n// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/\r\n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\r\n// =========================================================================================================\r\n\r\n#define FFT(p) pow(texelFetch(iChannel0, ivec2(int(p), 0), 0)*.45, vec4(4.5))\r\n\r\nfloat lenny(vec2 v)\r\n{\r\n  return abs(v.x)+abs(v.y);\r\n}\r\n#define sat(a) clamp(a, 0.,1.)\r\nmat2 r2d(float a)\r\n{\r\n  float ca = cos(a);\r\n  float sa = sin(a);\r\n\r\n  return mat2(ca,-sa, sa, ca);\r\n}\r\nvec2 _sub(vec2 a, vec2 b)\r\n{\r\n  if (a.x > -b.x)\r\n    return a;\r\n  return b;\r\n}\r\n\r\nvec2 _min(vec2 a, vec2 b)\r\n{\r\n  if (a.x < b.x)\r\n    return a;\r\n  return b;\r\n}\r\nfloat sdCylinder( vec3 p, vec3 c )\r\n{\r\n  return length(p.xz-c.xy)-c.z;\r\n}\r\n\r\n// power smooth min (k = 8);\r\nfloat _smin( float a, float b, float k )\r\n{\r\n    a = pow( a, k ); b = pow( b, k );\r\n    return pow( (a*b)/(a+b), 1.0/k );\r\n}\r\n\r\nvec3 getDir(vec3 rd, vec2 uv)\r\n{\r\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\r\n  vec3 u = normalize(cross(r, rd));\r\n\r\n  return rd+ r * uv.x + u * uv.y;\r\n}\r\n\r\nfloat rhombus(vec3 p, float sz)\r\n{\r\n  p = abs(p);\r\n  return (p.x+p.y+p.z-sz)*0.577;\r\n}\r\n\r\n\r\nvec2 map(vec3 p)\r\n{\r\n  float beat = FFT(5).x*3.;\r\n  vec2 cyl = vec2(sdCylinder(p, vec3(1., 1., 1.)), 0.);\r\n  vec3 p2 = p;\r\n  p2.xz += vec2(sin(beat), cos(beat))*4.;\r\n  vec2 sph = vec2(length(p2)-2.5*max(FFT(55).x, 0.007)*70., 0.);\r\n  p2 = p+vec3(1.);\r\n  vec2 sph2 = vec2(rhombus(p2, 5.5*max(FFT(205).x, 0.005)*70.), 0.);\r\n  return _min(_min(sph2, sph), cyl);\r\n  vec2 fl = vec2(p.y, 1.);\r\n  return _min(cyl, fl);\r\n}\r\n\r\nvec3 calcNormal( in vec3 p, in float t )\r\n{\r\n    float e = 0.001*t;\r\n\r\n    vec2 h = vec2(1.0,-1.0)*0.5773;\r\n    return normalize( h.xyy*map( p + h.xyy*e ).x +\r\n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x +\r\n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x +\r\n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\r\n}\r\n\r\nvec3 checkerBoard(vec2 uv)\r\n{\r\n  uv.y+=iTime*5.;\r\n  float sz = 1.5;\r\n  float x = mod(uv.x, sz)-sz*.5;\r\n  float y = mod(uv.y, sz)-sz*.5;\r\n  x = sat(x*200.);\r\n  float res = mix(x, 1.-x, sat(y*200.));\r\n  return vec3(res);\r\n}\r\n\r\nvec3 grad(vec2 uv)\r\n{\r\n  vec3 col;\r\n  vec3 blue = vec3(157., 200., 255.)/255.;\r\n  vec3 yellow = vec3(255, 241., 187.)/255.;\r\n  vec3 red = vec3(255., 190., 191.)/255.;\r\n\r\n  float sz = 19.;\r\n\r\n  if (uv.y < 0.)\r\n  {\r\n    return mix(yellow, red, sat(-uv.y*sz));\r\n  }\r\n\r\n\r\n  return mix(yellow, blue, sat(uv.y*sz));\r\n}\r\n\r\nfloat sig(vec2 uv)\r\n{\r\n  float attenBorder = 1.;\r\n  float t = iTime;// iTime;\r\n  float tst = sin(abs(uv.x)*5.+t)*.002;\r\n  return uv.y -.01- (attenBorder*sat(FFT(abs(uv.x*.005)).x*5.))*.05-tst;//*(1.-sat(abs(uv.x*2.)), 5.);\r\n}\r\n\r\nvec3 rdr(vec2 uv)\r\n{\r\n  vec3 col;\r\n  col = vec3(0.123, 0.07, 0.15);\r\n\r\n  vec3 rgb = pow(grad(uv), vec3(1.45));\r\n  rgb.x *= .6+sat(FFT(uv.x*.1).x)*100.;\r\n\r\n  vec2 ouv = uv;\r\n  uv = vec2(atan(uv.y, uv.x), length(uv));\r\n  float ln = abs(sig(uv))-.00001;\r\n\r\n    col = mix(col, rgb, 1.-sat(ln*800.));\r\n    col += rgb *pow(1.-sat(ln*10.), 5.);\r\n\r\n\r\n  for (int i = 0; i < 8; ++i)\r\n  {\r\n    float fi = float(i);\r\n\r\n    vec2 uvt = ouv * r2d(fi);\r\n    uvt = vec2(atan(uvt.y, uvt.x), length(uvt));\r\n    float ln2 = abs(sig(uvt*fi/8.))-.00001*fi*fi;\r\n\r\n    col += .3*rgb *pow(1.-sat(ln2*950.), 5.);\r\n\r\n  }\r\n\r\n\r\n  return col;\r\n}\r\n\r\n\r\n\r\nvec2 myPixel(vec2 uv, float k)\r\n{\r\n  vec2 pxuv = uv/k;\r\n  pxuv = vec2(int(pxuv.x), int(pxuv.y))*k;\r\n  return pxuv;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy)/iResolution.xx;\r\n uv *= .2;\r\n\r\n\r\n\r\n  float rep = 1.+(sin(iTime*.5) < 0. ? 1. : sat(FFT(5).x*50.));\r\n\r\n  if (false)//iTime > 78.8)\r\n  {\r\n\r\n  float rep2 = .1*sin(iTime*.5);\r\n  uv *= r2d(sin(iTime+length(uv)*145.));\r\n  uv.x = mod(uv.x, rep2)-.5*rep2;\r\n  }\r\n  uv *= r2d(-3.14159265/2.);\r\n  uv *= mod(-iTime, 2.);\r\n  float r = 0.05/(sin(iTime));\r\n  uv *= r2d(mod(length(uv), r)/r);\r\n\r\n  vec2 uv2 = uv;\r\n  uv2.x = (mod(atan(uv.y, uv.x), rep)-.5*rep)*.1;\r\n  uv2.y = FFT(abs(uv.y)).x+length(uv)*(mod(iTime*.5, 2.5))+sin(iTime)*.05;\r\n\r\n  uv2 = myPixel(uv2, 0.01*sin(iTime*.5));\r\n\r\n  vec3 col =rdr(uv2)*.7;\r\n  col += rdr(uv)*.1*(sin(iTime*.2)*.5+.5);\r\n\tcol *= .5+rdr(uv*.2);\r\n    float a = atan(uv.y, uv.x);\r\n    col = mix(col, mix(col.zyx, col, 0.), sat(sin(uv.x*15.+iTime)+.1*sin(length(uv-a*3.14159265*2.-iTime))));\r\n  col = pow(col, vec3(1.45));\r\n  vec3 txt;// = texture(iChannel1, fragCoord/iResolution.xy).xyz;\r\n  col *= mix(vec3(1.), vec3(5.), txt.x);\r\n  //col *= sat(iTime-2.);\r\n  col *= 1.-sat(iTime-502.);\r\n  fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"fd2GD1",name:"Shimmy by Kali",shader:"// https://www.shadertoy.com/view/fd2GD1\r\n#define iTime iChannelTime[0]\r\nfloat det=.005, maxdist=50., pi=3.1416, gl=0.;\r\nvec2 id;\r\n\r\n\r\nfloat hash12(vec2 p)\r\n{\r\n    p*=1000.;\r\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\r\n    p3 += dot(p3, p3.yzx + 33.33);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n\r\nmat2 rot(float a)\r\n{\r\n    float s=sin(a), c=cos(a);\r\n    return mat2(c,s,-s,c);\r\n}\r\n\r\nfloat box(vec3 p, vec3 c)\r\n{\r\n    vec3 pc=abs(p)-c;\r\n    return length(max(vec3(0.),pc))-min(0.,max(pc.z,max(pc.x,pc.y)));\r\n}\r\n\r\nvec2 amod(vec2 p, float n, float off, out float i)\r\n{\r\n    float l=length(p)-off;\r\n    float at=atan(p.x,p.y)/pi*n*.5;\r\n    i=abs(floor(at));\r\n    float a=fract(at)-.5;\r\n    return vec2(a,l);\r\n}\r\n\r\nfloat ring(vec3 p,inout vec2 id)\r\n{\r\n    p.xy=amod(p.xy*rot(iTime*0.), 20., 2., id.x);\r\n    float h=max(0.,texture(iChannel0,vec2(.5+fract(id.x*.2+id.y*.1),0.)*.5).r*3.-.5);\r\n    h+=sin(iTime*10.+id.x)*.2;\r\n    float d=box(p+vec3(0.,-h*1.5,0.),vec3(.1,h,.1));\r\n    return d*.5;\r\n}\r\n\r\nfloat de(vec3 p)\r\n{\r\n    float d=100.,ii=0.;\r\n    p.xz*=rot(iTime);\r\n    p.yz*=rot(sin(iTime));\r\n    float r=4.;\r\n    vec2 ids;\r\n    for (float i=0.; i<4.; i++)\r\n    {\r\n        p.xz*=rot(pi/r);\r\n        ids.y=i;\r\n        float r=ring(p,ids);\r\n        if (r<d)\r\n        {\r\n            d=r;\r\n            id=ids;\r\n        }\r\n    }\r\n    d=min(d,length(p)-1.5);\r\n    return d*.7;\r\n}\r\n\r\nvec3 normal(vec3 p)\r\n{\r\n    vec2 e=vec2(0.,det);\r\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\r\n}\r\n\r\n\r\nvec3 march(vec3 from, vec3 dir)\r\n{\r\n    float d, td=0.;\r\n    vec3 p, col=vec3(0.);\r\n    for (int i=0; i<100; i++)\r\n    {\r\n        p=from+td*dir;\r\n        d=de(p);\r\n        if (d<det || td>maxdist) break;\r\n        td+=d;\r\n        gl+=.1/(10.+d*d*10.)*step(.7,hash12(id+floor(iTime*5.)));\r\n    }\r\n    if (d<det)\r\n    {\r\n        //id+=floor(iTime*5.);\r\n        vec3 colid=vec3(hash12(id),hash12(id+123.123),1.);\r\n        p-=dir*det;\r\n        vec3 n=normal(p);\r\n        vec2 e=vec2(0.,.05);\r\n        col=.1+max(0.,dot(-dir,n))*colid;\r\n        col*=.5+step(.7,hash12(id+floor(iTime*5.)));\r\n    }\r\n    else\r\n    {\r\n        dir.xz*=rot(iTime*.5);\r\n        dir.yz*=rot(iTime*.25);\r\n        vec2 p2=abs(.5-fract(dir.yz));\r\n        float d2=100.,is=0.;\r\n        for(int i=0; i<10; i++)\r\n        {\r\n            p2=abs(p2*1.3)*rot(radians(45.))-.5;\r\n            float sh=length(max(vec2(0.),abs(p2)-.05));\r\n            if (sh<d2)\r\n            {\r\n                d2=sh;\r\n                is=float(i);\r\n            }\r\n        }\r\n        col+=smoothstep(.05,.0,d2)*fract(is*.1+iTime)*normalize(p+50.);\r\n    }\r\n    return col*mod(gl_FragCoord.y,4.)*.5+gl;\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\r\n    vec3 from = vec3(0.,0.,-8.);\r\n    vec3 dir = normalize(vec3(uv,.7));\r\n    vec3 col = march(from, dir);\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"tlySzm",name:"Chromatic Resonance by PixelPhil",shader:"// https://www.shadertoy.com/view/tlySzm\r\n//\r\n// Chromatic Resonance by Philippe Desgranges\r\n// Email: Philippe.desgranges@gmail.com\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n//\r\n\r\n#define MUSIC_REACTION 0.2\r\n\r\n#define S(a, b, c) smoothstep(a, b, c)\r\n#define sat(a) clamp(a, 0.0, 1.0)\r\n\r\n#define pi 3.14159265359\r\n#define pi2 (pi * 2.0)\r\n#define halfPi (pi * 0.5)\r\n\r\n\r\n// Some hash function 2->1\r\nfloat N2(vec2 p)\r\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\r\n    p = mod(p, vec2(1456.2346));\r\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\n\r\n\r\nfloat CosineInterpolate(float y1, float y2, float t)\r\n{\r\n   float mu = (1.0 -cos(t * pi)) * 0.5;\r\n   return (y1 * (1.0 - mu) + y2 * mu);\r\n}\r\n\r\n// A 2d Noise (Cosine interpolation is more plasing for this effect)\r\nfloat Noise2(vec2 uv)\r\n{\r\n    vec2 corner = floor(uv);\r\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\r\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\r\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\r\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\r\n\r\n    vec2 diff = fract(uv);\r\n\r\n    return CosineInterpolate(CosineInterpolate(c00, c10, diff.x), CosineInterpolate(c01, c11, diff.x), diff.y);\r\n}\r\n\r\nfloat LineNoise(float x, float t)\r\n{\r\n    float n = Noise2(vec2(x * 0.6, t * 0.2));\r\n    //n += Noise2(vec2(x * 0.8, t * 0.2 + 34.8)) * 0.5;\r\n    //n += Noise2(vec2(x * 1.2, t * 0.3 + 56.8)) * 0.25;\r\n\r\n    return n - (1.0) * 0.5;\r\n}\r\n\r\n\r\nfloat line(vec2 uv, float t, float scroll)\r\n{\r\n\r\n    float ax = abs(uv.x);\r\n    uv.y *= 0.5 + ax * ax * 0.3;\r\n\r\n\r\n    uv.x += iTime * scroll;\r\n\r\n    float n1 = LineNoise(uv.x, t);\r\n\r\n\r\n    float n2 = LineNoise(uv.x + 0.5, t + 10.0) * 2.0;\r\n\r\n    float ay = abs(uv.y - n1);\r\n    float lum = S(0.02, 0.00, ay) * 1.5;\r\n    lum += S(1.5, 0.00, ay) * 0.1;\r\n\r\n\r\n    float r = (uv.y - n1) / (n2 - n1);\r\n    float h = sat(1.0 - r);\r\n    if (r > 0.0) lum = max(lum, h * h * 0.7);\r\n\r\n    return lum;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\r\n\r\n\r\n    float xWave = fragCoord.x / iResolution.x;\r\n\r\n    float wave = texture(iChannel0, vec2(xWave * 0.2, 1.0)).r * sin(iTime * 0.2 ) * MUSIC_REACTION;\r\n    float wave1 = texture(iChannel0, vec2(xWave * 0.2 + 0.2, 1.0)).r * sin(iTime * 0.2 + 0.5) * MUSIC_REACTION;\r\n    float wave2 = texture(iChannel0, vec2(xWave * 0.2 + 0.4, 1.0)).r * sin(iTime * 0.2 + 1.0) * MUSIC_REACTION;\r\n    float wave3 = texture(iChannel0, vec2(xWave * 0.2 + 0.6, 1.0)).r * sin(iTime * 0.2 + 1.5) * MUSIC_REACTION;\r\n    float wave4 = texture(iChannel0, vec2(xWave * 0.2 + 0.8, 1.0)).r * sin(iTime * 0.2 + 2.0) * MUSIC_REACTION;\r\n\r\n  //  fragColor = vec4(lum, lum, lum, 1.0); return;\r\n\r\n\r\n    float lum = line(uv * vec2(2.0, 1.0)+  vec2(0.0, wave), iTime * 0.3, 0.1) * 0.6;\r\n    lum += line(uv * vec2(1.5, 0.9) +  vec2(0.33, wave1), iTime * 0.5 + 45.0, 0.15) * 0.5;\r\n    lum += line(uv * vec2(1.3, 1.2) +  vec2(0.66, wave2), iTime * 0.4 + 67.3, 0.2) * 0.3;\r\n    lum += line(uv * vec2(1.5, 1.15) +  vec2(0.8, wave3), iTime * 0.77 + 1235.45, 0.23) * 0.43;\r\n    lum += line(uv * vec2(1.5, 1.15) +  vec2(0.8, wave4), iTime * 0.77 + 456.45, 0.3) * 0.25;\r\n\r\n\r\n    float ax = abs(uv.x);\r\n\r\n    lum += ax * ax * 0.05;\r\n\r\n\r\n    vec3 col;\r\n\r\n    float x = uv.x * 1.2 + iTime * 0.2;\r\n\r\n    vec3 hue = (sin(vec3(x, x + pi2 * 0.33, x + pi2 * 0.66)) + vec3(1.0)) * 0.7;\r\n\r\n\r\n    // overlay mix\r\n    float thres = 0.7;\r\n    if (lum < thres)\r\n        col = hue * lum / thres;\r\n    else\r\n        col = vec3(1.0) - (vec3(1.0 - (lum - thres)) * (vec3(1.0) - hue));\r\n\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"Ddc3zs",name:"Dive into geometry by Deep4",shader:"// https://www.shadertoy.com/view/Ddc3zs\r\nprecision mediump float;\r\n\r\nvec3 Field(vec3 Pos)\r\n{\r\n\tPos *= .1;\r\n\r\n\tfor (int i = 0; i < 5; ++i)\r\n\t{\r\n\t\tPos = abs(fract((Pos.yzx * mat3(.8, .6, .0, -.6, .8, .0, .0, .0, 1.)) + vec3(.123, .456, .789) * float(i)) - .5) * 2.;\r\n\t}\r\n\r\n\tPos *= Pos;\r\n\treturn sqrt(Pos + Pos.yzx) * .33;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    vec3 Direction = vec3((fragCoord.xy - iResolution.xy * .5) / iResolution.x, 1.);\r\n\tvec3 Position = vec3(.5, .8, iTime * 3.);\r\n\tvec3 Color;\r\n\r\n    // Sound (see shadertoy.com/view/Xds3Rr)\r\n    float fft_SnareDrum;\r\n\r\n    for (int n = 95; n<512; n += 100)\r\n    {\r\n        fft_SnareDrum += texelFetch(iChannel0, ivec2(n, 0), 0).x;\r\n    }\r\n\r\n    fft_SnareDrum /= 2.;\r\n\r\n\tfor (int i = 0; i < 50; ++i)\r\n\t{\r\n\t\tvec3 f2 = Field(Position + (fft_SnareDrum * .5));\r\n\t\tPosition += Direction * min(min(f2.x, f2.y), f2.z);\r\n\t\tColor += float(50 - i) / (f2 + .005);\r\n\t}\r\n\r\n\tColor = vec3(1. - 1. / (1. + Color * (-.06 * .0004)));\r\n\tColor *= Color * (fft_SnareDrum * 2.);\r\n\tfragColor = vec4(Color.r * 6., .0, fft_SnareDrum, 1.);\r\n}\r\n"},{id:"cljXWw",name:"Fork SoundEclip reverland 340 by reverland",shader:"// https://www.shadertoy.com/view/cljXWw\r\n// credit: https://www.shadertoy.com/view/4tGXzt\r\n\r\n#define BEATMOVE 1\r\n\r\nconst float FREQ_RANGE = 128.0;\r\nconst float PI = 3.1415;\r\nconst float RADIUS = 0.6;\r\nconst float BRIGHTNESS = 0.2;\r\nconst float SPEED = 0.1;\r\n\r\n//convert HSV to RGB\r\nvec3 hsv2rgb(vec3 c){\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nfloat luma(vec3 color) {\r\n  return dot(color, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\nfloat getfrequency(float x) {\r\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\r\n}\r\n\r\nfloat getfrequency_smooth(float x) {\r\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\r\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\r\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\r\n}\r\n\r\nfloat getfrequency_blend(float x) {\r\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\r\n}\r\n\r\nvec3 doHalo(vec2 fragment, float radius) {\r\n\tfloat dist = length(fragment);\r\n\tfloat ring = 1.0 / abs(dist - radius);\r\n\r\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\r\n\r\n\tvec3 col = vec3(0.);\r\n\r\n\tfloat angle = atan(fragment.x, fragment.y);\r\n\tcol += hsv2rgb( vec3( ( angle  + iTime ) / (PI * 2.), cos(iTime)*0.1+0.5, cos(iTime) * 0.1 +0.5 ) ) * ring * b;\r\n\r\n\tfloat frequency = max(getfrequency_blend(abs(angle / (4. * PI))), 0.2);\r\n\tcol *= frequency;\r\n\r\n\t// Black halo\r\n\tcol *= smoothstep(radius * 0.5, radius, dist);\r\n\r\n\treturn col;\r\n}\r\n\r\nvec3 doLine(vec2 fragment, float radius, float x, float p) {\r\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\r\n\r\n\tfloat freq = abs(fragment.x * p);\r\n\r\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\r\n\tcol = col * smoothstep(radius, radius * 1.0, abs(fragment.x));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 fragPos = fragCoord / iResolution.xy;\r\n\tfragPos = (fragPos - 0.5) * 2.0;\r\n    fragPos.x *= iResolution.x / iResolution.y;\r\n\r\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\r\n\tcolor += doHalo(fragPos, RADIUS);\r\n    color += doHalo(fragPos, 0.2);\r\n\r\n    float c = cos(iTime * SPEED);\r\n    float s = sin(iTime * SPEED);\r\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\r\n\t//color += doLine(rot, RADIUS, rot.x, 0.12);\r\n\r\n\tcolor += max(luma(color) - 1.0, 0.0);\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"3s23RV",name:"Cavitation by EnigmaCurry",shader:"// https://www.shadertoy.com/view/3s23R\r\n// Cavitation - EnigmaCurry\r\n// Adapted from Bubble Rings by tdhooper - https://www.shadertoy.com/view/WdB3Dw\r\n\r\n// --------------------------------------------------------\r\n// HG_SDF\r\n// https://www.shadertoy.com/view/Xs3GRB\r\n// --------------------------------------------------------\r\n\r\n#define PI 3.14159265359\r\n\r\nvoid pR(inout vec2 p, float a, float c, float t) {\r\n    p = cos(a+p.y+c*t) + sin(a+p.y)*p*vec2(acos(p.x/p.x), p.y);\r\n}\r\n\r\nfloat smax(float a, float b, float r) {\r\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\r\n    return min(-r, max (a, b)) + length(u);\r\n}\r\n\r\n\r\n// --------------------------------------------------------\r\n// Spectrum colour palette\r\n// IQ https://www.shadertoy.com/view/ll2GD3\r\n// --------------------------------------------------------\r\n\r\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\r\n    return a + b*cos( 16.28318*(c*t+d) );\r\n}\r\n\r\nvec3 spectrum(float n) {\r\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\r\n}\r\n\r\n\r\n// --------------------------------------------------------\r\n// Main SDF\r\n// https://www.shadertoy.com/view/wsfGDS\r\n// --------------------------------------------------------\r\n\r\nvec4 inverseStereographic(vec3 p, out float k) {\r\n    k = 2.0/(1.0+dot(p,p));\r\n    return vec4(k*p,k-1.0);\r\n}\r\n\r\nfloat fTorus(vec4 p4) {\r\n    float d1 = length(p4.xy) / length(p4.zw) - 2.;\r\n    float d2 = length(p4.zw) / length(p4.xy) - 22.;\r\n    float d = d1 < 0.9 ? -d1 : d2;\r\n    d /= PI;\r\n    return d;\r\n}\r\n\r\nfloat fixDistance(float d, float k) {\r\n    float sn = sign(d);\r\n    d = abs(d);\r\n    d = d / k * 1.82;\r\n    d += 1.;\r\n    d = pow(d, .5);\r\n    d -= 1.;\r\n    d *= 5./3.;\r\n    d *= sn;\r\n    return d;\r\n}\r\n\r\nfloat time;\r\n\r\nfloat map(vec3 p) {\r\n    float fft = clamp(texture( iChannel0, vec2(0.1,0.1) ).x * 12., 0.2, 99999.);\r\n    float k;\r\n    vec4 p4 = inverseStereographic(p,k);\r\n    float c = sin(iTime/22.) * fft;\r\n    float t = mod(iTime / 12., 333.);\r\n    pR(p4.zy, time * -PI / 2., c, t);\r\n    pR(p4.xw, time * -PI / 2., c, t);\r\n\r\n    // A thick walled clifford torus intersected with a sphere\r\n\r\n    float d = fTorus(p4);\r\n    d = abs(d);\r\n    d -= .2;\r\n    d = fixDistance(d, k);\r\n    d = smax(d, length(p) - 1.85, .2);\r\n\r\n    return d;\r\n}\r\n\r\n\r\n// --------------------------------------------------------\r\n// Rendering\r\n// --------------------------------------------------------\r\n\r\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\r\n    vec3 ww = normalize(ta - ro);\r\n    vec3 uu = normalize(cross(ww,up));\r\n    vec3 vv = normalize(cross(uu,ww));\r\n    return mat3(uu, vv, ww);\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\r\n    time = mod(iTime / 1., 10.);\r\n\r\n    vec3 camPos = vec3(1.8, 5.5, -5.5) * 1.75;\r\n    vec3 camTar = vec3(.0,0.,.0);\r\n    vec3 camUp = vec3(-18,0,-5.5);\r\n    mat3 camMat = calcLookAtMatrix(camPos, camTar, camUp);\r\n    float focalLength = 5.;\r\n    vec2 p = (-iResolution.xy + 2. * gl_FragCoord.xy) / iResolution.y;\r\n\r\n    vec3 rayDirection = normalize(camMat * vec3(p, focalLength));\r\n    vec3 rayPosition = camPos;\r\n    float rayLength = 12.;\r\n\r\n    float distance = 0.;\r\n    vec3 color = vec3(0);\r\n\r\n    vec3 c;\r\n\r\n    // Keep iteration count too low to pass through entire model,\r\n    // giving the effect of fogged glass\r\n    const float ITER = 82.;\r\n    const float FUDGE_FACTORR = .8;\r\n    const float INTERSECTION_PRECISION = .001;\r\n    const float MAX_DIST = 20.;\r\n\r\n    for (float i = 0.; i < ITER; i++) {\r\n\r\n        // Step a little slower so we can accumilate glow\r\n        rayLength += max(INTERSECTION_PRECISION, abs(distance) * FUDGE_FACTORR);\r\n        rayPosition = camPos + rayDirection * rayLength;\r\n        distance = map(rayPosition);\r\n\r\n        // Add a lot of light when we're really close to the surface\r\n        c = vec3(max(0., .01 - abs(distance)) * .5);\r\n        c *= vec3(1.4,2.1,1.7); // blue green tint\r\n\r\n        // Accumilate some purple glow for every step\r\n        c += vec3(.6,.25,.7) * FUDGE_FACTORR / 160.;\r\n        c *= smoothstep(20., 7., length(rayPosition));\r\n\r\n        // Fade out further away from the camera\r\n        float rl = smoothstep(MAX_DIST, .1, rayLength);\r\n        c *= rl;\r\n\r\n        // Vary colour as we move through space\r\n        c *= spectrum(rl * 6. - .6);\r\n\r\n        color += c;\r\n\r\n        if (rayLength > MAX_DIST) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Tonemapping and gamma\r\n    color = pow(color, vec3(1. / 1.8)) * 2.;\r\n    color = pow(color, vec3(2.)) * 3.;\r\n    color = pow(color, vec3(1. / 2.2));\r\n\r\n    fragColor = vec4(color, 1);\r\n}\r\n"},{id:"fllSD8",name:"Psychedelic Eye by mrange",shader:"// https://www.shadertoy.com/view/fllSD8\r\n// License CC0: Psychedelic eye\r\n//  Continuation of weekend experiment\r\n\r\n#define PI            3.141592654\r\n#define TAU           (2.0*PI)\r\n#define TIME          iTime\r\n#define TTIME         (TAU*TIME)\r\n#define RESOLUTION    iResolution\r\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\r\n#define PCOS(x)       (0.5 + 0.5*cos(x))\r\n#define DOT2(x)       dot(x, x)\r\n#define BPERIOD       5.6\r\n#define MPERIOD       7.2\r\n#define FLIP          10.0\r\n\r\nconst vec2 iris_center = vec2(0.0, 0.28);\r\n\r\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\r\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\nvec3 hsv2rgb(vec3 c) {\r\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\r\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\r\n}\r\n// Macro version of above to enable compile-time constants\r\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\r\n\r\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.3, 1.0));\r\nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0));\r\nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0));\r\nconst vec3  sky0_color    = HSV2RGB(vec3(0.05, 0.65, -0.25));\r\nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.25));\r\nconst vec3  light0_pos    = vec3(1.0, 5.0, 4.0);\r\nconst vec3  light1_pos    = vec3(3.0, -1.0, -8.0);\r\nconst vec3  light0_dir    = normalize(light0_pos);\r\nconst vec3  light1_dir    = normalize(light1_pos);\r\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\r\n\r\nint   g_eff = 0;\r\n\r\nfloat g_hf;\r\n\r\nvec2 g_vx = vec2(0.0);\r\nvec2 g_vy = vec2(0.0);\r\n\r\nvec2 g_wx = vec2(0.0);\r\nvec2 g_wy = vec2(0.0);\r\n\r\n\r\nvec4 alphaBlend(vec4 back, vec4 front) {\r\n  float w = front.w + back.w*(1.0-front.w);\r\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\r\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\r\n}\r\n\r\nvec3 alphaBlend(vec3 back, vec4 front) {\r\n  return mix(back, front.xyz, front.w);\r\n}\r\n\r\nvec3 postProcess(vec3 col, vec2 q) {\r\n  col = clamp(col, 0.0, 1.0);\r\n  col = pow(col, vec3(1.0/2.2));\r\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\r\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\r\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\r\n  return col;\r\n}\r\n\r\nfloat circle(vec2 p, float r) {\r\n  return length(p) - r;\r\n}\r\n\r\n// Based on: https://iquilezles.org/articles/distfunctions2d\r\nfloat vesica(vec2 p, vec2 sz) {\r\n  if (sz.x < sz.y) {\r\n    sz = sz.yx;\r\n  } else {\r\n    p  = p.yx;\r\n  }\r\n  vec2 sz2 = sz*sz;\r\n  float d  = (sz2.x-sz2.y)/(2.0*sz.y);\r\n  float r  = sqrt(sz2.x+d*d);\r\n  float b  = sz.x;\r\n  p = abs(p);\r\n  return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\r\n                           : length(p-vec2(-d,0.0))-r;\r\n}\r\n\r\n// IQ's box\r\nfloat box(vec2 p, vec2 b) {\r\n  vec2 d = abs(p)-b;\r\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nfloat eye_shape(vec2 p) {\r\n  float a  = mix(0.0, 1.0, smoothstep(0.995, 1.0, cos(TTIME/BPERIOD)));\r\n  const float w = 1.14;\r\n  float h = mix(0.48, 0.05, a);\r\n  float d0 =  vesica(p, vec2(w, h));\r\n  return d0;\r\n}\r\n\r\n// IQ's ray sphere intersect: https://iquilezles.org/articles/intersectors\r\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\r\n  vec3 oc = ro - sph.xyz;\r\n  float b = dot( oc, rd );\r\n  float c = dot( oc, oc ) - sph.w*sph.w;\r\n  float h = b*b - c;\r\n  if (h < 0.0) return vec2(-1.0);\r\n  h = sqrt(h);\r\n  return vec2(-b - h, -b + h);\r\n}\r\n\r\n// IQ's ray plane intersect: https://iquilezles.org/articles/intersectors\r\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\r\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\r\n}\r\n\r\nfloat tanh_approx(float x) {\r\n//  return tanh(x);\r\n  float x2 = x*x;\r\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\r\n}\r\n\r\nvec2 toPolar(vec2 p) {\r\n  return vec2(length(p), atan(p.y, p.x));\r\n}\r\n\r\nvec2 toRect(vec2 p) {\r\n  return p.x*vec2(cos(p.y), sin(p.y));\r\n}\r\n\r\nvec3 toSpherical(vec3 p) {\r\n  float r   = length(p);\r\n  float t   = acos(p.z/r);\r\n  float ph  = atan(p.y, p.x);\r\n  return vec3(r, t, ph);\r\n}\r\n\r\nvec3 toRect(vec3 p) {\r\n  return p.x*vec3(cos(p.z)*sin(p.y), sin(p.z)*sin(p.y), cos(p.y));\r\n}\r\n\r\n// https://mercury.sexy/hg_sdf/\r\nfloat mod1(inout float p, float size) {\r\n  float halfsize = size*0.5;\r\n  float c = floor((p + halfsize)/size);\r\n  p = mod(p + halfsize, size) - halfsize;\r\n  return c;\r\n}\r\n\r\n// https://mercury.sexy/hg_sdf/\r\nvec2 mod2(inout vec2 p, vec2 size) {\r\n  vec2 c = floor((p + size*0.5)/size);\r\n  p = mod(p + size*0.5,size) - size*0.5;\r\n  return c;\r\n}\r\n\r\n// https://iquilezles.org/articles/smin\r\nfloat pmin(float a, float b, float k) {\r\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n  return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\nfloat pmax(float a, float b, float k) {\r\n  return -pmin(-a, -b, k);\r\n}\r\n\r\nfloat pabs(float a, float k) {\r\n  return -pmin(-a, a, k);\r\n}\r\n\r\nfloat noise(vec2 p) {\r\n  float a = sin(p.x);\r\n  float b = sin(p.y);\r\n  float c = 0.5 + 0.5*cos(p.x + p.y);\r\n  float d = mix(a, b, c);\r\n  return d;\r\n}\r\n\r\n// https://iquilezles.org/articles/fbm\r\nfloat fbm(vec2 p, float aa) {\r\n  const mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\r\n\r\n  float f = 0.0;\r\n  float a = 1.0;\r\n  float s = 0.0;\r\n  float m = 2.0;\r\n  for (int x = 0; x < 4; ++x) {\r\n    f += a*noise(p);\r\n    p = frot*p*m;\r\n    m += 0.01;\r\n    s += a;\r\n    a *= aa;\r\n  }\r\n  return f/s;\r\n}\r\n\r\n// https://iquilezles.org/articles/warp\r\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\r\n  const float r  = 0.5;\r\n  const float rr = 0.25;\r\n  float l2 = length(p);\r\n  float f  = 1.0;\r\n\r\n  if (g_eff==0) {\r\n//    f = smoothstep(r, r+rr, l2);\r\n    f = smoothstep(-0.1, 0.15, eye_shape(p));\r\n    p.y += TIME*0.125;\r\n    p.x = pabs(p.x, 0.1);\r\n  } else if (g_eff==1) {\r\n    const float z = 0.75;\r\n    f = smoothstep(-0.05, 0.1, eye_shape(p.yx/z)*z);\r\n    f = smoothstep(r, r+rr, l2);\r\n    p = -p.yx;\r\n    p = toPolar(p);\r\n//    f = smoothstep(r, r+rr, l2);\r\n    p.y -= -0.125*TIME+p.x*1.25;\r\n  }\r\n\r\n  g_hf = f;\r\n  vec2 pp = p;\r\n\r\n  vec2 vx = g_vx;\r\n  vec2 vy = g_vy;\r\n\r\n  vec2 wx = g_wx;\r\n  vec2 wy = g_wy;\r\n\r\n\r\n  //float aa = mix(0.95, 0.25, tanh_approx(pp.x));\r\n  float aa = 0.5;\r\n\r\n  v = vec2(fbm(p + vx, aa), fbm(p + vy, aa))*f;\r\n  w = vec2(fbm(p + 3.0*v + wx, aa), fbm(p + 3.0*v + wy, aa))*f;\r\n\r\n  return -tanh_approx(fbm(p + 2.25*w, aa)*f);\r\n}\r\n\r\nvec3 normal(vec2 p) {\r\n  vec2 v;\r\n  vec2 w;\r\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\r\n\r\n  vec3 n;\r\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\r\n  n.y = 2.0*e.x;\r\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\r\n\r\n  return normalize(n);\r\n}\r\n\r\nvoid compute_globals() {\r\n  vec2 vx = vec2(0.0, 0.0);\r\n  vec2 vy = vec2(3.2, 1.3);\r\n\r\n  vec2 wx = vec2(1.7, 9.2);\r\n  vec2 wy = vec2(8.3, 2.8);\r\n\r\n  vx *= ROT(TTIME/1000.0);\r\n  vy *= ROT(TTIME/900.0);\r\n\r\n  wx *= ROT(TTIME/800.0);\r\n  wy *= ROT(TTIME/700.0);\r\n\r\n  g_vx = vx;\r\n  g_vy = vy;\r\n\r\n  g_wx = wx;\r\n  g_wy = wy;\r\n}\r\n\r\nvec3 iris(vec2 p) {\r\n  const vec3 up  = vec3(0.0, 1.0, 0.0);\r\n  const vec3 lp1 = 1.0*vec3(1.0, 1.25, 1.0);\r\n  const vec3 lp2 = 1.0*vec3(-1.0, 2.5, 1.0);\r\n\r\n  vec3 ro = vec3(0.0, 10.0, 0.0);\r\n  vec3 pp = vec3(p.x, 0.0, p.y);\r\n\r\n  vec2 v;\r\n  vec2 w;\r\n\r\n  float h  = warp(p, v, w);\r\n  float hf = g_hf;\r\n  vec3  n  = normal(p);\r\n\r\n  vec3 lcol1 = hsv2rgb(vec3(0.7, 0.5, 1.0));\r\n  vec3 lcol2 = hsv2rgb(vec3(0.4, 0.5, 1.0));\r\n  vec3 po  = vec3(p.x, 0.0, p.y);\r\n  vec3 rd  = normalize(po - ro);\r\n\r\n  vec3 ld1 = normalize(lp1 - po);\r\n  vec3 ld2 = normalize(lp2 - po);\r\n\r\n  float diff1 = max(dot(n, ld1), 0.0);\r\n  float diff2 = max(dot(n, ld2), 0.0);\r\n\r\n  vec3  ref   = reflect(rd, n);\r\n  float ref1  = max(dot(ref, ld1), 0.0);\r\n  float ref2  = max(dot(ref, ld2), 0.0);\r\n\r\n  const vec3 col1 = vec3(0.1, 0.7, 0.8).xzy;\r\n  const vec3 col2 = vec3(0.7, 0.3, 0.5).zyx;\r\n\r\n  float a = length(p);\r\n  vec3 col = vec3(0.0);\r\n//  col += hsv2rgb(vec3(fract(0.3*TIME+0.25*a+0.5*v.x), 0.85, abs(tanh_approx(v.y))));\r\n//  col += hsv2rgb(vec3(fract(-0.5*TIME+0.25*a+0.125*w.x), 0.85, abs(tanh_approx(w.y))));\r\n  col += hsv2rgb(vec3(fract(-0.1*TIME+0.125*a+0.5*v.x+0.125*w.x), abs(0.5+tanh_approx(v.y*w.y)), tanh_approx(0.1+abs(v.y-w.y))));\r\n//  col += (length(v)*col1 + length(w)*col2*1.0);\r\n//  col += diff1;\r\n//  col += diff2;\r\n//  col *= 0.0;\r\n  col += 0.5*lcol1*pow(ref1, 20.0);\r\n  col += 0.5*lcol2*pow(ref2, 10.0);\r\n  col *= hf;\r\n\r\n//  col = n;\r\n  return col;\r\n}\r\n\r\nvec3 eye_complete(vec2 p) {\r\n  const float iris_outer = 0.622;\r\n  const float iris_inner = 0.285;\r\n\r\n\r\n  float t0 = abs(0.9*p.x);\r\n  t0 *= t0;\r\n  t0 *= t0;\r\n  t0 *= t0;\r\n  t0 = clamp(t0, 0.0, 1.0);\r\n  float dt0 = mix(0.0125, -0.0025, t0);\r\n\r\n  vec2 p0 = p;\r\n  float d0 = eye_shape(p);\r\n  float d5 = d0;\r\n\r\n  vec2 p1 = p;\r\n  p1 -= iris_center;\r\n  float d1 = circle(p1, iris_outer);\r\n  d1 = max(d1,d0+dt0);\r\n  float d6 = d1;\r\n\r\n  vec2 p2 = p;\r\n  p2 -= vec2(0.155, 0.35);\r\n  float d2 = circle(p2, 0.065);\r\n\r\n  vec2 p3 = p;\r\n  p3 -= iris_center;\r\n  p3 = toPolar(p3);\r\n  float n3 = mod1(p3.x, 0.05);\r\n  float d3 = abs(p3.x)-0.0125*(1.0-1.0*length(p1));\r\n\r\n  vec2 p4 = p;\r\n  p4 -= iris_center;\r\n  float d4 = circle(p4, iris_inner);\r\n\r\n  d3 = max(d3,-d4);\r\n\r\n  d1 = pmax(d1,-d2, 0.0125);\r\n  d1 = max(d1,-d3);\r\n\r\n  d0 = abs(d0)-dt0;\r\n\r\n\r\n  float d = d0;\r\n  d = pmin(d, d1, 0.0125);\r\n  return vec3(d, d6, d5);\r\n}\r\n\r\nvec3 df(vec2 p) {\r\n  return eye_complete(p);\r\n}\r\n\r\nvec3 render_background(vec3 ro, vec3 rd, vec3 nrd) {\r\n  rd.xy *= ROT(-PI/2.0+0.6);\r\n  vec3 srd = toSpherical(rd.xzy);\r\n  srd.z += 0.025*TIME;\r\n  vec2 pg  = srd.yz;\r\n  float f  = sin(pg.x);\r\n  float lf2= ceil(log(f)/log(2.0)-0.505);\r\n  float mf = pow(2.0, lf2);\r\n\r\n  float aa = 0.005;\r\n  const float count = 20.0;\r\n  const vec2 sz = vec2(2.0*PI/count);\r\n  vec2 ng = mod2(pg, vec2(mf, 1.0)*sz);\r\n\r\n  float dg = min(abs(pg.y)*f, abs(pg.x))-aa*0.0;\r\n  vec3 lines = grid_color*smoothstep(-aa, aa, -dg)*f*f;\r\n\r\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\r\n\r\n  vec2 pi = raySphere(ro, rd, planet_sph);\r\n\r\n  float lf1 = 1.0;\r\n  if (pi.x > 0.0) {\r\n    vec3 ppos = ro+rd*pi.x;\r\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\r\n    sky *= mix(0.5, 1.0, t);\r\n    lf1 = t;\r\n  } else {\r\n    sky += lines;\r\n  }\r\n\r\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color;\r\n  sky += pow(max(dot(rd, light0_dir), 0.0), 80.0)*light1_color*0.1;\r\n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color;\r\n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 50.0)*light0_color*0.1;\r\n\r\n\r\n  return sky;\r\n}\r\n\r\nvec4 render_iris(vec3 ro, vec3 rd, vec3 nrd) {\r\n  vec4 plane = vec4(normalize(vec3(1.0, 0.165-0.00, 0.0)), -0.944);\r\n  float aa = TTIME/MPERIOD;\r\n  float bb = smoothstep(-0.125, 0.125, sin(aa));\r\n  plane.xy *= ROT(0.075*bb);\r\n  plane.xz *= ROT(0.25*bb*sign(-sin(PI/4.0+0.5*aa)));\r\n  vec3 tnor  = plane.xyz;\r\n  const vec3 tup   = normalize(vec3(0.0, -1.0, 0.0));\r\n  float t = rayPlane(ro, rd, plane);\r\n  if (t <= 0.0) {\r\n    return vec4(0.0);\r\n  }\r\n\r\n  vec3 tpos = ro + t*rd;\r\n  tpos *= 4.0;\r\n  vec3 txx = normalize(cross(tnor, tup));\r\n  vec3 tyy = normalize(cross(tnor, txx));\r\n\r\n  vec2 tpos2 = vec2(dot(txx, tpos), dot(tyy, tpos));\r\n\r\n  vec3 col = iris(tpos2)*smoothstep(0.0, 1.0/75.0, t);\r\n\r\n  return vec4(col, smoothstep(0.0, 1.0/500.0, t));\r\n}\r\n\r\n\r\nvec4 render_body(vec2 p, vec3 dd, float z) {\r\n//  p -= iris_center;\r\n  float aa = 2.0/RESOLUTION.y;\r\n\r\n  vec3 ro = vec3(2.0, 0.0, 0.0);\r\n  vec3 la = vec3(0.0, 0.0, 0.0);\r\n\r\n  vec2 np   = p + vec2(4.0/RESOLUTION.y);\r\n\r\n  vec3 ww   = normalize(la - ro);\r\n  vec3 uu   = normalize(cross(vec3(0.0,1.0,0.0), ww));\r\n  vec3 vv   = normalize(cross(ww,uu));\r\n  float rdd = 2.0;\r\n  vec3 rd   = normalize(p.x*uu + p.y*vv + rdd*ww);\r\n  vec3 nrd  = normalize(np.x*uu + np.y*vv + rdd*ww);\r\n\r\n  vec4 sph  = vec4(vec3(0.0), 1.0);\r\n\r\n  vec2 si   = raySphere(ro, rd, sph);\r\n  if (si.x <= 0.0) {\r\n    return vec4(0.0);\r\n  }\r\n\r\n  float a = smoothstep(-aa, aa, -dd.z);\r\n  float b = smoothstep(0.0, mix(0.25, 1.0, float(p.y > 0.0))*mix(0.075, 0.0025, smoothstep(0.5, 1.0, abs(p.x))), -dd.z/z);\r\n  float c = smoothstep(-aa, aa, -dd.x);\r\n\r\n  vec3 pos  = ro + rd*si.x;\r\n\r\n  vec3 nor  = normalize(pos - sph.xyz);\r\n\r\n  float dif0= max(dot(nor, light0_dir), 0.0);\r\n  float dif1= max(dot(nor, light1_dir), 0.0);\r\n\r\n  vec3 ref  = reflect(rd, nor);\r\n  vec3 nref = reflect(nrd, nor);\r\n\r\n  vec3 refr = refract(rd, nor, 0.9);\r\n  vec3 nrefr= refract(nrd, nor, 0.9);\r\n\r\n  vec3 rbkg = render_background(pos, ref, nref);\r\n  vec4 riris= render_iris(pos, refr, nrefr);\r\n\r\n  vec3 col = vec3(0.0);\r\n  col += vec3(0.5);\r\n  col += dif1*0.5;\r\n  col += dif0*0.5;\r\n  if (fract((TIME/BPERIOD)/(2.0*FLIP)) > 0.5) {\r\n    rbkg = max(rbkg, 0.0);\r\n    rbkg = tanh(vec3(0.5, 1.0, 1.6)*rbkg).zxy;\r\n    col = mix(rbkg, rbkg*0.6, c);\r\n  } else {\r\n    col = alphaBlend(col, riris);\r\n    col += rbkg*mix(0.33, 1.0, riris.w);\r\n  }\r\n  col *= b;\r\n\r\n  return vec4(col, a);\r\n}\r\n\r\nfloat synth(vec2 p) {\r\n  const float z = 4.0;\r\n  const float st = 0.02;\r\n  float dob = box(p, vec2(1.4, 0.5));\r\n  p.x = abs(p.x);\r\n  p.x += st*20.0;\r\n  p /= z;\r\n  float n = mod1(p.x, st);\r\n  float dib = 1E6;\r\n  const int around = 1;\r\n  for (int i = -around; i <=around ;++i) {\r\n    float fft = texture(iChannel0, vec2((n+float(i))*st, 0.25)).x;\r\n    fft *= fft;\r\n    float dibb = box(p-vec2(st*float(i), 0.0), vec2(st*0.25, 0.05*fft+0.001));\r\n    dib = min(dib, dibb);\r\n  }\r\n\r\n  float dl = p.y;\r\n  dl = abs(dl) - 0.005;\r\n  dl = abs(dl) - 0.0025;\r\n  dl = abs(dl) - 0.00125;\r\n  float d = dib;\r\n  d = max(d, -dl);\r\n  //d = pmax(d, dob, 0.025);\r\n  return d*z;\r\n}\r\n\r\nvec3 effect(vec2 p) {\r\n  compute_globals();\r\n\r\n  float aa = 2.0/RESOLUTION.y;\r\n  const float m = 3.0;\r\n  const float z = 1.0;\r\n  p /= z;\r\n  vec2 pp  = p;\r\n\r\n  vec3 d   = df(pp)*z;\r\n\r\n  vec4 dcol = vec4(mix(vec3(0.9), vec3(0.0), smoothstep(-aa, aa, -d.x)) , smoothstep(-aa, aa, -d.z));\r\n  g_eff = 1;\r\n  vec4 scol = render_body(p, d, z);\r\n\r\n  vec3 col  = vec3(1.0);\r\n  g_eff = 0;\r\n  col = iris(p);\r\n\r\n  vec2 dp = p;\r\n  dp.y = -pabs(dp.y, 1.0);\r\n  dp -= vec2(0.0, -0.85);\r\n  dp = toPolar(dp);\r\n  dp.y += -0.2*(p.x);\r\n  dp = toRect(dp);\r\n  float dd = synth(dp);\r\n\r\n  vec4 ddcol = vec4(vec3(0.9), smoothstep(-aa, aa, -dd));\r\n\r\n  col = alphaBlend(col, dcol);\r\n  if (fract((TIME/BPERIOD)/FLIP) > 0.5) {\r\n    col = alphaBlend(col, scol);\r\n  }\r\n  col -= 0.5*exp(-75.0*max(dd, 0.0));\r\n  col = alphaBlend(col, ddcol);\r\n  return col;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n  vec2 q = fragCoord/iResolution.xy;\r\n  vec2 p = -1.0 + 2.0*q;\r\n  p.x *= RESOLUTION.x/RESOLUTION.y;\r\n  float aa = 2.0/RESOLUTION.y;\r\n\r\n  vec3 col = effect(p);\r\n  col = mix(vec3(0.0), col, smoothstep(0.5, 5.0, TIME));\r\n  col = postProcess(col, q);\r\n\r\n  fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"4stSRs",name:"Abstract Music by MatHack",shader:"// https://www.shadertoy.com/view/4stSRs\r\n//Fast Code, No Optim and clean ;) !\r\n\r\nfloat freqs[16];\r\n\r\n\r\nmat2 rotate2d(float angle){\r\n    return mat2(cos(angle),-sin(angle),\r\n                sin(angle),cos(angle));\r\n}\r\n\r\nfloat Hash2d(vec2 uv)\r\n{\r\n    float f = uv.x + uv.y * 47.0;\r\n    return fract(cos(f*3.333)*100003.9);\r\n}\r\nfloat Hash3d(vec3 uv)\r\n{\r\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\r\n    return fract(cos(f*3.333)*100003.9);\r\n}\r\nfloat mixP(float f0, float f1, float a)\r\n{\r\n    return mix(f0, f1, a*a*(3.0-2.0*a));\r\n}\r\nconst vec2 zeroOne = vec2(0.0, 1.0);\r\nfloat noise2d(vec2 uv)\r\n{\r\n    vec2 fr = fract(uv.xy);\r\n    vec2 fl = floor(uv.xy);\r\n    float h00 = Hash2d(fl);\r\n    float h10 = Hash2d(fl + zeroOne.yx);\r\n    float h01 = Hash2d(fl + zeroOne);\r\n    float h11 = Hash2d(fl + zeroOne.yy);\r\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\r\n}\r\nfloat noise(vec3 uv)\r\n{\r\n    vec3 fr = fract(uv.xyz);\r\n    vec3 fl = floor(uv.xyz);\r\n    float h000 = Hash3d(fl);\r\n    float h100 = Hash3d(fl + zeroOne.yxx);\r\n    float h010 = Hash3d(fl + zeroOne.xyx);\r\n    float h110 = Hash3d(fl + zeroOne.yyx);\r\n    float h001 = Hash3d(fl + zeroOne.xxy);\r\n    float h101 = Hash3d(fl + zeroOne.yxy);\r\n    float h011 = Hash3d(fl + zeroOne.xyy);\r\n    float h111 = Hash3d(fl + zeroOne.yyy);\r\n    return mixP(\r\n        mixP(mixP(h000, h100, fr.x), mixP(h010, h110, fr.x), fr.y),\r\n        mixP(mixP(h001, h101, fr.x), mixP(h011, h111, fr.x), fr.y)\r\n        , fr.z);\r\n}\r\n\r\n\r\nfloat PI=3.14159265;\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xx;\r\n    vec2 mouse = iMouse.xy / iResolution.xy;\r\n    vec2 uv2 =  -1.0 + 2.0 * uv;\r\n    uv2.y += 0.45;\r\n    //uv2.xy -= (mouse*4.0) - 2.0;\r\n    uv2.xy *= 4.5;\r\n\r\n    float time = iTime + (2.0*freqs[0]);\r\n\r\n    vec3 color = vec3(0.0);\r\n    vec3 color2 = vec3(0.0);\r\n\r\n    float nbPointX = 128.0;\r\n    float nbPointY = 128.0;\r\n    float resX =  (iResolution.x/nbPointX)/iResolution.x;\r\n    float resY =  (iResolution.y/nbPointY)/iResolution.y;\r\n\r\n\r\n    for( int i=0; i<16; i++ ){\r\n        freqs[i] = clamp( 1.9*pow( texture( iChannel0, vec2( 0.05 + 0.5*float(i)/16.0, 0.25 ) ).x, 3.0 ), 0.0, 1.0 );\r\n\r\n        float wave = sqrt(sin( (-(freqs[i]*noise2d(uv*10.0+ vec2(rotate2d(iTime)).xy ) )*3.1416) + ((uv2.x*uv2.x) + (uv2.y*uv2.y)) ) );\r\n\r\n\t\tvec2 v = rotate2d(iTime) * (uv * 2.0);\r\n\r\n \t\twave = smoothstep(0.8, 1.0, wave);\r\n        color2 += wave * (vec3(v.x, v.y, 1.7-v.y*v.x)*0.08) * freqs[i];\r\n\r\n        float endPixelX = (1.0/iResolution.x)*(wave*1.0);\r\n    \tfloat endPixelY = (1.0/iResolution.x)*(wave*1.0);\r\n        //Grid 1\r\n        if(mod(uv.x, resX) >= 0.0 && mod(uv.x, resX) <= endPixelX && mod(uv.y, resY) >= 0.0 && mod(uv.y, resY) <= endPixelY){\r\n            color2 += (vec3(v.x, v.y, 1.7-v.y*v.x)*0.08) ;\r\n        }\r\n\r\n\r\n        wave = smoothstep(0.99999, 1.0, wave);\r\n        color2 += wave * vec3(0.2) ;\r\n\r\n\r\n    }\r\n\r\n\r\n\tfragColor =  vec4(color2, 1.0);\r\n\r\n\r\n}\r\n"},{id:"MdfBz7",name:"Particles Dance by MatHack",shader:"// https://www.shadertoy.com/view/MdfBz7\r\n#define M_PI 3.1415926535897932384626433832795\r\n\r\nfloat random(vec2 co)\r\n{\r\n    highp float a = 12.9898;\r\n    highp float b = 78.233;\r\n    highp float c = 43758.5453;\r\n    highp float dt= dot(co.xy ,vec2(a,b));\r\n    highp float sn= mod(dt,3.14);\r\n    return fract(sin(sn) * c);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec4 outColor = vec4(0.0);\r\n\tfloat time = iTime * 0.1;\r\n    vec2 uvNorm = fragCoord.xy / iResolution.xy;\r\n\tvec2 uv = -0.5 + 1.0 * uvNorm;\r\n    uv /= vec2(iResolution.y / iResolution.x, 1.);\r\n\r\n    for(float i=0.0; i<600.0 ;i++){\r\n        float f1 = mod(i * 0.101213, 0.28);\r\n        float fft1 = texture(iChannel0, vec2(f1)).x;\r\n        float r = (fft1 / 2.);\r\n        float r1 = (fft1 / 8.) * random(vec2(uv));\r\n        float a = random(vec2(i))*(M_PI*2.);\r\n        vec2 center = vec2(cos(a), sin(a)) * r;\r\n        vec2 center2 = vec2(cos(a), sin(a)) * r1;\r\n        float dist = length(uv - center);\r\n        float dist2 = length(uv - center - center2);\r\n        float birghtness = 1./pow(0.001 + dist*350., 2.);\r\n        float birghtness2 = 1./pow(0.001 + dist2*500., 2.);\r\n        vec3 color = vec3(fft1-0.8, 0.3, fft1-0.2);\r\n        vec3 col = color * birghtness2 * fft1 * 2.;\r\n        col += color * birghtness * fft1 * 1.5;\r\n        //Out :D\r\n        outColor.rgb += col;\r\n    }\r\n\r\n\r\n    float grid = smoothstep((sin(length(uv.y-0.5)*(800.*length(uv.y+0.5))) * sin(length(uv.x+0.5)*(800.*length(uv.x-0.5)))), 0.0, 1.0);\r\n    outColor.rgb += (outColor.rgb * vec3(grid) * 0.6);\r\n\r\n\tfragColor = outColor;\r\n}\r\n"},{id:"WsGfDm",name:"osc + equalizer by chernomord",shader:"// https://www.shadertoy.com/view/WsGfDm\r\nconst float PI = 3.14;\r\n\r\nfloat plot(vec2 st, float pct){\r\n  return  smoothstep( pct-0.015, pct, st.y) -\r\n          smoothstep( pct, pct+0.015, st.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n\r\n    // Time varying pixel color\r\n    vec4 col = vec4( 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)), 1.);\r\n    vec4 top = texture(iChannel0, vec2(uv.x,1.));\r\n    float pl = plot(uv,top.r);\r\n    vec4 osc=vec4(vec3(pl),1.);\r\n\r\n\r\n    uv.y = abs(uv.y*2.-1.);\r\n    osc.b /= 10.*uv.y;\r\n    osc.g /=5.*uv.y;\r\n\r\n    // Output to screen\r\n    // compress X coord\r\n    float comp = floor(uv.x*80.)/80.;\r\n    float ultraComp = floor(uv.y*1.)/1.;\r\n\r\n    vec4 backgrCol = texture(iChannel0, vec2(ultraComp, 0.));\r\n    backgrCol.b = backgrCol.r / (uv.y*10.*uv.x)/2.;\r\n    backgrCol.g = backgrCol.r / (uv.y*6.*uv.x)/8.;\r\n    backgrCol.r = backgrCol.r / (uv.y*8.*uv.x)/1.;\r\n\r\n    // get texture from channel0\r\n    fragColor = texture(iChannel0, vec2(comp, 0.));\r\n    // colorize texture\r\n    fragColor.g = sin(fragColor.r*PI);\r\n    fragColor.b = abs(fragColor.r - 1.);\r\n\r\n    fragColor *= step(uv.y, fragColor.r);\r\n    fragColor = fragColor/1.2 + osc;\r\n    fragColor = fragColor + backgrCol/4.;\r\n}\r\n"},{id:"4dycW1",name:"Audio Spectrum by isak",shader:"// https://www.shadertoy.com/view/4dycW1\r\nfloat audio_power_f( in sampler2D channel, in float f, in float p) {\r\n    return texture( channel, vec2(f, p) ).x;\r\n}\r\n\r\n#define audio_power(x) audio_power_f(iChannel0, x, 0.0)\r\n#define audio_power_p(x,p) audio_power_f(iChannel0, x, p)\r\n#define pi 3.141592\r\n\r\nvec3 freq_bar(vec2 FC) {\r\n    vec2 uv = FC.xy / iResolution.xy;\r\n    float power = audio_power(uv.x);\r\n\r\n \treturn smoothstep(power, 0.0, uv.y)*vec3(power,0.5,0.5);\r\n}\r\n\r\nvec3 freq_circle(vec2 FC) {\r\n \tvec2 uv = FC.xy - 0.5*iResolution.xy;\r\n    uv *= 2.0/iResolution.y;\r\n\r\n    float angle = sign(uv.x)*atan(uv.x,uv.y);\r\n\r\n    float power, power_c;\r\n    power_c = 1.0 - audio_power_p(angle/pi, 1.0) ;\r\n    power = audio_power( angle/pi );\r\n\r\n    uv = 0.2*uv/(1.0- (1.7 + 0.3*power_c)*length(uv));\r\n\r\n\r\n\r\n    float ref_size = 0.2;\r\n    vec3 color;\r\n    float shade;\r\n    shade = smoothstep(0.2,power*0.8 + 0.25, length(uv));\r\n    shade *= smoothstep(0.0, 0.2+ 0.5*power, (1.0 - length(uv)));\r\n\r\n    color = vec3(power*power_c, power*0.5 + 0.5, power_c + 0.4);\r\n    return shade*color;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 FC ) {\r\n\r\n\r\n    fragColor = vec4(freq_bar(FC), 1.0);\r\n    fragColor = vec4(freq_circle(FC), 1.0);\r\n\r\n}\r\n"},{id:"XsyXzw",name:"Dancing Dots by s23b",shader:"// https://www.shadertoy.com/view/XsyXz\r\n#define PI 3.14159265359\r\n\r\nvec3 hsv2rgb (in vec3 hsv) {\r\n    return hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 0.6667, 0.3333))) - 1.0));\r\n}\r\n\r\nfloat hash(vec3 uv) {\r\n    return fract(sin(dot(uv, vec3(7.13, 157.09, 113.57))) * 48543.5453);\r\n}\r\n\r\n// better distance function thanks to Shane\r\nfloat map(vec3 p) {\r\n    float radius = texture(iChannel0, vec2(hash(floor(p)), .25)).x * .99 + .01;\r\n    return length(fract(p) - .5) - .25 * radius;\r\n}\r\n\r\n// raymarching function\r\nfloat trace(vec3 o, vec3 r) {\r\n\r\n    float t = 0.;\r\n\r\n    for (int i = 0; i < 32; ++i) { // Low iterations for blur.\r\n        float d = map(o + r * t);\r\n        t += d * .9; // Ray shortening to blur a bit more.\r\n    }\r\n\r\n    return t;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n\r\n    // ray\r\n    vec3 r = normalize(vec3(uv, 2.));\r\n    // origin\r\n    vec3 o = vec3(-3, iTime, -1);\r\n\r\n    // rotate origin and ray\r\n    float a = -iTime * .5;\r\n    mat2 rot = mat2(cos(a), -sin(a), sin(a), cos(a));\r\n    o.xz *= rot;\r\n    r.xy *= rot;\r\n    r.xz *= rot;\r\n\r\n    // march\r\n    float f = trace(o, r);\r\n\r\n    // calculate color from angle on xz plane\r\n    vec3 p = o + f * r;\r\n    float angel = atan(p.x, p.z) / PI / 2.;\r\n    vec3 c = hsv2rgb(vec3(angel, 1., 1.));\r\n\r\n    // add with fog\r\n\tfragColor = vec4(c / (1. + f * f * .1),1.0);\r\n}\r\n"},{id:"7ltyR4",name:"Playing around with spirals by mati_software",shader:"// https://www.shadertoy.com/view/7ltyR4\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 spiralCenter = iResolution.xy / 2.0;\r\n    float abstandSpiralCenter = distance(fragCoord, spiralCenter);\r\n    float abstandSpiralCenterNorm = abstandSpiralCenter / length(iResolution.xy / 2.0);\r\n\r\n    float winkel = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .17)   + iTime * .61;\r\n    vec2 vergleichspunkt = spiralCenter + abstandSpiralCenter * vec2(sin(winkel), cos(winkel));\r\n    float abstandVergleichspunkt = distance(fragCoord, vergleichspunkt);\r\n    float abstandVergleichspunktNorm = abstandVergleichspunkt / length(iResolution.xy / 2.0);\r\n    float subtrahend = abstandVergleichspunktNorm / abstandSpiralCenterNorm;\r\n\r\n    float winkel2 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .23 + .1)   + iTime * .31;\r\n    vec2 vergleichspunkt2 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel2), cos(winkel2));\r\n    float abstandVergleichspunkt2 = distance(fragCoord, vergleichspunkt2);\r\n    float abstandVergleichspunktNorm2 = abstandVergleichspunkt2 / length(iResolution.xy / 2.0);\r\n    float subtrahend2 = abstandVergleichspunktNorm2 / abstandSpiralCenterNorm;\r\n\r\n    float winkel3 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .41 + .62)   + iTime * .47;\r\n    vec2 vergleichspunkt3 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel3), cos(winkel3));\r\n    float abstandVergleichspunkt3 = distance(fragCoord, vergleichspunkt3);\r\n    float abstandVergleichspunktNorm3 = abstandVergleichspunkt3 / length(iResolution.xy / 2.0);\r\n    float subtrahend3 = abstandVergleichspunktNorm3 / abstandSpiralCenterNorm;\r\n\r\n    float winkel4 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .38 + .17)   + iTime * .85;\r\n    vec2 vergleichspunkt4 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel4), cos(winkel4));\r\n    float abstandVergleichspunkt4 = distance(fragCoord, vergleichspunkt4);\r\n    float abstandVergleichspunktNorm4 = abstandVergleichspunkt4 / length(iResolution.xy / 2.0);\r\n    float subtrahend4 = abstandVergleichspunktNorm4 / abstandSpiralCenterNorm;\r\n\r\n    float winkel5 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .48 + .95)   + iTime * .57;\r\n    vec2 vergleichspunkt5 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel5), cos(winkel5));\r\n    float abstandVergleichspunkt5 = distance(fragCoord, vergleichspunkt5);\r\n    float abstandVergleichspunktNorm5 = abstandVergleichspunkt5 / length(iResolution.xy / 2.0);\r\n    float subtrahend5 = abstandVergleichspunktNorm5 / abstandSpiralCenterNorm;\r\n\r\n    float winkel6 = sqrt(abstandSpiralCenterNorm) * 10.0 * sin(iTime * .29 + .27)   + iTime * .54;\r\n    vec2 vergleichspunkt6 = spiralCenter + abstandSpiralCenter * vec2(sin(winkel6), cos(winkel6));\r\n    float abstandVergleichspunkt6 = distance(fragCoord, vergleichspunkt6);\r\n    float abstandVergleichspunktNorm6 = abstandVergleichspunkt6 / length(iResolution.xy / 2.0);\r\n    float subtrahend6 = abstandVergleichspunktNorm6 / abstandSpiralCenterNorm;\r\n\r\n    vec3 fragColor1 = vec3(2.0 - abstandVergleichspunktNorm - abstandVergleichspunktNorm4 - abstandVergleichspunktNorm6, 2.0 - abstandVergleichspunktNorm2 - abstandVergleichspunktNorm5 - abstandVergleichspunktNorm4, 2.0 - abstandVergleichspunktNorm3 - abstandVergleichspunktNorm6 - abstandVergleichspunktNorm5);\r\n    vec3 fragColor2 = vec3(4.0 - subtrahend - subtrahend4 - subtrahend6, 4.0 - subtrahend2 - subtrahend5 - subtrahend4, 4.0 - subtrahend3 - subtrahend6 - subtrahend5);\r\n    float faktor = texture(iChannel0,vec2(0,0)).x;\r\n    faktor = pow(faktor, 5.0);\r\n\r\n    // Output to screen\r\n    fragColor = vec4(mix(fragColor1, fragColor2, faktor), 1.0);\r\n}\r\n"},{id:"ls3BDH",name:"SoundEclipse rpm by sclavel",shader:"// https://www.shadertoy.com/view/ls3BDH\r\n// credit: https://www.shadertoy.com/view/4tGXzt\r\n\r\n#define BEATMOVE 1\r\n\r\nconst float FREQ_RANGE = 64.0;\r\nconst float PI = 3.1415;\r\nconst float RADIUS = 0.6;\r\nconst float BRIGHTNESS = 0.2;\r\nconst float SPEED = 0.5;\r\n\r\n//convert HSV to RGB\r\nvec3 hsv2rgb(vec3 c){\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nfloat luma(vec3 color) {\r\n  return dot(color, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\nfloat getfrequency(float x) {\r\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\r\n}\r\n\r\nfloat getfrequency_smooth(float x) {\r\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\r\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\r\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\r\n}\r\n\r\nfloat getfrequency_blend(float x) {\r\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\r\n}\r\n\r\nvec3 doHalo(vec2 fragment, float radius) {\r\n\tfloat dist = length(fragment);\r\n\tfloat ring = 1.0 / abs(dist - radius);\r\n\r\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\r\n\r\n\tvec3 col = vec3(0.0);\r\n\r\n\tfloat angle = atan(fragment.x, fragment.y);\r\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\r\n\r\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\r\n\tcol *= frequency;\r\n\r\n\t// Black halo\r\n\tcol *= smoothstep(radius * 0.5, radius, dist);\r\n\r\n\treturn col;\r\n}\r\n\r\nvec3 doLine(vec2 fragment, float radius, float x) {\r\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\r\n\r\n\tfloat freq = abs(fragment.x * 0.5);\r\n\r\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\r\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 fragPos = fragCoord / iResolution.xy;\r\n\tfragPos = (fragPos - 0.5) * 2.0;\r\n    fragPos.x *= iResolution.x / iResolution.y;\r\n\r\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\r\n\tcolor += doHalo(fragPos, RADIUS);\r\n\r\n    float c = cos(iTime * SPEED);\r\n    float s = sin(iTime * SPEED);\r\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\r\n\tcolor += doLine(rot, RADIUS, rot.x);\r\n\r\n\tcolor += max(luma(color) - 1.0, 0.0);\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"llB3W1",name:"Fractal Audio 01 by relampago2048",shader:"// https://www.shadertoy.com/view/llB3W1\r\nconst int iters = 150;\r\n\r\nint fractal(vec2 p, vec2 point) {\r\n\tvec2 so = (-1.0 + 2.0 * point) * 0.4;\r\n\tvec2 seed = vec2(0.098386255 + so.x, 0.6387662 + so.y);\r\n\r\n\tfor (int i = 0; i < iters; i++) {\r\n\r\n\t\tif (length(p) > 2.0) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t\tvec2 r = p;\r\n\t\tp = vec2(p.x * p.x - p.y * p.y, 2.0* p.x * p.y);\r\n\t\tp = vec2(p.x * r.x - p.y * r.y + seed.x, r.x * p.y + p.x * r.y + seed.y);\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\nvec3 color(int i) {\r\n\tfloat f = float(i)/float(iters) * 2.0;\r\n\tf=f*f*2.;\r\n\treturn vec3((sin(f*2.0)), (sin(f*3.0)), abs(sin(f*7.0)));\r\n}\r\n\r\n\r\nfloat sampleMusicA() {\r\n\treturn 0.5 * (\r\n\t\ttexture( iChannel0, vec2( 0.15, 0.25 ) ).x +\r\n\t\ttexture( iChannel0, vec2( 0.30, 0.25 ) ).x);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 mouse = vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\r\n\r\n    vec2 position = 3. * (-0.5 + fragCoord.xy / iResolution.xy );\r\n\tposition.x *= iResolution.x/iResolution.y;\r\n\r\n    vec2 iFC = vec2(iResolution.x-fragCoord.x,iResolution.y-fragCoord.y);\r\n    vec2 pos2 = 2. * (-0.5 + iFC.xy / iResolution.xy);\r\n    pos2.x*=iResolution.x/iResolution.y;\r\n\r\n    vec4 t3 = texture(iChannel0, vec2(length(position)/2.0,0.1) );\r\n    float pulse = 0.5+sampleMusicA()*1.8;\r\n\r\n    vec3 invFract = color(fractal(pos2,vec2(0.55+sin(iTime/3.+0.5)/2.0,pulse*.9)));\r\n\r\n    vec3 fract4 = color(fractal(position/1.6,vec2(0.6+cos(iTime/2.+0.5)/2.0,pulse*.8)));\r\n\r\n    vec3 c = color(fractal(position,vec2(0.5+sin(iTime/3.)/2.0,pulse)));\r\n\r\n    t3=abs(vec4(0.5,0.1,0.5,1.)-t3)*2.;\r\n\r\n    vec4 fract01 =  vec4( c , 1.0 );\r\n    vec4 salida;\r\n    salida = fract01 / t3 + fract01 * t3 + vec4(invFract,0.6) + vec4(fract4,0.3);\r\n\tfragColor = salida;\r\n}\r\n"},{id:"Ws2fWG",name:"Ocassional Spectators by Kali",shader:"// https://www.shadertoy.com/view/Ws2fWG\r\n\r\nfloat s;\r\nfloat t;\r\nvec3 ot;\r\nvec3 colo=vec3(0);\r\n\r\nmat2 rot(float a) {\r\n  float s=sin(a),c=cos(a);\r\n  return mat2(c,s,-s,c);\r\n}\r\n\r\nfloat de(vec3 p)\r\n{\r\n  float z=p.z;\r\n  ot=vec3(100);\r\n  colo=p;\r\n  float sc=1.;\r\n  p.xy*=rot(p.z*.1);\r\n  p=abs(15.-mod(p,30.))-1.;\r\n  for (int i=0; i<8; i++) {\r\n    p.xy*=rot(1.);\r\n    p.yz*=rot(t*10.);\r\n    ot=min(ot,abs(p.xyz));\r\n    p.xy=abs(p.xy+5.)-abs(p.xy-5.)-p.xy;\r\n    float s=1.5;\r\n    sc*=s;\r\n    p=p*s;\r\n  }\r\n  colo=exp(-15.*ot);\r\n  return (length(p)/sc-.5)*.8;\r\n\r\n}\r\n\r\n\r\nvec3 march(vec3 from, vec3 dir) {\r\n  float d, td=0.;\r\n  vec3 p, c=vec3(0.);\r\n  for (int i=0; i<50; i++)\r\n  {\r\n    p=from+dir*td;\r\n    d=de(p);\r\n    td+=max(.01,abs(d));\r\n    c+=colo*exp(-.05*td);\r\n  }\r\n  return (c*c*.02);\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n  t=floor(iChannelTime[0]*10.)*.001;\r\n  s=texture(iChannel0,vec2(.3)).r;\r\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\r\n  uv-=.5;\r\n  uv.x*=iResolution.x/iResolution.y;\r\n  if (fract(t*4.)<.5) t+=floor(length(uv)*4.-t*100.); else t+=floor(length(uv.y+uv.x)*1.5-t*100.);\r\n  vec3 dir=normalize(vec3(uv,.5+s*.3));\r\n  vec3 from=vec3(cos(t*.5)*2.,sin(t)*2.,t*200.);\r\n  from.xy*=rot(t*100.);\r\n  dir.yz*=rot(smoothstep(-.5,.5,sin(t*10.))*10.);\r\n  vec3 c = march(from,dir);\r\n  c=abs(cross(c,dir));\r\n  c.xy*=rot(t*50.+s*20.);\r\n  fragColor = vec4(c,1.)*min(1.,iChannelTime[0]*.2);\r\n}\r\n"},{id:"7tfyRl",name:"Audio Flight v2 (strobes) by byt3_m3chanic",shader:"// https://www.shadertoy.com/view/7tfyRl\r\n/**\r\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n\r\n    AudioFlight 🚀 v2 - music Boris Brejcha - Gravity\r\n    4/14/22 | @byt3_m3chanic\r\n\r\n    Path shader based around @Shane's stuff - he has a ton of amazing ones.\r\n    https://www.shadertoy.com/view/MlXSWX\r\n\r\n    Music EQ based around @blackle's domain rep tricks\r\n\r\n    Lots of fo\r\n*/\r\n\r\n\r\n#define R           iResolution\r\n#define T           iTime\r\n#define M           iMouse\r\n\r\n#define PI2         6.28318530718\r\n#define PI          3.14159265358\r\n\r\n#define MINDIST     .0001\r\n#define MAXDIST     125.\r\n\r\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\r\n\r\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\r\nfloat sampleFreq(float freq) {\r\n    return texture(iChannel0, vec2(freq, 0.1)).x;\r\n}\r\n\r\n//http://mercury.sexy/hg_sdf/\r\nfloat pMod(inout float p, float size) {\r\n\tfloat c = floor((p + size*0.5)/size);\r\n\tp = mod(p + size*0.5, size) - size*0.5;\r\n\treturn c;\r\n}\r\nvec2 pMod(inout vec2 p, float size) {\r\n\tvec2 c = floor((p + size*0.5)/size);\r\n\tp = mod(p + size*0.5, size) - size*0.5;\r\n\treturn c;\r\n}\r\nvec3 pMod(inout vec3 p, float size) {\r\n\tvec3 c = floor((p + size*0.5)/size);\r\n\tp = mod(p + size*0.5, size) - size*0.5;\r\n\treturn c;\r\n}\r\nfloat pModPolar(inout vec2 p, float repetitions) {\r\n    float angle = 2.*PI/repetitions;\r\n    float a = atan(p.y, p.x) + angle/2.,\r\n          r = length(p),\r\n          c = floor(a/angle);\r\n    a = mod(a,angle) - angle/2.;\r\n    p = vec2(cos(a), sin(a))*r;\r\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\r\n    return c;\r\n}\r\nfloat vmax(vec2 v) {\treturn max(v.x, v.y);\t\t\t\t\t\t}\r\nfloat vmax(vec3 v) {\treturn max(max(v.x, v.y), v.z);\t\t\t\t}\r\nfloat fBox(vec3 p, vec3 b) {\r\n\tvec3 d = abs(p) - b;\r\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\r\n}\r\nfloat fBox2(vec2 p, vec2 b) {\r\n\tvec2 d = abs(p) - b;\r\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\r\n}\r\n//@iq\r\nfloat sdCap( vec3 p, float h, float r ){\r\n  p.y -= clamp( p.y, 0.0, h );\r\n  return length( p ) - r;\r\n}\r\n// @Shane - https://www.shadertoy.com/view/MlXSWX\r\nvec2 path(in float z){\r\n    vec2 p1 =vec2(2.35*sin(z * .125)+2.38*cos(z * .25), 3.5*cos(z * .0945));\r\n    vec2 p2 =vec2(3.2*sin(z * .19), 4.31*sin(z * .125)-2.38*cos(z * .115));\r\n    return (p1 - p2)*.3;\r\n}\r\n\r\n// globals\r\nfloat time,tm,travelSpeed;\r\n\r\n// globals and stuff\r\nfloat glow,iqd,flight,beams,gcolor,objglow,offWobble,boxsize;\r\nfloat ga,sa,slp;\r\nvec3 g_hp,s_hp;\r\nmat2 r4,r5;\r\n\r\nconst vec3 cxz = vec3(3.15,4.75,3.);\r\nconst float scale = 3.0;\r\n\r\nvec2 fragtail(vec3 pos) {\r\n    float ss=1.15;\r\n    float r = 1e5;\r\n\r\n    for (int i = 0;i<2;i++) {\r\n        pos=abs(pos);\r\n        if ( pos.x- pos.y<0.) pos.yx = pos.xy;\r\n        if ( pos.x- pos.z<0.) pos.zx = pos.xz;\r\n        if ( pos.y- pos.z<0.) pos.zy = pos.yz;\r\n\r\n        pos.x=scale * pos.x-cxz.x*(scale-1.);\r\n        pos.y=scale * pos.y-cxz.y*(scale-1.);\r\n        pos.z=scale * pos.z;\r\n\r\n        if (pos.z>0.5*cxz.z*(scale-1.)) pos.z-=cxz.z*(scale-1.);\r\n\r\n        r = fBox2(pos.xy,vec2(5,1.5+.25*sin(pos.x*5.)))-.0015;\r\n        ss*=1./scale;\r\n    }\r\n\r\n    return vec2(r*ss,1.);\r\n}\r\n\r\n//@blackle domain rep https://www.shadertoy.com/view/Wl3fD2\r\nvec2 edge(vec2 p) {\r\n    vec2 p2 = abs(p);\r\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\r\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\r\n}\r\nfloat ths= 13.25;\r\n// scene map\r\nvec2 map (in vec3 p, float sg) {\r\n\r\n    vec2 res = vec2(100.,-1.);\r\n    float msize = 7.25;\r\n\r\n    // set path(s) vector(s)\r\n    vec2 tun = p.xy - path(p.z);\r\n    vec3 q = vec3(tun,p.z);\r\n    vec3 o = vec3(tun+vec2(0.,.0),p.z+travelSpeed+4.25);\r\n\r\n    vec3 s = q;\r\n\r\n    o.zx*=r5;\r\n    o.yz*=r4;\r\n    o = abs(o)-(offWobble*.25);\r\n    float obj = fBox(o,vec3(.15*offWobble))-.015;\r\n    if(obj<res.x ) {\r\n        res = vec2(obj,11.);\r\n        g_hp=o;\r\n    }\r\n\r\n    // mods and vectors\r\n    float pid = floor((q.z+(msize/2.))/msize);\r\n    float trackmod = mod(pid,18.);\r\n    float deg = trackmod<12. ? trackmod<6. ? 4. : 6. : 10.;\r\n    pModPolar(q.xy,deg);\r\n    pModPolar(s.xy,deg*.5);\r\n\r\n    vec3 r =s;\r\n    vec3 fs=s-vec3(2.85,0,0);\r\n    r = vec3(abs(r.x),abs(r.y),r.z);\r\n\r\n    // audio bards\r\n    fs.z*=2.;\r\n    vec2 center = floor(fs.xz) + .5;\r\n    vec2 neighbour = center + edge(fs.xz - center);\r\n\r\n    float chs = floor(center.y);\r\n    float bmod = mod(chs,16.);\r\n\r\n    float height = (sampleFreq(bmod*.0465));\r\n    height=smoothstep(.001,1.,height);\r\n\r\n    ga=height;\r\n    float ids = pMod(s.z,msize);\r\n    vec3 qid = pMod(q,msize);\r\n    float ld = mod(ids,6.);\r\n    float lq = mod(ids,2.);\r\n\r\n    iqd=qid.x;\r\n\r\n    float zprs= mod(chs, tm <8.? tm <4.? tm <4.? 2.: 2.: 5.: floor(height*1.45));\r\n\r\n    float d4a = length(r.xy-vec2(2.5,1.75))-.1;\r\n    float d4 =  length(r.xy-vec2(2.5,1.75))-.04+.027+.027*sin(r.z-time*4.5);\r\n    if(d4<res.x ) {\r\n        res = vec2(d4,12.);\r\n        g_hp=p;\r\n    }\r\n\r\n    // fractal\r\n    vec2 d1 = fragtail(q);\r\n    d1.x = max(d1.x,-d4a);\r\n\r\n    s.z=abs(s.z);\r\n    float blt = sdCap(s-vec3(2.45,-.58,2.725),1.16 ,.015);\r\n    if(lq<2.) d1.x = min(blt,d1.x);\r\n    if(d1.x<res.x) {\r\n        res = d1.xy;\r\n        g_hp = p;\r\n    }\r\n\r\n    float me =   fBox(fs-vec3(0,0,center.y),   vec3(.05,.150+height,.25));\r\n    float next = fBox(fs-vec3(0,0,neighbour.y),vec3(.05,.001+height,.25));\r\n    float dlt = min(me, next);\r\n    if(dlt<res.x) {\r\n        //float mid= zprs<4.? zprs<3.? zprs<2.? 3. : 4. : 4.  : 3.;\r\n        res = vec2(dlt,4.);//tm <8. ? mid : 4.);\r\n        g_hp = p;\r\n    }\r\n\r\n    if(sg==1.)beams += .0001/(.000003+d4*d4);\r\n    if(sg==1.&&lq<1.)flight += .00025/(.0000001+blt*blt);\r\n    if(sg==1.&&zprs<.1)glow += .00015/(.000002+dlt*dlt);\r\n    if(sg==1.&&tm<ths)objglow += .0005/(.0005+obj*obj);\r\n\r\n\r\n    return res;\r\n}\r\n\r\nvec2 marcher(vec3 ro, vec3 rd, int maxstep, float sg){\r\n    float d =  0.,\r\n          m = -1.;\r\n        for(int i=0;i<maxstep;i++){\r\n            vec3 p = ro + rd * d;\r\n            vec2 t = map(p,sg);\r\n            if(abs(t.x)<d*MINDIST||d>MAXDIST)break;\r\n            d += i<42? t.x*.35 : t.x;\r\n            m  = t.y;\r\n        }\r\n    return vec2(d,m);\r\n}\r\n\r\nvec3 normal(vec3 p, float t) {\r\n    float e = MINDIST*t;\r\n    vec2 h = vec2(1,-1)*.5773;\r\n    return normalize(\r\n        h.xyy*map( p + h.xyy*e,0.).x +\r\n        h.yyx*map( p + h.yyx*e,0.).x +\r\n        h.yxy*map( p + h.yxy*e,0.).x +\r\n        h.xxx*map( p + h.xxx*e,0.).x );\r\n}\r\n\r\n//iq of hsv2rgb\r\nvec3 hsv2rgb( in vec3 c ) {\r\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\r\n    return c.z * mix( vec3(1.0), rgb, c.y);\r\n}\r\n\r\nvoid mainImage( out vec4 O, in vec2 F ) {\r\n    // precal\r\n    time = iTime;\r\n    tm = mod(time*.3, 18.);\r\n    travelSpeed = (time * 5.);\r\n\r\n    offWobble = 1.5+1.15*sin(tm+time*.1);\r\n\r\n    r4 =r2(time);\r\n    r5 =r2(time);\r\n\r\n    // pixel screen coordinates\r\n    vec2 uv = (F.xy - R.xy*0.5)/max(R.x,R.y);\r\n    vec3 C = vec3(0.),\r\n         FC = vec3(.03);\r\n\r\n    float crop = clamp((-.05)+(T*.05),0.,.18);\r\n    if(uv.y<crop&&uv.y>-crop){\r\n    vec3 lp = vec3(0.,0.,0.-travelSpeed);\r\n    vec3 ro = vec3(0.,0,.15);\r\n\r\n    // mouse\r\n    float x = M.xy==vec2(0) || M.z<0. ? 0.:(M.y/R.y*1.-.5)*PI;\r\n    float y = M.xy==vec2(0) || M.z<0. ? 0.:-(M.x/R.x*2.-1.)*PI;\r\n\r\n    ro.zy*=r2(x);\r\n\r\n    ro +=lp;\r\n\r\n    lp.xy += path(lp.z);\r\n    ro.xy += path(ro.z);\r\n\r\n    // set camera\r\n    vec3 f=normalize(lp-ro),\r\n         r=normalize(cross(vec3(0,1,0),f)),\r\n         u=normalize(cross(f,r)),\r\n         c=ro+f*.183,\r\n         i=c+uv.x*r+uv.y*u,\r\n        rd=i-ro;\r\n\r\n    // center tracking\r\n        rd.xy = r2( (.2*sin(time*.3))-path(lp.z).x/ 24. )*rd.xy;\r\n        rd.xz = r2( y-path(lp.z+1.).y/ 14. )*rd.xz;\r\n\r\n    // march\r\n    vec2 t = marcher(ro,rd, 164,1.);\r\n    float d = t.x,\r\n          m = t.y;\r\n    s_hp=g_hp;\r\n\r\n    // if visible\r\n    if(d<MAXDIST)\r\n    {\r\n        vec3 p = ro+rd*d;\r\n\r\n        vec3 n = normal(p,d);\r\n        vec3 lpos = vec3(0,0,.25)-p;\r\n        lpos +=lp;\r\n        lpos.xy += path(lpos.z);\r\n        vec3 l = normalize(lpos);\r\n\r\n        float diff = clamp(dot(n,l),.01,1.);\r\n\r\n        float spec = pow(max(dot(reflect(l,n),rd),.01),24.);\r\n\r\n        vec3 h = m==11.? vec3(.005): vec3(1.0);\r\n        if(m==3.||m==4.) h = vec3(.012);\r\n        if(tm>ths) {\r\n            C =(h * diff + spec);\r\n        } else {\r\n            if(m==3.||m==4.) C =(hsv2rgb(vec3(s_hp.z*.01,.8,.6))  * diff);\r\n        }\r\n\r\n    }\r\n\r\n    if(tm>ths) {\r\n        if(mod(T,.1)<.05)FC=vec3(.8);\r\n    }else{\r\n\r\n        C += abs(glow*.7)*hsv2rgb(vec3(s_hp.z*.01,.8,.6));\r\n        C += abs(objglow*.65)*vec3(1,1,1);\r\n    }\r\n    C = mix( C, FC, 1.-exp(-0.000075*t.x*t.x*t.x));\r\n    C += abs(beams*.65)*hsv2rgb(vec3(s_hp.z*.025,.8,.6));\r\n    C += abs(flight*.75)*vec3(.5,1,.2);\r\n    }\r\n\r\n\r\n    float px = 1./R.x;\r\n\r\n\r\n    float d1 = fBox2(uv+vec2(-.485,.2675),vec2(.005))-.002;\r\n    d1=smoothstep(px,-px,d1);\r\n    C=mix(C,vec3(0.212,0.671,0.576),d1);\r\n\r\n    d1 = fBox2(uv+vec2(-.465,.2675),vec2(.005))-.002;\r\n    d1=smoothstep(px,-px,d1);\r\n    C=mix(C,vec3(0.757,0.686,0.341),d1);\r\n\r\n    d1 = fBox2(uv+vec2(-.445,.2675),vec2(.005))-.002;\r\n    d1=smoothstep(px,-px,d1);\r\n    C=mix(C,vec3(0.882,0.459,0.867),d1);\r\n\r\n    C=pow(C, vec3(0.4545));\r\n    O = vec4(C,1.0);\r\n}\r\n"},{id:"3tXBWS",name:"The City At night by gilesruscoe",shader:"// https://www.shadertoy.com/view/3tXBWS\r\n#define AA 6.0 / iResolution.y\r\n\r\nfloat hash21(vec2 v) {\r\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123);\r\n}\r\n\r\nfloat line(vec2 uv, vec2 a, vec2 b, float width)\r\n{\r\n    vec2 pa = uv - a;\r\n    vec2 ba = b - a;\r\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\r\n\treturn 1.0 - smoothstep(-AA, AA, length(pa - ba * h) - width);\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord/iResolution.xy;\r\n    float ar = iResolution.y / iResolution.x;\r\n    uv = uv * 2.0 - 1.0;\r\n    uv *= 1.0 + sin(iTime * 0.5) * 0.35;\r\n\r\n    uv.y *= ar;\r\n\r\n\r\n    vec3 comp = vec3(0.0);\r\n    float lines = 0.0;\r\n    for(int i = 0; i < 100; i++)\r\n    {\r\n       \tfloat ifloat = float(i);\r\n        vec2 seed = vec2(ifloat * 1.0, ifloat * 3.0);\r\n        vec2 pos = (vec2((hash21(seed) * 2.0 - 1.0) * 2.0,\r\n                         (hash21(seed*2.0) * 2.0 - 1.0)) * 0.5);\r\n\r\n        float soundsample = texture( iChannel0, vec2(floor(abs(pos.x*0.5) * 32.0) / 32.0,0.0) ).x * 1.10;\r\n        if(soundsample < 0.55)\r\n            continue;\r\n\r\n        float burst = pow(soundsample, 5.0) * 20.0;\r\n\r\n        pos.x += sin(iTime + ifloat) * 0.25;\r\n        pos.y += cos(iTime * 2.0 + ifloat) * 0.15;\r\n        float value = length(uv + pos) * 4.25;\r\n\r\n        // circles\r\n        vec3 col = normalize(vec3(sin(pos.x*5.0) + 0.25, 0.1, sin(pos.y*10.0))) * 3.0;\r\n    \tcomp += clamp(col * smoothstep(value - AA, value + AA, 0.01 + burst * 0.02) * 0.155, vec3(0.0), vec3(1.0));\r\n        comp += clamp(col * smoothstep(value - 0.5, value + 0.5, 0.01 + burst * 0.075) * 0.01, vec3(0.0), vec3(1.0)) * 2.0;\r\n\r\n        // Lines\r\n        float L = 0.0;\r\n        for(int j = 0; j < int(pow(soundsample, 3.0) * 15.8); j++)\r\n        {\r\n            float jfloat = float(j);\r\n            vec2 Lseed = vec2(jfloat, jfloat);\r\n            vec2 Lpos = (vec2((hash21(Lseed) * 2.0 - 1.0) * 2.0,\r\n                         (hash21(Lseed*2.0) * 2.0 - 1.0)) * 0.5);\r\n            Lpos.x += sin(iTime + jfloat) * 0.25;\r\n        \tLpos.y += cos(iTime * 2.0 + jfloat) * 0.15;\r\n            L = max(L, line(uv, -pos, -Lpos, 0.001));\r\n        }\r\n        lines += L;\r\n\r\n    }\r\n    comp *= 0.25;\r\n    comp += lines * 0.01;\r\n    vec3 bg = vec3(0.35*(uv.y * 0.5 + 0.5), 0.0, 0.15);\r\n    fragColor = vec4(bg + vec3(comp)*12.0, 1.0);\r\n}\r\n"},{id:"wlVXRV",name:"Goatrance trip ! by z0rg",shader:"// https://www.shadertoy.com/view/wlVXRV\r\n// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\r\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/\r\n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\r\n// =========================================================================================================\r\n\r\nconst float PI = 3.14159265;\r\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\r\n\r\nfloat lenny(vec2 v)\r\n{\r\n  return abs(v.x)+abs(v.y);\r\n}\r\nfloat sat(float a)\r\n{\r\n  return clamp(a,0.,1.);\r\n}\r\nvec3 sat(vec3 v)\r\n{\r\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\r\n}\r\nvec2 repeat(vec2 p, vec2 sp)\r\n{\r\n  return mod(p,sp)-sp/2.;\r\n}\r\nfloat _cir(vec2 uv, float sz)\r\n{\r\n  return length(uv)-sz;\r\n}\r\n\r\n float sdf_rect(vec2 uv, vec2 sz)\r\n{\r\n  vec2 r = abs(uv)-sz;\r\n  return max(r.x,r.y);\r\n}\r\n\r\nfloat _union(float a, float b)\r\n{\r\n  return min(a,b);\r\n}\r\nfloat _sub(float a, float b)\r\n{\r\n  return max(a,-b);\r\n}\r\n\r\n\r\nvec3 rdrPsy(vec2 uv)\r\n{\r\n  vec3 cols[4];\r\n\r\n  cols[0] = vec3(196.,1.,44.)/255.;\r\n  cols[1] = .0*vec3(1.,44.,196.)/255.;\r\n  cols[2] = vec3(1.,196.,153.)/255.;\r\n  cols[3] = vec3(196.,153.,1.)/255.;\r\n  float fidx= mod(-iTime+length(uv)*4.+.2*-abs(sin(50.*atan(uv.y,uv.x)/PI))\r\n    +abs(0.1*sin(iTime*5.+sin(uv.x*5.)*179.7*atan(uv.y,uv.x)/PI))\r\n      ,4.);\r\n  int curIdx=int(fidx);\r\n  vec3 bubbles = vec3(uv,.5)*(1.-sat(50.*_cir(repeat(uv*(sin(iTime*.5)*.2+.5)*r2d(.5*sin(uv.y*2.+iTime*.5)),vec2(.1)),.02)));\r\n  return bubbles+vec3(.3)+mix(cols[curIdx], cols[int(mod(float(curIdx)+1.,4.))], fract(fidx));\r\n}\r\n\r\nvec3 rdrScn(vec2 uv)\r\n{\r\n  vec2 uvc = vec2(abs(uv.x),uv.y*sign(uv.x));\r\n  vec2 uvcir =uvc- vec2(.0);\r\n  float acir = atan(uvcir.y,uvcir.x)/PI;\r\n  vec2 pcir = vec2(sin(iTime),cos(iTime*.7))*.5;\r\n  float cir = (1.-sat(_cir(uv+pcir,.5)*200.))*float(acir<.7*sin(10.*-iTime+length(uvcir)*20.));;\r\n\r\n\r\n  return vec3(abs(uv),.5)*cir*2.;\r\n}\r\n\r\nvec3 rdrDot(vec2 uv, float szmin, float szmax)\r\n{\r\n  vec2 ouv = uv;\r\n  uv = vec2(int(uv.x/szmax),int(uv.y/szmax))*szmax;\r\n  vec3 col = rdrScn(uv);\r\n\r\n  return col*(1.-sat((length(ouv-uv-vec2(.5*szmax*sign(uv.x),.5*szmax*sign(uv.y)))-mix(szmin,(szmax-.1*szmax)*.5,col.x))*200.*(col.x+.1)));\r\n}\r\n\r\nfloat sdCross(vec2 p, float sz)\r\n{\r\n  vec2 sz2 = vec2(sz,sz/3.);\r\n  float a = sdf_rect(p,sz2);\r\n  float b = sdf_rect(p,sz2.yx);\r\n\r\n  return _union(a,b);\r\n}\r\n\r\nvec3 rdrCross(vec2 uv)\r\n{\r\n  vec3 acc;\r\n\r\n  for (int i = 0;i<16;++i)\r\n  {\r\n    float fi = float(i);\r\n    float px = sin(fi)*.5;\r\n    vec2 pos= vec2(px,sin(px*2.+iTime)+mod((fi-4.)*5.,.53));\r\n    vec2 p = (uv-vec2(pos))*r2d(sin(iTime*.5+float(i)));\r\n\r\n    float sd = sat(sdCross(p,.1*fi*.3)*200.);\r\n    float sdHalo = sat(sdCross(p,.1*(fi*.2))*5.);\r\n    float sd2 = sat(sdCross(p,.08*(fi*.3))*200.);\r\n\r\n    acc*= sd;\r\n    acc+= vec3(1.)*(sd2*(1.-sd))+(1.-sdHalo)*sd*vec3(uv.xyx*.5+.5);\r\n  }\r\n  return acc;\r\n}\r\n\r\nvec3 rdr(vec2 uv)\r\n{\r\n  vec3 opsy = rdrPsy(uv*r2d(-iTime));\r\n  uv = abs(uv);\r\n  uv = uv*r2d(20.*atan(uv.y,uv.x)/PI);\r\n  uv= uv+(vec2(.1)*r2d(-iTime));\r\n  float sel = float(mod(iTime,.4)<.2);\r\n  vec3 col = rdrDot((uv+vec2(.3))*r2d(iTime),.02,mix(.05,.01,sel));\r\n  vec3 c2 = rdrCross(uv);\r\n\r\n  return mix(col,c2,c2.x)+rdrPsy(uv).yxz-opsy.zyx*.5;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n  vec2 uv = fragCoord.xy / iResolution.xx;\r\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\r\nuv*=2.+(sin(iTime)*.5+.5);\r\n  vec3 col = rdr(uv);\r\n    //uv.x += .5;\r\n    float rad = length(uv)-.1;\r\n    float an = abs(atan(uv.y, uv.x)/PI);\r\n    vec3 col2 = col*float(rad < texelFetch(iChannel0, ivec2(int((an)*512.), 0), 0).x)*.5;\r\n    vec3 outcol = sat(1.-lenny(uv*.5))*col.zxy*.5+col2.zxy;\r\n//    outcol = pow(outcol, vec3(1./2.2));\r\n\r\n    float fadeIn = clamp(iTime,0.,3.)/3.;\r\n  fragColor = vec4(outcol*fadeIn, 1.0);\r\n}\r\n"},{id:"3l2Gzc",name:"Music Visualizer #3 (Bokeh) by jaszunio15",shader:"// https://www.shadertoy.com/view/3l2Gzc\r\n//License: CC BY 3.0\r\n//Author: Jan Mróz (jaszunio15)\r\n\r\n//1/512\r\n#define FREQ_STEP (0.001953125 * 3.0)\r\n\r\n#define PI 3.1415927\r\n#define TWO_PI 6.283185\r\n\r\nfloat pow2(in float x)\r\n{\r\n \treturn x*x;\r\n}\r\n\r\nfloat pow3(in float x)\r\n{\r\n \treturn x*x*x;\r\n}\r\n\r\nfloat pow4(in float x)\r\n{\r\n \treturn x*x*x*x;\r\n}\r\n\r\nfloat hash1_2(vec2 x)\r\n{\r\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);\r\n}\r\n\r\nvec2 hash2_2(vec2 x)\r\n{\r\n    return fract(sin(x * mat2x2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\r\n}\r\n\r\n//Simple interpolated noise\r\nvec2 noise2_2(vec2 uv)\r\n{\r\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\r\n\r\n \tvec2 uv00 = floor(uv);\r\n    vec2 uv01 = uv00 + vec2(0,1);\r\n    vec2 uv10 = uv00 + vec2(1,0);\r\n    vec2 uv11 = uv00 + 1.0;\r\n    vec2 v00 = hash2_2(uv00);\r\n    vec2 v01 = hash2_2(uv01);\r\n    vec2 v10 = hash2_2(uv10);\r\n    vec2 v11 = hash2_2(uv11);\r\n\r\n    vec2 v0 = mix(v00, v01, f.y);\r\n    vec2 v1 = mix(v10, v11, f.y);\r\n    vec2 v = mix(v0, v1, f.x);\r\n\r\n    return v;\r\n}\r\n\r\n//Average band volume from nearest bands, more steps - smoother spectrum\r\nfloat getAvgVolume(float v, int steps)\r\n{\r\n    float sum = 0.0;\r\n    float x = 0.0;\r\n\tfor (int i = 0; i < steps; i++)\r\n    {\r\n        x = fract(v + float(i) * FREQ_STEP);\r\n        \t\t\t\t\t\t\t\t//pow for non linear spectrum\r\n        sum += texture(iChannel0, vec2(pow3(x), 0.0)).r * pow(x, 0.08) * (1.0 + v * 0.5);\r\n    }\r\n\r\n    return (sum / float(steps));\r\n}\r\n\r\nvec3 myHue(float hue)\r\n{\r\n    hue = fract(hue);\r\n \treturn clamp(vec3(sin(hue * TWO_PI),\r\n                      sin(hue * TWO_PI + TWO_PI * 0.33),\r\n                      sin(hue * TWO_PI + TWO_PI * 0.66)), 0.0, 1.0);\r\n}\r\n\r\n//Cell center from point on the grid\r\nvec2 voronoiPointFromRoot(vec2 root, float deg)\r\n{\r\n  \tvec2 point = hash2_2(root) - 0.5;\r\n    float s = sin(deg);\r\n    float c = cos(deg);\r\n    point = mat2x2(s, c, -c, s) * point;\r\n    point += root + 0.5;\r\n    return point;\r\n}\r\n\r\nfloat degFromRootUV(vec2 uv, float animationOffset)\r\n{\r\n \treturn (iTime + animationOffset) * (hash1_2(uv) + 0.2);\r\n}\r\n\r\nvec2 rotate(vec2 point, float deg)\r\n{\r\n \tfloat s = sin(deg);\r\n    float c = cos(deg);\r\n    return mat2x2(s, c, -c, s) * point;\r\n}\r\n\r\n//Main circle sync\r\nfloat intensiveMomentSoft()\r\n{\r\n \tfloat introMod = smoothstep(0.0, 27.5, iChannelTime[0]);\r\n    float introMod4 = pow2(introMod);\r\n\r\n    float silence = 1.0 - smoothstep(120.0, 137.0, iChannelTime[0]);\r\n    float drop = smoothstep(158.0, 165.5, iChannelTime[0]);\r\n    drop = pow4(drop);\r\n    float silence2 = 1.0 - smoothstep(260.5, 274.25, iChannelTime[0]);\r\n\r\n    return introMod4 * silence + drop * silence2;\r\n}\r\n\r\n//Particle movment speed sync\r\nfloat intensiveMomentMove()\r\n{\r\n    float intro = smoothstep(25.5, 27.6, iChannelTime[0]);\r\n    float intro2 = smoothstep(81.5, 82.5, iChannelTime[0]);\r\n    float silence = 1.0 - smoothstep(120.0, 137.0, iChannelTime[0]);\r\n    float drop = smoothstep(164.5, 166.5, iChannelTime[0]);\r\n    float drop2 = smoothstep(218.5, 219.5, iChannelTime[0]);\r\n    float silence2 = 1.0 - smoothstep(260.5, 274.25, iChannelTime[0]);\r\n    return (intro + intro2 * 0.5) * silence + (drop + drop2 * 0.5) * silence2;\r\n\r\n}\r\n\r\n//Particle zoom sync\r\nfloat intensiveMomentZoom()\r\n{\r\n    float introMod = smoothstep(0.0, 27.5, iChannelTime[0]);\r\n    float introMod2 = smoothstep(81.5, 82.5, iChannelTime[0]);\r\n    float silence = 1.0 - smoothstep(120.0, 137.0, iChannelTime[0]);\r\n    float drop = smoothstep(158.0, 165.5, iChannelTime[0]);\r\n    float drop2 = smoothstep(218.5, 219.5, iChannelTime[0]);\r\n    float silence2 = 1.0 - smoothstep(260.5, 274.25, iChannelTime[0]);\r\n\r\n    return 1.0 - ((introMod + introMod2 * 0.5) * silence + (drop + drop2 * 0.5) * silence2);\r\n}\r\n\r\n//x - voronoi coordinates (grid step = 1)\r\nfloat voronoi(vec2 uv, vec2 distProportions, float distRotation, float animationOffset)\r\n{\r\n    vec2 rootUV = floor(uv);\r\n    float deg = degFromRootUV(rootUV, animationOffset);\r\n    vec2 pointUV = voronoiPointFromRoot(rootUV, deg);\r\n\r\n    vec2 tempRootUV;\t//Used in loop only\r\n    vec2 tempPointUV;\t//Used in loop only\r\n    vec2 closestPointUV = pointUV;\r\n    float minDist = 2.0;\r\n    float dist = 2.0;\r\n    for (float x = -1.0; x <= 1.0; x+=1.0)\r\n    {\r\n     \tfor (float y = -1.0; y <= 1.0; y+=1.0)\r\n        {\r\n         \ttempRootUV = rootUV + vec2(x, y);\r\n            deg = degFromRootUV(tempRootUV, animationOffset);\r\n            tempPointUV = voronoiPointFromRoot(tempRootUV, deg);\r\n            tempPointUV = mix(tempPointUV, tempRootUV + 0.5, animationOffset);\r\n\r\n            dist = length(rotate(uv - tempPointUV, distRotation) * distProportions);\r\n            if(dist < minDist)\r\n            {\r\n             \tclosestPointUV = tempPointUV;\r\n               \tminDist = dist;\r\n            }\r\n        }\r\n    }\r\n\r\n    return minDist;\r\n}\r\n\r\n//Bokeh from voronoi\r\nfloat bokehParticles(vec2 uv, float radius, vec2 dotProportions, float dotRotation, float animationOffset)\r\n{\r\n \tfloat voro = voronoi(uv, dotProportions, dotRotation, animationOffset);\r\n    float particles = 1.0 - smoothstep(radius, radius * (2.0), voro);\r\n    return particles;\r\n}\r\n\r\n//Layering particles to imitate 3D view\r\nvec3 layeredParticles(vec2 uv, float radiusMod, float sizeMod, float alphaMod, int layers, vec2 dotProportions, float dotRotation, float animationOffset)\r\n{\r\n    vec3 particles = vec3(0);\r\n    float size = 1.0;\r\n    float alpha = 1.0;\r\n    float radius = 0.04;\r\n    vec2 offset = vec2(0.0);\r\n    vec3 startColor = myHue(iTime * 0.05 + animationOffset * 0.5) + 0.3;\r\n    vec3 endColor = myHue(iTime * 0.05 + 0.3 + animationOffset * 0.5) + 0.3 + animationOffset;\r\n    vec3 color = startColor;\r\n    for (int i = 0; i < layers; i++)\r\n    {\r\n\t\tparticles += bokehParticles(\r\n            (uv * size + vec2(sin(iTime * 0.3), cos(iTime * 0.3)) * 6.0 * intensiveMomentMove() - animationOffset * 0.3) + offset,\r\n            radius,\r\n            dotProportions,\r\n            dotRotation + offset.x,\r\n            animationOffset\r\n        \t) * alpha * color;\r\n        color = mix(startColor, endColor, float(i+1) / float(layers));\r\n        offset += hash2_2(vec2(alpha, alpha)) * 10.0;\r\n        alpha *= alphaMod;\r\n        size *= sizeMod;\r\n        radius *= radiusMod;\r\n    }\r\n    return particles;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float intensivity = intensiveMomentSoft();\r\n\r\n    vec3 col = vec3(0);\r\n\r\n    //Gathering the kick from the song\r\n    float kick = getAvgVolume(0.08, 50);\r\n    kick = sqrt(smoothstep(0.25, 0.5, pow4(kick))) * intensivity;\r\n\r\n    //uv 0.0 at the screen center\r\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\r\n    uv *= 2.0;\r\n\r\n    //Fish eye\r\n    uv *= 1.0 - length(uv) * 0.2;\r\n\r\n    //Displacement\r\n    uv += (noise2_2(uv * 3.0 + iTime + kick) - 0.5) * 0.1 * kick;\r\n\r\n    //Dots shape\r\n    vec2 dotProportions = mix(vec2(1.0), vec2(0.07, 10.0), kick);\r\n\r\n    //Particles\r\n    vec3 particles = layeredParticles(\r\n        uv,\r\n        0.99 + kick * 0.01, //RadiusMod\r\n        1.08 - kick * 0.02 - intensiveMomentZoom() * 0.1, //SizeMod\r\n        0.93, //AlphaMod\r\n        20, //Layers\r\n        dotProportions,\r\n        PI * 0.5 + (iTime - kick), //Dots rotation\r\n        kick * 0.5\t//Animation offset\r\n    \t) * 0.75;\r\n    col += particles;\r\n\r\n    //Coloring the darkness\r\n    col += 0.05 * myHue(kick + iTime * 0.1);\r\n\r\n  \t//Center circle\r\n    float circle = 1.0 - smoothstep(0.1 + (1.0 - intensivity) + kick * kick * 0.5, 0.1 + (1.0 - intensivity) + kick * kick * 0.5 + 0.01 + kick * 0.001, length(uv) * intensivity);\r\n\r\n \t//Placing the circle\r\n    col += circle * intensivity;\r\n\r\n    //Inverting colors in the circle\r\n    col = mix(col, (1.3 + kick * 0.4) - col, circle * intensivity);\r\n\r\n    //Vigniete and addtitional lighting\r\n    float vignete = 1.0 - smoothstep(1.0, 1.8, length(uv * vec2(1.0, iResolution.x / iResolution.y)));\r\n    float lighting = 1.0 - smoothstep(0.0, 2.0, length(uv));\r\n    float lighting2 = 1.0 - smoothstep(0.3, 0.8, length(uv));\r\n\r\n    //Postrpocess\r\n    col = smoothstep(-0.1, 0.9, col);\r\n\r\n    //Vignete\r\n    col *= vignete;\r\n\r\n    //Lighting\r\n    col += (lighting * kick * 0.1) + lighting2 * kick * 0.15;\r\n\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"NlsfDM",name:"nanoKontrol2 by byt3_m3chanic",shader:"// https://www.shadertoy.com/view/NlsfDM\r\n/**\r\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n\r\n    NanoKontrol2 Korg Midi interface\r\n    04/26/22 | byt3_m3chanic\r\n\r\n    Use sound or mic in iChannel0\r\n\r\n\r\n    Made mostly just cause I had a day to play, but also a pretty\r\n    good demo of how to access the midi texture in KodeLife\r\n    (though here on Shadertoy I'm just pumping the sound to controll)\r\n\r\n    https://twitter.com/byt3m3chanic/status/1518968742314754049\r\n\r\n    to use in KodeLife - replace the sampleFreq calls with midiCoord\r\n\r\n    ivec2 midiCoord(int offset){\r\n        int x = offset % 32;\r\n        int y = offset / 32;\r\n        return ivec2(x,y);\r\n    }\r\n\r\n    float md1 = texelFetch(midi1, midiCoord(3 * 127 + i), 0).x;\r\n*/\r\n\r\n#define R iResolution\r\n#define M iMouse\r\n#define T iTime\r\n\r\n#define PI2 6.28318530718\r\n#define PI  3.14159265359\r\n\r\n// button color\r\nconst vec3 lcolor = vec3(0.949,0.008,0.290);\r\n// power color\r\nconst vec3 tcolor = vec3(0.855,0.969,0.812);\r\n\r\nmat2 rot(float g) {return mat2(cos(g), sin(g),-sin(g), cos(g));}\r\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\r\n\r\nfloat sampleFreq(float freq) {\r\n    return texture(iChannel0, vec2(freq, 0.1)).x;\r\n}\r\n\r\nfloat box(in vec2 p, in vec2 b){\r\n    vec2 d = abs(p)-b;\r\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\r\n}\r\n\r\nfloat px = 0.;\r\n\r\nvoid nanoBody(inout vec3 C, vec2 p) {\r\n    vec2 uv=p-vec2(0);\r\n\r\n    //body\r\n    float d = box(uv,vec2(.725,.2))-.015;\r\n    d=smoothstep(px,-px,d);\r\n\r\n    //inset\r\n    float i = box(uv,vec2(.715,.1875))-.015;\r\n    i=smoothstep(px,-px,i);\r\n\r\n    //shadow\r\n    float sd = box(uv+vec2(0,.01),vec2(.71,.19));\r\n    sd=smoothstep(.045-px,-px,abs(sd)-.01);\r\n    float hs = hash21(uv*sin(uv.x));\r\n\r\n    C= mix(C,vec3(.0),sd);\r\n    C= mix(C,vec3(.015)-(hs*.01),d);\r\n    C= mix(C,vec3(.035)-(hs*.01),clamp(min(uv.y+.45,i),0.,1.));\r\n\r\n    // button fame boxes\r\n    float r = box(uv+vec2(.55,.15),vec2(.13,.0275));\r\n    r=smoothstep(px,-px,abs(r)-.00075);\r\n    C= mix(C,vec3(.1),r);\r\n\r\n    r = box(uv+vec2(.55,.05),vec2(.13,.021));\r\n    r=smoothstep(px,-px,abs(r)-.00075);\r\n    C= mix(C,vec3(.1),r);\r\n\r\n    // power light\r\n    float l = box(uv+vec2(.7,-.175),vec2(.0125,.002))-.0025;\r\n    float sl=smoothstep(.02-px,-px,l);\r\n    l=smoothstep(px,-px,l);\r\n    C= mix(C,tcolor*.2,sl);\r\n    C= mix(C,tcolor,l);\r\n}\r\n\r\nvoid knob(inout vec3 C, vec2 p, float level) {\r\n    vec2 uv = p-vec2(0);\r\n    //base\r\n    uv*=rot(level*PI2);\r\n    float k = length(uv)-.037;\r\n    float dk = length(uv)-.027;\r\n    dk=smoothstep(px,-px,abs(dk)-.005);\r\n    k=smoothstep(px,-px,k);\r\n\r\n    C= mix(C,vec3(.001),k);\r\n    C= mix(C,uv.x>0.?vec3(.16):vec3(.05),dk);\r\n\r\n    //line\r\n    float l = box(uv-vec2(0,.01),vec2(.0015,.01));\r\n    l=smoothstep(px,-px,l);\r\n\r\n    C= mix(C,vec3(.6),l);\r\n}\r\n\r\nvoid slider(inout vec3 C, vec2 p, float level) {\r\n    vec2 uv=p-vec2(0);\r\n\r\n    //background\r\n    float d = box(uv,vec2(.015,.125))-.015;\r\n    d=smoothstep(px,-px,d);\r\n    C= mix(C,uv.x<0.?vec3(.1):vec3(.15),d);\r\n\r\n    //lines\r\n    float l = box(uv,vec2(.015,.0001));\r\n    l = min(box(vec2(uv.x,abs(abs(uv.y)-.075)-.025),vec2(.015,.0001)),l);\r\n    l=smoothstep(px,-px,l);\r\n    C= mix(C,uv.x>0.?vec3(.00):vec3(.5),l);\r\n\r\n    //slider\r\n    level = (level*.75)-.15;\r\n    float b = box(uv-vec2(0,level),vec2(.0125,.0175))-.0075;\r\n    b=smoothstep(px,-px,b);\r\n\r\n    C= mix(C,vec3(.01),b);\r\n}\r\n\r\nvoid button(inout vec3 C, vec2 p, float state, int type) {\r\n    vec2 uv = p-vec2(0);\r\n    //base\r\n    float b = box(uv,vec2(.0125,type==2?.005:.0125))-.005;\r\n    float sl=smoothstep(.02-px,-px,b);\r\n    b=smoothstep(px,-px,b);\r\n\r\n    if(state>.001) C= mix(C,lcolor*.2,sl);\r\n    C= mix(C,state>.001?lcolor:vec3(.05),b);\r\n}\r\n\r\nvoid backdrop( inout vec3 C, vec2 p) {\r\n    vec2 uv = p-vec2(0);\r\n    uv*=rot(.78);\r\n    float d = box(uv,vec2(5.,.4));\r\n    float dcut=d;\r\n    float sd=smoothstep(.03-px,-px,d);\r\n    d=smoothstep(px,-px,d);\r\n    C=mix(C,vec3(.0001),sd);\r\n    C=mix(C,vec3(.001),d);\r\n    C=mix(C,vec3(0.384,0.510,0.227),clamp(min((p.y+.015)*2.865,d),0.,1.));\r\n\r\n\r\n    float i = .03;\r\n    vec2 nv=p-vec2(1.-T*.1,-.02);\r\n    vec2 f = fract(nv*40.)-.5;\r\n    vec2 fid = floor(nv*40.)+.5;\r\n    fid.x=mod(fid.x,30.);\r\n    float ht = sampleFreq(fid.x*.015)*.85;\r\n\r\n    float bd = box(f,vec2(.4))-.01;\r\n    bd=max(bd,dcut);\r\n    bd=smoothstep(px,-px,bd);\r\n\r\n    float bx = box(f,vec2(.3))-.01;\r\n    bx=abs(bx)-.12;\r\n    bx=max(bx,dcut);\r\n    bx=smoothstep(px,-px,bx);\r\n\r\n    //draw dots\r\n    if(fid.x<40.&& fid.y>0.) {\r\n        float avg = (fid.y*.095)-.5;\r\n        if(ht>avg) C=mix(C,vec3(.0001),bx);\r\n        if ( ht>avg&&ht<avg+.1) C=mix(C,vec3(.0001),bd);\r\n    }\r\n\r\n\r\n    uv.y=abs(uv.y-.38)-.02;\r\n    float nd = box(uv,vec2(5.,.0075));\r\n    nd=smoothstep(px,-px,nd);\r\n    C=mix(C,tcolor,nd);\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 O, in vec2 F )\r\n{\r\n\r\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\r\n    float hs = hash21(uv*sin(uv.x));\r\n    vec3 C = vec3(.3-(hs*.05));\r\n\r\n    px=2./R.x;\r\n\r\n    backdrop(C, uv);\r\n\r\n    // uncomment for fun\r\n    //uv.x+=T*.3;\r\n    //uv.x=mod(uv.x+1.,2.)-1.;\r\n\r\n    nanoBody(C, uv+vec2(0,.25));\r\n    // to use midi texture you loop over\r\n    // the control values based on a 32x32\r\n    // texture\r\n    // https://hexler.net/kodelife/manual/parameters-built-in\r\n\r\n    // sliders\r\n    for(int i = 0; i<8;i++) {\r\n        //float md1 = (texelFetch(midi1, midiCoord(3 * 127 + i), 0).x);\r\n        float md1 = sampleFreq(float(i)*.042)*.35;\r\n        vec2 p = vec2(.25,.29)-vec2(float(i)*.13,0);\r\n\r\n        slider(C, uv+p, md1);\r\n    }\r\n\r\n    // knobs\r\n    int tk = 0;\r\n    for(int i = 16; i<24;i++) {\r\n    //\r\n        float md1 = sampleFreq(float(i)*.051)*.5;\r\n        vec2 p = vec2(.25,.0925)-vec2(float(tk)*.13,0);\r\n        knob(C,uv+p,md1);\r\n\r\n        tk++;\r\n    }\r\n\r\n    // solo buttons\r\n    tk = 0;\r\n    for(int i = 32; i<40;i++) {\r\n        float md1 = sampleFreq(float(tk)*.02)*.45;\r\n        if(md1<.2) md1 = 0.;\r\n        vec2 p = vec2(.3125,.2)-vec2(float(tk)*.13,0);\r\n        button(C,uv+p, md1, 0);\r\n        tk++;\r\n    }\r\n\r\n    // mute buttons\r\n    tk = 0;\r\n    for(int i = 48; i<56;i++) {\r\n        float md1 = sampleFreq(float(tk)*.1)*.45;\r\n        if(md1<.1) md1 = 0.;\r\n        vec2 p = vec2(.3125,.25)-vec2(float(tk)*.13,0);\r\n        button(C,uv+p, md1, 0);\r\n        tk++;\r\n    }\r\n\r\n    // record buttons\r\n    tk = 0;\r\n    for(int i = 64; i<72;i++) {\r\n        float md1 = sampleFreq(float(i-35)*.1)*.45;\r\n        if(md1<.1) md1 = 0.;\r\n        vec2 p = vec2(.3125,.3)-vec2(float(tk)*.13,0);\r\n        button(C,uv+p, md1, 0);\r\n        tk++;\r\n    }\r\n\r\n    // track buttons\r\n    for(int i = 41; i<46;i++) {\r\n        float md1 = sampleFreq(float(i-41)*.1)*.45;\r\n        if(md1<.25)md1 = 0.;\r\n        // track button midi jumps all over? why Korg?\r\n        // fixing my brute force\r\n        float fk = 0.;\r\n        if(i==41){\r\n        fk=10.;\r\n        }else if(i==42){\r\n        fk=9.;\r\n        }else if(i==43){\r\n        fk=7.;\r\n        }else if(i==44){\r\n        fk=8.;\r\n        }else{\r\n        fk=11.;\r\n        }\r\n\r\n        vec2 p = vec2(1.,.4)-vec2(float(fk)*.05,0);\r\n        button(C,uv+p, md1, 0);\r\n        tk++;\r\n    }\r\n\r\n    // cycle button\r\n    tk = 0;\r\n    float md1 = sampleFreq(float(.23434)*.1)*.45;\r\n    if(md1<.2) md1 = 0.;\r\n    button(C,uv+vec2(.65,.30), md1, 2);\r\n\r\n    // marker buttons\r\n        for(int i = 60; i<63;i++) {\r\n        float md1 = sampleFreq(float(i-35)*.1)*.45;\r\n        if(md1<.1) md1 = 0.;\r\n        vec2 p = vec2(.55,.30)-vec2(float(tk)*.05,0);\r\n        button(C,uv+p, md1, 2);\r\n        tk++;\r\n    }\r\n\r\n    // track buttons\r\n        for(int i = 58; i<60;i++) {\r\n        float md1 = sampleFreq(float(i-57)*.078)*.45;\r\n        if(md1<.25) md1 = 0.;\r\n        vec2 p = vec2(.8,.25)-vec2(float(tk)*.05,0);\r\n        button(C,uv+p, md1, 2);\r\n        tk++;\r\n    }\r\n\r\n    if(hs<.65) C = clamp(C+(hs*.005),C,vec3(1));\r\n    C = pow(C, vec3(.4545));\r\n    O = vec4(C,1.);\r\n}\r\n"},{id:"wldBD8",name:"Audio Visualizer: Rainbow by Zi7ar21",shader:"// https://www.shadertoy.com/view/wldBD8\r\n// ##### Audio Visualizer: Rainbow #####\r\n// Made by Zi7ar21 (Discord: @Zi7ar21#2168)\r\n\r\n/* I don't know what this is really, it has pretty colors and stuff...\r\nI made it symetrical and stuff and it can take the Microphone/Soundcloud\r\nInput in iChannel0. uamee's \"COMRADE YOU JUST POSTED CRINGE\" is used as\r\nan example.*/\r\n\r\n// UPDATE August 30th, 2021: Cleaned code, this looked horrifying lmao\r\n\r\n// Anti-Aliasing (Super-Sampling Anti-Aliasing)\r\n#define SSAA 4\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    vec2 uv = 2.0*(fragCoord.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\r\n    vec3 color = vec3(0.0);\r\n    for(int x = -SSAA; x <= SSAA; x++) {\r\n    for(int y = -SSAA; y <= SSAA; y++) {\r\n        vec2 spos = vec2(x, y)/float(SSAA);\r\n        uv = abs(2.0*((fragCoord.xy+spos)-0.5*iResolution.xy)/max(iResolution.x, iResolution.y));\r\n        if(texture(iChannel0, vec2(uv.x, 0.0)).x*uv.y < 0.1)\r\n        {\r\n            color += clamp(vec3(uv.x, 1.0-uv.x, 1.0-uv.y), 0.0, 1.0);\r\n        }\r\n        if(texture(iChannel0, vec2(uv.x, 1.0)).x*uv.y < 0.1)\r\n        {\r\n            color += clamp(vec3(uv.x, 1.0-uv.x, 1.0-uv.y*2.0), 0.0, 1.0);\r\n        }\r\n    }\r\n    }\r\n\r\n    fragColor = vec4(color/float(SSAA*SSAA*8), 1.0);\r\n}\r\n"},{id:"mtjSWm",name:"Fork SoundEclip nobody 012 by nobody",shader:"// https://www.shadertoy.com/view/mtjSWm\r\n// credit: https://www.shadertoy.com/view/4tGXzt\r\n\r\n#define BEATMOVE 1\r\n\r\nconst float FREQ_RANGE = 10.0;\r\nconst float PI = 3.1415;\r\nconst float RADIUS = 0.0;\r\nconst float BRIGHTNESS = 0.5;\r\nconst float SPEED = 0.0;\r\n\r\n//convert HSV to RGB\r\nvec3 hsv2rgb(vec3 c){\r\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n}\r\n\r\nfloat luma(vec3 color) {\r\n  return dot(color, vec3(0.299, 0.587, 0.114));\r\n}\r\n\r\nfloat getfrequency(float x) {\r\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\r\n}\r\n\r\nfloat getfrequency_smooth(float x) {\r\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\r\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\r\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\r\n}\r\n\r\nfloat getfrequency_blend(float x) {\r\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\r\n}\r\n\r\nvec3 doHalo(vec2 fragment, float radius) {\r\n\tfloat dist = length(fragment);\r\n\tfloat ring = 1.0 / abs(dist - radius);\r\n\r\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\r\n\r\n\tvec3 col = vec3(0.0);\r\n\r\n\tfloat angle = atan(fragment.x, fragment.y);\r\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\r\n\r\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\r\n\tcol *= frequency;\r\n\r\n\t// Black halo\r\n\tcol *= smoothstep(radius * 0.5, radius, dist);\r\n\r\n\treturn col;\r\n}\r\n\r\nvec3 doLine(vec2 fragment, float radius, float x) {\r\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\r\n\r\n\tfloat freq = abs(fragment.x * 0.5);\r\n\r\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\r\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\r\n\r\n\treturn col;\r\n}\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n    vec2 fragPos = fragCoord / iResolution.xy;\r\n\tfragPos = (fragPos - 0.5) * 2.0;\r\n    fragPos.x *= iResolution.x / iResolution.y;\r\n\r\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\r\n\tcolor += doHalo(fragPos, RADIUS);\r\n\r\n    float c = cos(iTime * SPEED);\r\n    float s = sin(iTime * SPEED);\r\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\r\n\tcolor += doLine(rot, RADIUS, rot.x);\r\n\r\n\tcolor += max(luma(color) - 1.0, 0.0);\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"NdSGW3",name:"ViolentEyeSimulator314 by Domain314",shader:"// https://www.shadertoy.com/view/NdSGW3\r\n/* DOES NOT WORK (doesn't look the same as in ShaderToy) */\r\nfloat red (vec2 gv, float fft){\r\n    float d = distance(gv, vec2(0.5));\r\n    return smoothstep(0.15, fft, d);\r\n}\r\n\r\nfloat blue (vec2 gv, float fft){\r\n    float d = distance(gv, vec2(0.5));\r\n    return smoothstep(0., fft/2., d);\r\n}\r\n\r\nfloat green(vec2 gv, float fft){\r\n    return smoothstep(0.75, 0.55, gv.y)*(fft-0.1);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\r\n    uv += vec2(0., 0.5);\r\n    vec3 col = vec3(0.);\r\n    vec2 gv = fract(uv);\r\n\r\n    int tx = int(gv.y*512.);\r\n    float fft = texelFetch(iChannel0, ivec2(tx, 0), 0).x;\r\n    float fft2 = texelFetch(iChannel0, ivec2(tx, 1), 0).x;\r\n\r\n    float r = red(gv, fft);\r\n    float b = blue(gv, fft2);\r\n    float g = green(gv, fft2);\r\n\r\n    col.r += r;\r\n    col.b += 1.-b*1.5;\r\n    col.g += 1.-b*1.8;\r\n    col.g += g;\r\n\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"XstSRX",name:"Disco 2000 by finalman",shader:"// https://www.shadertoy.com/view/XstSRX\r\nconst float EXPOSURE = 12.0;\r\nconst float OMNI_LIGHT = 0.1;\r\nconst float FLOOR_REFLECTION = 0.15;\r\n\r\nconst int NUM_LIGHTS = 10;\r\n\r\nconst float PI = 3.1415926535897932384626433832795;\r\nconst float TAU = 2.0 * PI;\r\nconst float BIG = 1e30;\r\nconst float EPSILON = 1e-10;\r\nconst float THETA = (1.0 + 2.2360679775) / 2.0;\r\nconst float INV_THETA = 1.0 / THETA;\r\n\r\nstruct Ray\r\n{\r\n    vec3 o;\r\n    vec3 d;\r\n};\r\n\r\nstruct Intersection\r\n{\r\n    float dist;\r\n    vec3 normal;\r\n};\r\n\r\nstruct Result\r\n{\r\n    Intersection start;\r\n    Intersection end;\r\n};\r\n\r\nstruct Range\r\n{\r\n\tfloat start;\r\n    float end;\r\n};\r\n\r\nstruct Light\r\n{\r\n    vec3 d;\r\n    vec3 c;\r\n    float a;\r\n};\r\n\r\nLight lights[NUM_LIGHTS];\r\n\r\nmat4 rotateX(float v)\r\n{\r\n    float c = cos(v);\r\n    float s = sin(v);\r\n\r\n    return mat4(\r\n        1.0, 0.0, 0.0, 0.0,\r\n        0.0,   c,   s, 0.0,\r\n        0.0,  -s,   c, 0.0,\r\n        0.0, 0.0, 0.0, 1.0\r\n    );\r\n}\r\n\r\nmat4 rotateY(float v)\r\n{\r\n    float c = cos(v);\r\n    float s = sin(v);\r\n\r\n    return mat4(\r\n          c, 0.0,  -s, 0.0,\r\n        0.0, 1.0, 0.0, 0.0,\r\n          s, 0.0,   c, 0.0,\r\n        0.0, 0.0, 0.0, 1.0\r\n    );\r\n}\r\n\r\nmat4 rotateZ(float v)\r\n{\r\n    float c = cos(v);\r\n    float s = sin(v);\r\n\r\n    return mat4(\r\n          c,   s, 0.0, 0.0,\r\n         -s,   c, 0.0, 0.0,\r\n        0.0, 0.0, 1.0, 0.0,\r\n        0.0, 0.0, 0.0, 1.0\r\n    );\r\n}\r\n\r\nfloat insideCone(vec3 direction, float angle, vec3 o)\r\n{\r\n    float oz = dot(o, direction);\r\n    vec3 oxy = o - direction * oz;\r\n    float c = dot(oxy, oxy) / (angle * angle) - (oz * oz);\r\n    return smoothstep(20.0, -50.0, c);\r\n}\r\n\r\nRange cone(vec3 direction, float angle, Ray ray)\r\n{\r\n    float dz = dot(ray.d, direction);\r\n    float oz = dot(ray.o, direction);\r\n    vec3 dxy = ray.d - direction * dz;\r\n    vec3 oxy = ray.o - direction * oz;\r\n\r\n    float a = dot(dxy, dxy) - (dz * dz * angle * angle);\r\n    float b = dot(dxy, oxy) - (dz * oz * angle * angle);\r\n    float c = dot(oxy, oxy) - (oz * oz * angle * angle);\r\n\r\n    float p = 2.0 * b / a;\r\n    float q = c / a;\r\n\r\n    float r = p * p / 4.0 - q;\r\n\r\n    Range result;\r\n    result.start = BIG;\r\n    result.end = -BIG;\r\n\r\n    if (r >= 0.0)\r\n    {\r\n        float m = -p / 2.0;\r\n        float sr = sqrt(r);\r\n\r\n        if (c < 0.0)\r\n        {\r\n\t\t\t// Inside\r\n            if (m + sr < 0.0)\r\n            {\r\n                // Both solutions behind us\r\n                result.start = 0.0;\r\n                result.end = BIG;\r\n            }\r\n            else if (m - sr < 0.0)\r\n            {\r\n                // One solution behind us\r\n                result.start = 0.0;\r\n                result.end = m + sr;\r\n            }\r\n            else\r\n            {\r\n                // Both solutions ahead\r\n                result.start = 0.0;\r\n            \tresult.end = m - sr;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            // Outside\r\n            if (m + sr < 0.0)\r\n            {\r\n                // Both solutions behind us\r\n                return result;\r\n            }\r\n            else if (m - sr < 0.0)\r\n            {\r\n                // One solution behind us\r\n                result.start = m + sr;\r\n                result.end = BIG;\r\n            }\r\n            else\r\n            {\r\n                // Both solutions ahead\r\n                result.start = m - sr;\r\n            \tresult.end = m + sr;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nResult plane(vec3 pos, vec3 normal, Ray ray)\r\n{\r\n    ray.o -= pos;\r\n\r\n    float rdn = dot(ray.d, normal);\r\n    float ron = dot(ray.o, normal);\r\n\r\n    Result result;\r\n    result.start.normal = normal;\r\n    result.end.normal = normal;\r\n\r\n    if (ron > 0.0)\r\n    {\r\n        // Outside\r\n        result.start.dist = BIG;\r\n        result.end.dist = -BIG;\r\n\r\n        if (abs(rdn) > EPSILON)\r\n        {\r\n            float d = -ron / rdn;\r\n\r\n            if (d > 0.0)\r\n            {\r\n                result.start.dist = d;\r\n                result.end.dist = BIG;\r\n            }\r\n            else\r\n            {\r\n                result.start.dist = -BIG;\r\n                result.end.dist = d;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // Inside\r\n        result.start.dist = -BIG;\r\n        result.end.dist = BIG;\r\n\r\n        if (abs(rdn) > EPSILON)\r\n        {\r\n            float d = -ron / rdn;\r\n\r\n            if (d > 0.0)\r\n            {\r\n                result.start.dist = -BIG;\r\n                result.end.dist = d;\r\n            }\r\n            else\r\n            {\r\n                result.start.dist = d;\r\n                result.end.dist = BIG;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nfloat inverseSquare(vec3 p)\r\n{\r\n    return 1.0 / dot(p, p);\r\n}\r\n\r\nfloat inverseSquareAntiderivative(Ray ray, float t)\r\n{\r\n    vec3 o = ray.o;\r\n    vec3 d = ray.d;\r\n\r\n    // Shoutout to Wolfram Alpha\r\n    float a = t * dot(d, d) + dot(d, o);\r\n    float b1 = d.x * d.x * dot(o.yz, o.yz);\r\n    float b2 = 2.0 * d.x * o.x * dot(o.yz, d.yz);\r\n    float b3 = o.x * o.x * dot(d.yz, d.yz);\r\n    float b4 = (o.y * d.z - d.y * o.z) * (o.y * d.z - d.y * o.z);\r\n    float b = sqrt(b1 - b2 + b3 + b4);\r\n    return atan(a / b) / b;\r\n}\r\n\r\nfloat inverseSquareIntegral(Ray ray, float start, float end)\r\n{\r\n    return inverseSquareAntiderivative(ray, end) - inverseSquareAntiderivative(ray, start);\r\n}\r\n\r\nvec3 getLight(vec3 pos)\r\n{\r\n    vec3 color = vec3(inverseSquare(pos) * OMNI_LIGHT * 2.0);\r\n    for (int i = 0; i < NUM_LIGHTS; i++)\r\n    {\r\n        color += lights[i].c * inverseSquare(pos) * insideCone(lights[i].d, lights[i].a, pos);\r\n    }\r\n    return color;\r\n}\r\n\r\nvec3 renderVolumetric(Ray ray, float maxDist)\r\n{\r\n    vec3 color = vec3(inverseSquareIntegral(ray, 0.0, maxDist) * OMNI_LIGHT);\r\n\r\n    for (int i = 0; i < NUM_LIGHTS; i++)\r\n    {\r\n        Range r = cone(lights[i].d, lights[i].a, ray);\r\n        r.end = min(r.end, maxDist);\r\n\r\n        if (r.end > r.start)\r\n        {\r\n            float boost = mix(1.0, 18.0, insideCone(lights[i].d, lights[i].a, ray.o));\r\n\r\n            color += inverseSquareIntegral(ray, r.start, r.end) * lights[i].c * boost;\r\n        }\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\nvec3 floorTexture(vec3 pos)\r\n{\r\n    pos.z += pos.x * 0.25;\r\n    return fract(pos.x * 0.1) > fract(pos.z * 0.1) ? vec3(1.0) : vec3(0.7);\r\n}\r\n\r\nfloat floorGloss(vec3 pos)\r\n{\r\n    pos.x += pos.z * 2.0;\r\n    return texture(iChannel1, pos.xz * 0.2).x * 0.5 + 0.75;\r\n}\r\n\r\nvec3 renderScene(Ray ray)\r\n{\r\n    Result r = plane(vec3(0.0, -18.0, 0.0), vec3(0.0, 1.0, 0.0), ray);\r\n\r\n    if (r.start.dist > 0.0 && r.start.dist < r.end.dist)\r\n    {\r\n        vec3 pos = ray.o + ray.d * r.start.dist;\r\n\r\n        Ray reflectedRay;\r\n        reflectedRay.o = pos;\r\n        reflectedRay.d = ray.d * vec3(1, -1, 1);\r\n\r\n        vec3 volumetric = renderVolumetric(ray, r.start.dist);\r\n        vec3 reflectedVolumetric = renderVolumetric(reflectedRay, BIG);\r\n\r\n        vec3 color = -normalize(pos).y * getLight(pos) * 30.0 * floorTexture(pos);\r\n        float gloss = floorGloss(pos);\r\n\r\n        return volumetric + mix(color, reflectedVolumetric, FLOOR_REFLECTION * gloss);\r\n    }\r\n    else\r\n    {\r\n    \treturn renderVolumetric(ray, BIG);\r\n    }\r\n}\r\n\r\nvec3 toneMap(vec3 color)\r\n{\r\n    return 1.0 - exp(-color * EXPOSURE);\r\n}\r\n\r\nvoid setUpLights()\r\n{\r\n    mat4 m = rotateX(TAU * iTime * 0.05) * rotateY(TAU * iTime * 0.09);\r\n\r\n    lights[0].d = normalize(m * vec4(1, 1, 1, 0)).xyz;\r\n    lights[1].d = normalize(m * m * vec4(1, 1, -1, 0)).xyz;\r\n    lights[2].d = normalize(m * vec4(1, -1, 1, 0)).xyz;\r\n    lights[3].d = normalize(m * m * vec4(1, -1, -1, 0)).xyz;\r\n    lights[4].d = normalize(m * vec4(0, INV_THETA, THETA, 0)).xyz;\r\n    lights[5].d = normalize(m * m * vec4(0, INV_THETA, -THETA, 0)).xyz;\r\n    lights[6].d = normalize(m * vec4(INV_THETA, THETA, 0, 0)).xyz;\r\n    lights[7].d = normalize(m * m * vec4(INV_THETA, -THETA, 0, 0)).xyz;\r\n    lights[8].d = normalize(m * vec4(THETA, 0, INV_THETA, 0)).xyz;\r\n    lights[9].d = normalize(m * m * vec4(-THETA, 0, INV_THETA, 0)).xyz;\r\n\r\n    lights[0].c = normalize(vec3(1, 1, 1) * 0.5 + 0.7);\r\n    lights[1].c = normalize(vec3(1, 1, -1) * 0.5 + 0.7);\r\n    lights[2].c = normalize(vec3(1, -1, 1) * 0.5 + 0.7);\r\n    lights[3].c = normalize(vec3(1, -1, -1) * 0.5 + 0.7);\r\n    lights[4].c = normalize(vec3(0, INV_THETA, THETA) * 0.5 + 0.7);\r\n    lights[5].c = normalize(vec3(0, INV_THETA, -THETA) * 0.5 + 0.7);\r\n    lights[6].c = normalize(vec3(INV_THETA, THETA, 0) * 0.5 + 0.7);\r\n    lights[7].c = normalize(vec3(INV_THETA, -THETA, 0) * 0.5 + 0.7);\r\n    lights[8].c = normalize(vec3(THETA, 0, INV_THETA) * 0.5 + 0.7);\r\n    lights[9].c = normalize(vec3(-THETA, 0, INV_THETA) * 0.5 + 0.7);\r\n\r\n    for (int i = 0; i < NUM_LIGHTS; i++)\r\n    {\r\n        lights[i].a = texture(iChannel0, vec2(float(i) * 0.18, 0.0)).x * 0.3 + 0.05;\r\n    }\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n    setUpLights();\r\n\r\n    Ray ray;\r\n    ray.o = vec3(sin(iTime * 0.5) * 5.0, -12.5 + sin(iTime * 0.6) * 2.5, -25.0);\r\n    ray.d = normalize(rotateX(-sin(iTime * 0.23) * 0.1) *\r\n                      rotateZ(sin(iTime * 0.33) * 0.1) *\r\n                      vec4((fragCoord.xy - iResolution.xy * 0.5) / iResolution.y, 0.7, 0.0)).xyz;\r\n\r\n   \tvec3 color = renderScene(ray);\r\n    color = toneMap(color);\r\n    fragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"MdSyDy",name:"dancing octopus by lab",shader:"// https://www.shadertoy.com/view/MdSyDy\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n  vec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 p = uv - vec2(0.5, 0.5);\r\n    p.y += .05;\r\n\r\n    vec4 sound = texture(iChannel0, uv);\r\n\r\n    float ed = sound.x / 1.4;\r\n    vec2 lep = p;\r\n    lep.y -= 0.38;\r\n    lep.x += 0.03;\r\n    float le = length(lep) / ed;\r\n    le = smoothstep(0.05, 0.06, le);\r\n\r\n    vec2 rep = p;\r\n    rep.y -= 0.38;\r\n    rep.x -= 0.030;\r\n    float re = length(rep) / ed;\r\n    re = smoothstep(0.05, 0.06, re);\r\n\r\n    vec2 m = p;\r\n    m.y -= .31;\r\n    float a = -40.;\r\n    float b = 0.;\r\n    float c = 0.;\r\n    if(m.y <= -0.066) {\r\n      m.y = 1.;\r\n    }\r\n\r\n    float pb = abs(a * (m.x * m.x) + b * m.x + c - m.y);\r\n    pb = smoothstep(0.003, 0.004, pb * sound.x / 1.4);\r\n\r\n    float r = 0.3 + 0.15 * cos(atan(p.x, p.y) * 3. / sound.x);\r\n    float rr = smoothstep(r, r - 0.01, length(p));\r\n\r\n  vec3 col = vec3(.2, .5, 1.);\r\n    col *= (rr / (r * 2.));\r\n    col *= le;\r\n    col *= re;\r\n    col *= pb;\r\n\r\n    if(uv.y <= 0.25) {\r\n        col = vec3(0.);\r\n    }\r\n\r\n    fragColor = vec4(col,1.0);\r\n}"},{id:"Xd3GRX",name:"Audio Visualizer - Raymarching by Lallis",shader:"// https://www.shadertoy.com/view/Xd3GRX\r\n/*\r\n\tIf you have any ideas please let me know in the comments! :)\r\n\tEspecially if you have a better idea for the frequency distribution.\r\n\tRight now it's MAXF/2^(x/2) where x is a frequency band numbered from 0 to 15.\r\n\tIt would probably be smart to include more than a single frequency over each band.\r\n\r\n*/\r\n//Enable dithering\r\n#define ENABLEDITHER\r\n\r\n//Enable rotation\r\n//#define ENABLEROT\r\n\r\n//Enable zooming with beat (sucks ass)\r\n//#define ENABLEBEAT\r\n\r\n//Show only the back wall without perspective\r\n//#define FLAT\r\n\r\n//Enable waveform\r\n#define ENABLEWAVE\r\n\r\n//Waveform amplitude; adjust according to audio source volume\r\n#define WAVEAMP 1.0\r\n\r\n//Height for gradient middle color; set to 1.0 for 2 color gradient\r\n#define GRADVAL 0.8\r\n\r\n#define time iTime\r\n\r\n\r\nconst vec3 Color1 = vec3(0.25,0.625,0.625);\r\nconst vec3 Color2 = vec3(0.25,0.25,1.00); // TEAL->BLUE->RED\r\nconst vec3 Color3 = vec3(1.00,0.25,0.25);\r\n\r\n//Some color combinations\r\n\r\n/*const vec3 Color1 = vec3(0.25,1.00,0.25);\r\nconst vec3 Color2 = vec3(0.75,0.50,0.25); // GREEN->YELLOW->RED\r\nconst vec3 Color3 = vec3(1.00,0.25,0.25);*/\r\n\r\n/*const vec3 Color1 = vec3(0.00,0.00,0.00);\r\nconst vec3 Color2 = vec3(0.70,0.55,0.25); // BLACK->YELLOW->WHITE\r\nconst vec3 Color3 = vec3(0.5);*/\r\n\r\n/*const vec3 Color1 = vec3(0.25,0.25,1.00);\r\nconst vec3 Color2 = vec3(0.25,0.625,0.625); // BLUE->TEAL->WHITE\r\nconst vec3 Color3 = vec3(0.5);*/\r\n\r\n\r\n/*const vec3 Color1 = vec3(0.75); // WHITE\r\n//const vec3 Color1 = vec3(0.25,0.50,1.00); // LIGHT BLUE\r\nconst vec3 Color2 = Color1;\r\nconst vec3 Color3 = Color1;*/\r\n\r\nfloat noise(vec2 p)\r\n{\r\n\treturn fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nfloat noise3D(vec3 p)\r\n{\r\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453);\r\n}\r\n\r\n\r\nmat3 rot(vec3 ang)\r\n{\r\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\r\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\r\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\r\n\treturn x*y*z;\r\n}\r\n\r\nvec3 getCol(float v, vec3 col1, vec3 col2)\r\n{\r\n    v = clamp(v,0.0,1.0);\r\n    vec3 res = vec3(0.0);\r\n    for(int i = 0; i<3; i++)\r\n    {\r\n        res[i] = col1[i] + v * (col2[i] - col1[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat udBox( vec3 p, vec3 b )\r\n{\r\n  return length(max(abs(p)-b,0.0));\r\n}\r\n\r\nvec4 map(vec3 rp)\r\n{\r\n\tvec4 d = vec4(0.0);\r\n\r\n    vec3 bgCol = vec3(0.125,0.125,0.125);\r\n\r\n    #ifdef ENABLEWAVE\r\n    float waveF = texture(iChannel0, vec2((rp.x+1.8)/3.6, 0.75)).r;\r\n    float waveDist = udBox(rp-vec3(0.0,-waveF*WAVEAMP+WAVEAMP/2.0,0.25), vec3(1.8,0.02,0.001));\r\n    vec4 wave = vec4(vec3(0.3), waveDist);\r\n    #endif\r\n\r\n    float backWallDist = udBox(rp-vec3(0.0,0.0,0.75), vec3(1.8, 1.1, 0.5));\r\n    vec4 backWall = vec4(bgCol, backWallDist);\r\n\r\n    float edgeLeftDist = udBox(rp-vec3(1.9,0.0,0.3725), vec3(0.1,1.1,1.0));\r\n    vec4 edgeLeft = vec4(bgCol, edgeLeftDist);\r\n\r\n    float edgeRightDist = udBox(rp-vec3(-1.9,0.0,0.3725), vec3(0.1,1.1,1.0));\r\n    vec4 edgeRight = vec4(bgCol, edgeRightDist);\r\n\r\n    float edgeTopDist = udBox(rp-vec3(0.0,1.2,0.3725), vec3(2.0,0.1,1.0));\r\n    vec4 edgeTop = vec4(bgCol,edgeTopDist);\r\n\r\n    float edgeBotDist = udBox(rp-vec3(0.0,-1.2,0.3725), vec3(2.0,0.1,1.0));\r\n    vec4 edgeBot = vec4(bgCol,edgeBotDist);\r\n\r\n    d = edgeLeft.a > backWall.a ? backWall : edgeLeft;\r\n    d = edgeRight.a > d.a ? d : edgeRight;\r\n    d = edgeTop.a > d.a ? d : edgeTop;\r\n    d = edgeBot.a > d.a ? d : edgeBot;\r\n\r\n    #ifdef ENABLEWAVE\r\n    d = wave.a > d.a ? d : wave;\r\n    #endif\r\n\r\n    return d;\r\n\r\n}\r\n\r\nvec3 normal(vec3 rp)\r\n{\r\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\r\n\treturn normalize( vec3(\r\n           map(rp+eps.xyy).a - map(rp-eps.xyy).a,\r\n           map(rp+eps.yxy).a - map(rp-eps.yxy).a,\r\n           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );\r\n\r\n}\r\n\r\nfloat light(vec3 lp, vec3 rp, vec3 n, float pulse)\r\n{\r\n    return (1.5*(pulse+0.05)/pow(distance(lp,rp),2.0))*max(dot(normalize(lp-rp), n), 0.0)*0.25;\r\n}\r\n\r\nfloat drawLight(vec3 lp, vec3 rd, vec3 ro, float td, float pulse)\r\n{\r\n    float res = 0.0;\r\n    if(td > distance(lp,ro))\r\n    {\r\n\t\tfloat dlp = length(cross(lp-ro, lp-(ro+rd)))/length((ro+rd)-ro);\r\n\t\tres=max(exp(-dlp*64.0*((1.0-pulse)+0.5)),0.0);\r\n    }\r\n    return res;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 p = 2.0*uv-1.0;\r\n    p.x*=iResolution.x/iResolution.y;\r\n    vec2 m = iMouse.xy/iResolution.xy;\r\n    m.x = iMouse.x == 0.0 ? 0.5 : iMouse.x/iResolution.x;\r\n    m = 2.0*m-1.0;\r\n    vec3 col = vec3(0.00);\r\n\r\n    float hArr[16];\r\n    for(int i = 0; i < 16; i++)\r\n    {\r\n     \thArr[i] = texture(iChannel0, vec2( 1.0/pow(2.0,float(i)*0.5)-0.001,0.25)).r;\r\n    }\r\n\r\n    float z = -0.5;\r\n\r\n    #ifdef ENABLEROT\r\n    z = -2.0*(sin(time*0.25)*0.5+0.5);\r\n    #endif\r\n    #ifdef ENABLEBEAT\r\n    z += -2.0*hArr[14];\r\n    #endif\r\n    vec3 ro = vec3(0.0,0.0,z-2.0);\r\n    #ifdef FLAT\r\n    ro = vec3(p/vec2(1.0,1.25), z-2.0);\r\n    #endif\r\n    vec3 rd = normalize( vec3(p, z) - ro );\r\n\r\n    vec3 ang = vec3( 0.0, 0.0 , 0.0);\r\n    #ifdef ENABLEROT\r\n    ang = vec3(1.54*sin(time*0.125)*0.25, 1.54*cos(time*0.25)*0.25, 0.0);\r\n    #endif\r\n    ro*=rot(ang);\r\n    rd*=rot(ang);\r\n\r\n    vec3 rp = vec3(0.0);\r\n\r\n    vec4 d = vec4(0.0);\r\n    float td = 0.5;\r\n\tfloat dMax = 25.0;\r\n\r\n    for(int i = 0; i < 64; i++)\r\n    {\r\n        if(td >= dMax) break;\r\n        rp = ro+rd*td;\r\n     \td = map(rp);\r\n        if(d.a < 0.001)\r\n        {\r\n         \tbreak;\r\n        }\r\n        td += d.a*0.75;\r\n    }\r\n\r\n    vec3 lp[16];\r\n\r\n    for(int i = 0; i < 16; i++)\r\n    {\r\n     \tlp[i] = vec3( (7.5-float(i))*0.2125, hArr[i]*2.0-1.0, 0.0);\r\n    }\r\n\r\n    float g = 1.0/(1.0-GRADVAL);\r\n    float r = 1.0/GRADVAL;\r\n\r\n    vec3 lc[16];\r\n\r\n    for(int i = 0; i < 16; i++)\r\n    {\r\n     \tlc[i] = getCol((hArr[i]-GRADVAL)*g, getCol(hArr[i]*r, Color1, Color2), Color3);\r\n    }\r\n\r\n    vec3 n = normal(rp);\r\n    if(d.a < 0.001)\r\n    {\r\n\r\n        vec3 illumination = vec3(0.01);\r\n\r\n        for(int i = 0; i < 16; i++)\r\n        {\r\n         \tillumination += lc[i] * light(lp[i], rp, n, hArr[i] );\r\n        }\r\n\r\n     \tcol = d.rgb*illumination;\r\n    }\r\n\r\n    for(int i = 0; i < 16; i++)\r\n    {\r\n     \tcol += lc[i] * drawLight(lp[i], rd, ro, td, hArr[i] );\r\n    }\r\n\r\n    col = clamp(col, 0.0, 1.0);\r\n\r\n    col = pow(col, vec3(0.45)); //gamma adjust\r\n\r\n    float f = 8.0;\r\n    col = (1.0/(1.0+exp(4.0-f*col))-0.0003)/(0.982-0.018); //contrast\r\n    p.x/=iResolution.x/iResolution.y;\r\n    col *= smoothstep( 1.325, 0.825, abs(p.x) ); //dark edges\r\n    col *= smoothstep( 1.325, 0.825, abs(p.y) );\r\n\r\n    #ifdef ENABLEDITHER\r\n    float dither = 4.0/256.0;\r\n\r\n   \tcol += (noise3D(vec3(p,fract(time)))*2.0-1.0)*dither;\r\n    #endif\r\n\r\n\tfragColor = vec4(col,1.0);\r\n}\r\n"},{id:"XsX3zS",name:"Sound sinus wave by Eitraz",shader:"// https://www.shadertoy.com/view/XsX3zS\r\n#define WAVES 8.0\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\r\n\r\n\tfloat time = iTime * 1.0;\r\n\r\n\tvec3 color = vec3(0.0);\r\n\r\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\r\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 7.0;\r\n\r\n\t\tvec2 p = vec2(uv);\r\n\r\n\t\tp.x += i * 0.04 + freq * 0.03;\r\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\r\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\r\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 1.75 * intensity) * (3.0 / WAVES);\r\n\t}\r\n\r\n\tfragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"Xd3yWB",name:"Speaker by felipunkerito",shader:"// https://www.shadertoy.com/view/Xd3yWB\r\n#define EPS 0.0001\r\n#define FAR 100.0\r\n#define STEPS 2000\r\n\r\nfloat trig( float dist, float decay, float frequency, float amplitude, float speed )\r\n{\r\n\r\n\treturn exp( -decay * dist ) *\r\n   \t\t   sin( dist * frequency + ( speed ) ) * amplitude;\r\n\r\n}\r\n\r\nfloat hash( float n )\r\n{\r\n\r\n    return fract( sin( n ) * 45843.349 );\r\n\r\n}\r\n\r\nfloat noise( in vec3 x )\r\n{\r\n\r\n    vec3 p = floor( x );\r\n    vec3 k = fract( x );\r\n\r\n    k *= k * k * ( 3.0 - 2.0 * k );\r\n\r\n    float n = p.x + p.y * 57.0 + p.z * 113.0;\r\n\r\n    float a = hash( n );\r\n    float b = hash( n + 1.0 );\r\n    float c = hash( n + 57.0 );\r\n    float d = hash( n + 58.0 );\r\n\r\n    float e = hash( n + 113.0 );\r\n    float f = hash( n + 114.0 );\r\n    float g = hash( n + 170.0 );\r\n    float h = hash( n + 171.0 );\r\n\r\n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\r\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\r\n                     k.z\r\n    \t\t\t\t );\r\n\r\n    return res;\r\n\r\n}\r\n\r\nfloat fbm( in vec3 p )\r\n{\r\n\r\n    float f = 0.0;\r\n    f += 0.5000 * noise( p ); p *= 2.02;\r\n    f += 0.2500 * noise( p ); p *= 2.03;\r\n    f += 0.1250 * noise( p ); p *= 2.01;\r\n    f += 0.0625 * noise( p );\r\n    f += 0.0125 * noise( p );\r\n    return f / 0.9375;\r\n\r\n}\r\n\r\nfloat map( vec3 p )\r\n{\r\n\r\n    float dis = length( p );\r\n    float dec = 0.01;\r\n    float fre = 5.0;\r\n    float amp = 2.1;\r\n    float spe = ( texture( iChannel0, vec2( 0.0, 0.25 ) ).x );\r\n    float tri = trig( dis, dec, fre, amp, spe );\r\n    return length( p ) - 0.0 + tri;\r\n\r\n}\r\n\r\nvec3 grad( vec3 p )\r\n{\r\n\r\n    vec2 e = vec2( 0.0, EPS );\r\n    return vec3( map( p + e.xyy ) - map( p - e.xyy ),\r\n                 map( p + e.yxy ) - map( p - e.yxy ),\r\n                 map( p + e.yyx ) - map( p - e.yyx )\r\n                );\r\n\r\n}\r\n\r\nfloat softShadows( in vec3 ro, in vec3 rd )\r\n{\r\n\r\n\tfloat res = 1.0;\r\n    for( float t = 0.1; t < 8.0; ++t )\r\n    {\r\n\r\n        float h = map( ro + rd * t );\r\n        if( h < EPS ) return 0.0;\r\n        res = min( res, 8.0 * h / t );\r\n        t += h;\r\n\r\n    }\r\n\r\n    return res;\r\n\r\n}\r\n\r\nvec3 shade( vec3 ro, vec3 rd, float t )\r\n{\r\n\r\n\r\n    vec3 p = ro + rd * t;\r\n    vec3 n = normalize( grad( p ) );\r\n    vec3 col;\r\n    vec3 lig = normalize( vec3( 0.3, 0.8, 0.7 ) );\r\n    vec3 ref = reflect( rd, lig );\r\n\r\n    float wav = ( texture( iChannel0, vec2( 0.0, 0.25 ) ).x );\r\n    float amb = 0.5 + 0.5 * n.y;\r\n    float sha = softShadows( p, lig );\r\n    float dif = max( 0.0, dot( n, lig ) );\r\n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 16.0 );\r\n\r\n    col += vec3( 0.8, 0.7, 0.8 ) * amb;\r\n    col += dif * vec3( 0.8, 0.7, 0.8 ) * sha;\r\n    col += 1.0 * spe;\r\n    col *= mix( vec3( 0.2, 0.4, 0.6 ), vec3( 0.4, 0.2, 0.2 ), fbm( p + iTime + wav ) );\r\n    return col;\r\n\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\r\n\r\n    //vec3 ro = 3.0 * vec3( sin( iTime ), 0.0, cos( iTime ) );\r\n    //vec3 rd = normalize( vec3( uv, -1.0 ) );\r\n    vec3 ro = vec3( 0.0, 0.0, 3.0 );\r\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\r\n    vec3 vv = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\r\n    vec3 uu = normalize( cross( ww, vv ) );\r\n    vec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\r\n\r\n    float t = 0.0; float d = EPS;\r\n    for( int i = 0; i < STEPS; ++i )\r\n    {\r\n\r\n        d = map( ro + rd * t );\r\n        if( d < EPS || t > FAR ) break;\r\n        t += d;\r\n\r\n    }\r\n\r\n    // Time varying pixel color\r\n    vec3 col = d < EPS ? shade( ro, rd, t ) : vec3( 0.0 );\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n}\r\n"},{id:"XllSzB",name:"Cylon's Jam by jayjayjay",shader:"// https://www.shadertoy.com/view/XllSzB\r\n// Created by Jason Yung - jayjayjay/2015\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n\r\n#define time iTime/1.\r\n#define cTime iChannelTime[0]/50.\r\n\r\n#define AUDIO_LEN 75.0\r\n#define ZOOM (sin(iChannelTime[0]/AUDIO_LEN)+.1)*2.\r\nconst float baseLvl = 2.0;\r\nconst int steps = 10;\r\nconst float step = \t1.0/float(steps);\r\n\r\nconst float stretch = 1.5;\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float third = 1.0 / pow( 3., baseLvl);\r\n    float cScalar = 1.0;\r\n\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    uv -= .5;\r\n    uv *= ZOOM;\r\n\r\n    float absX = abs(uv.x);\r\n    float absY = abs(uv.y);\r\n\r\n    // first texture row is frequency data\r\n    float fft  = texture( iChannel0, vec2(abs(absX)*2.0,0.25) ).x;\r\n\r\n    // second texture row is the sound wave\r\n    float wave = texture( iChannel0, vec2(abs(absX -.5)*2.0,0.75) ).x; //-.5 to center\r\n\r\n    //small = zoom out\r\n    float step = 1.0/float(wave*(sin(time)+2.0)*10.0);\r\n\r\n    //make it wider and smaller\r\n    float t = sin(cTime)*stretch;\r\n\r\n    third /= pow( 3., pow(t,2.0));\r\n\r\n    for(int i = 0; i< steps; i++) {\r\n        float y = float(i) * step;\r\n        if(y > absY) {\r\n            break; //dont iterate past uv.y\r\n        }\r\n    \tcScalar = mod( floor( (abs(uv.x)) / third) + 1.0, 2.0 );\r\n        if(cScalar == 0.0) {\r\n            break;\r\n        }else{\r\n        \tthird /= 3.0;\r\n        }\r\n    }\r\n\r\n    float w = absY / step;\r\n    float lvl = floor(w);\r\n    float diff = w-lvl;\r\n\r\n    float freqScalar = 1.0-fft;\r\n\r\n   //loat lvlScalar = 1.0-uv.y;\r\n    float lvlScalar = 1.0;\r\n\r\n    float scalar = 10.;\r\n    float z = 1.0 - abs(diff-.5) * (freqScalar * lvlScalar) * scalar; //for centering in row, remember that diff is proportional (0<diff<1) ! since w and lvl are!\r\n    //z = 1.0-z; //invert ratio\r\n\r\n    float b = (lvl+1.0)/float(steps);\r\n\r\n    fragColor = vec4(1.0-b,b,abs(.5-b),1.0) * cScalar * z;\r\n\r\n}\r\n"},{id:"MtB3zd",name:"Radial Sound Visualizer by tholzer",shader:"// https://www.shadertoy.com/view/MtB3zd\r\n//-----------------------------------------------------\r\n// Radial Sound Visualizer                     5/2015\r\n// Based on 'Input-Sound' by IQ\r\n// now switch between 2 views\r\n//-----------------------------------------------------\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // create pixel coordinates\r\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\r\n\r\n    // for radial view click to left side,\r\n    // for xy view click to right side\r\n    if (iMouse.x / iResolution.x < 0.5)\r\n      uv = vec2( 2.0*length(uv-0.5), atan(abs(uv.y-0.5), abs(uv.x-0.5)) );\r\n\r\n    float value, fft, wave;\r\n    value = abs(uv.x-0.5);\r\n\r\n    // first texture row is frequency data\r\n\tfft  = texture( iChannel0, vec2(value,0.25) ).x;\r\n\r\n  \t// second texture row is the sound wave\r\n\twave = texture( iChannel0, vec2(value,0.75) ).x;\r\n\r\n\t// convert frequency to colors\r\n\tvec3 col = vec3( 4.0*fft*(1.0-fft)*(0.2+0.4*sin(iTime))\r\n                    , fft+0.3*sin(0.22*iTime)\r\n                    , 0.5-fft-0.4*sin(0.33*iTime) ) * fft;\r\n\r\n    // add wave form on top\r\n\tvalue = (uv.y < 1.0) ? uv.y : uv.y - 1.0;\r\n\tcol += 0.8 -  smoothstep( 0.0, 0.15, abs(wave - value) );\r\n\r\n\t// output final color\r\n\tfragColor = vec4(col,1.0);\r\n}\r\n"},{id:"wtdXzS",name:"Techno Core by Kali",shader:"// https://www.shadertoy.com/view/wtdXzS\r\nfloat det = .001;\r\nvec3 objcol=vec3(0.);\r\nfloat snd;\r\n\r\n\r\nmat2 rot(float a) {\r\n\tfloat s = sin(a), c = cos(a);\r\n    return mat2(c, s, -s, c);\r\n}\r\n\r\nfloat fractal(vec3 p) {\r\n    vec3 c = p;\r\n    float m = 100.;\r\n    for(int i = 0; i < 10; i++) {\r\n\t\tp=abs(p + 1.) - abs( p - 1.) - p;\r\n        p=p / clamp(dot(p,p), 0.1, 1.) - c;\r\n    \tm=min(m, abs(length(p) - 3.5));\r\n    }\r\n    m = max(0., 1. - m);\r\n    objcol = abs(p) * .6;\r\n    return m * m * (.2+snd);\r\n}\r\n\r\nfloat de(vec3 p) {\r\n    p.yz *= rot(iTime);\r\n    p.xz *= rot(.2);\r\n    float f = fractal(p);\r\n\tfloat d = length(p) - 3.5 + f * 1.5 - snd * 3.;\r\n    d = min(d, length(p.xy) - .25);\r\n\td = min(d, length(p.yz) - .25);\r\n\td = min(d, length(p.xz) - .25);\r\n    return (d - f * .5) * .5;\r\n}\r\n\r\nvec3 march(vec3 from, vec3 dir) {\r\n\tvec3 col = vec3(0.), p;\r\n    float td = 0., d;\r\n    for (int i = 0; i < 150; i++) {\r\n    \tp = from + td * dir;\r\n\t\td = de(p);\r\n        td += max(det, abs(d));\r\n\t\tif (td > 20.) break;\r\n        col += objcol * exp(-.005 * td * td);\r\n    }\r\n    vec3 rescol = col * .01 * (.3 + snd * 1.5);\r\n    return rescol;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    snd = texture(iChannel0,vec2(.15)).r;\r\n    vec2 p = (fragCoord - iResolution.xy * .5) / iResolution.y;\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n    vec3 dir = normalize(vec3(p, .7));\r\n    float t = iTime*.5;\r\n    vec3 from = vec3(sin(t) * 2., 0., -10.);\r\n    from.xz *= rot(t);\r\n    dir.xz *= rot(t);\r\n\tdet += max(0. ,5. - iTime)*.02;\r\n    vec3 col = march(from, dir);\r\n    col += pow(abs(.5 - fract(dir.x * 20.)) * 2., 10.) * .2;\r\n    col += pow(abs(.5 - fract(dir.y * 20.)) * 2., 10.) * .2;\r\n    float spec = pow(texture(iChannel0, vec2(floor(dir.x*20.)/20. * .5 + .5, .1)).r,2.);\r\n\tvec2 sq = abs(.5-fract(dir.xy*20.));\r\n    col+=abs(1.-length(max(vec2(0.),abs(sq.xy)-.1)))*step(dir.y+.4,spec)*length(fract(dir.xy*10.))*.4;\r\n    col=max(col, vec3(.5, .2, 0.) - smoothstep(0.,.03,abs(dir.y - spec + .35)));\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"clG3RR",name:"Year of Truchets #018 by byt3_m3chanic",shader:"// https://www.shadertoy.com/view/clG3RR\r\n/**\r\n\r\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n\r\n    Year of Truchets #018\r\n    05/06/2023  @byt3_m3chanic\r\n\r\n    All year long I'm going to just focus on truchet tiles and the likes!\r\n    Truchet Core \\M/->.<-\\M/ 2023\r\n\r\n    Thanks to @Shane for his path shaders!\r\n    https://www.shadertoy.com/view/MlXSWX\r\n\r\n    good song choices\r\n    https://soundcloud.com/trybesof/tim-green-battle-illusion\r\n    https://soundcloud.com/trybesof/tim-green-pyxis\r\n\r\n*/\r\n\r\n#define R          iResolution\r\n#define M          iMouse\r\n#define T          iTime\r\n#define PI         3.141592653\r\n#define PI2        6.283185307\r\n\r\n#define MAX_DIST   50.\r\n#define MIN_DIST   1e-3\r\n\r\nfloat sampleFreq(float freq) { return texture(iChannel0, vec2(freq, .25)).x; }\r\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\r\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(27.609, 57.583)))*43758.5453); }\r\n\r\n//@iq SDF's\r\nfloat box( vec3 p, vec3 b ) {\r\n  vec3 q = abs(p) - b;\r\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\nfloat trs( vec3 p,vec2 t){\r\n    vec2 q = vec2(length(p.zx)-t.x,p.y);\r\n    return length(q)-t.y;\r\n}\r\n\r\n//@Shane - path function\r\nvec2 path(in float z){\r\n    vec2 p1 =vec2(2.38*sin(z * .15)+5.38*cos(z * .15), 3.4*cos(z * .0945));\r\n    vec2 p2 =vec2(3.2*sin(z * .179),4.31*sin(z * .127));\r\n    return (p1 - p2)*.3;\r\n}\r\n\r\n//@MercurySexy\r\nvec2 pModPolar(inout vec2 p) {\r\n    float angle = 0.26179938779;//0.52359877559;//hardcoded for speed 2.*PI/24;\r\n    float a = atan(p.y, p.x) + angle/2.,\r\n          r = length(p),\r\n          c = floor(a/angle);\r\n    a = mod(a,angle) - angle/2.;\r\n    p = vec2(cos(a), sin(a))*r;\r\n    if (abs(c) >= (12.)) c = abs(c);\r\n    return vec2(c,angle);\r\n}\r\n\r\nfloat time=0.,tspeed=0.,glow = 0.,gwave=0.;\r\nvec3 hp,hit,lp = vec3(0.);\r\nvec2 gid,sid;\r\nmat2 rxa,rxb;\r\n\r\nconst float sz = 1.;\r\nconst float hf = .5;\r\n\r\nvec2 map (in vec3 pos, float sg) {\r\n \tvec2 res = vec2(1e5,0);\r\n \tvec3 p = pos;\r\n\r\n\r\n \tvec2 tun = p.xy - path(p.z);\r\n    vec3 px = vec3(tun+vec2(0.,-.1),pos.z+tspeed+5.+gwave);\r\n    vec3 q = vec3(tun,p.z);\r\n\r\n    float iz = floor((q.z+hf)/sz);\r\n    q.z = mod(q.z+hf,sz)-hf;\r\n    vec3 r = q;\r\n    r.xz*=1.15;\r\n    float zhs=hash21(vec2(iz,0.));\r\n    if(zhs<.75) r.xy *= rxa;\r\n    if(zhs>.95) r.xy *= rxb;\r\n    vec2 id = pModPolar(r.xy);\r\n    r -= vec3(4.1,0,0);\r\n    r.xy *= rot(id.y*6.);\r\n\r\n    vec2 mid = vec2(id.x,iz);\r\n    float hs = hash21(mid);\r\n\r\n    if(hs>.5) r.xz*=rot(1.5707);\r\n    float ct = box(r,vec3(hf,.015,hf));\r\n    float tk = .125;\r\n\r\n\r\n    float d = min(\r\n    trs(r-vec3(hf,0,-hf),vec2(hf,tk)),\r\n    trs(r-vec3(-hf,0,hf),vec2(hf,tk))\r\n    );\r\n\r\n    if(hs>.75) d = min(length(r.yz)-tk,length(r.yx)-tk);\r\n    if (hs>.9) d = min(length(abs(r.xz)-vec2(hf,0))-tk,length(r.yx)-tk);\r\n    d = max(ct,d);\r\n    if(d<res.x) {\r\n        res = vec2(d,1.);\r\n        hit=q;\r\n        sid=mid;\r\n    }\r\n\r\n    float ns = sampleFreq(.01)*.5;\r\n    float nx = sampleFreq(.4)*PI2;\r\n    float nr = sampleFreq(.75)*PI2;\r\n    float b=length(px)-(.001+ns);\r\n    px.xz *= rot(nx);\r\n    px = abs(px.xzy)-.3;\r\n    px.zy *= rot(-nr);\r\n    b = min(trs(px,vec2(.2+ns,.01)),b);\r\n\r\n    if(sg==1.) { glow += .001/(.0002+b*b);}\r\n\r\n    if(b<res.x) {\r\n        res = vec2(b,1.);\r\n        hit=px;\r\n        sid=vec2(0);\r\n    }\r\n\r\n    res.x /=1.15;\r\n \treturn res;\r\n}\r\n\r\nvec3 normal(vec3 p, float t) {\r\n    t*=MIN_DIST;\r\n    float d = map(p,0.).x;\r\n    vec2 e = vec2(t,0);\r\n    vec3 n = d - vec3(\r\n        map(p-e.xyy,0.).x,\r\n        map(p-e.yxy,0.).x,\r\n        map(p-e.yyx,0.).x\r\n        );\r\n    return normalize(n);\r\n}\r\n\r\n//@iq of hsv2rgb\r\nvec3 hsv2rgb( in vec3 c ) {\r\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\r\n    return c.z * mix( vec3(1), rgb, c.y);\r\n}\r\n\r\nvoid mainImage( out vec4 O, in vec2 F )\r\n{\r\n    // precal\r\n    time = iTime;\r\n    tspeed = time*3.85;\r\n    gwave = 7.75+5.*sin(time*.1);\r\n    rxa=rot(T*.3);\r\n    rxb=rot(-T*.25);\r\n\r\n    vec3 C =vec3(0);\r\n\r\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\r\n\r\n    vec3 ro = vec3(0,0,.1);\r\n    vec3 rd = normalize(vec3(uv,-1.));\r\n\r\n    // mouse //\r\n    float x = M.xy==vec2(0) && M.z<1. ? 0. : -(M.y/R.y*.5-.25)*PI;\r\n    float y = M.xy==vec2(0) && M.z<1. ? 0. : -(M.x/R.x*2.-1.)*PI;\r\n    if(M.z>0.){\r\n        mat2 rx = rot(x), ry = rot(y);\r\n        ro.zy *= rx; ro.xz *= ry;\r\n        rd.zy *= rx; rd.xz *= ry;\r\n    }\r\n\r\n    ro.z -= tspeed;\r\n    ro.xy += path(ro.z);\r\n\r\n    // center tracking\r\n    rd.xy = rot( (.2*sin(time*.3))-path(lp.z).x/ 24. )*rd.xy;\r\n    rd.xz = rot( path(lp.z+1.).y/ 14. )*rd.xz;\r\n\r\n    float d,m;\r\n    vec3 p = vec3(0);\r\n\r\n    for(int i=0;i<255;i++) {\r\n        p=ro+rd*d;\r\n        vec2 ray = map(p,1.);\r\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\r\n        d+= i>75? ray.x*.65 : ray.x * .2;\r\n        m = ray.y;\r\n    }\r\n    gid=sid;\r\n\r\n    if(d<MAX_DIST) {\r\n        vec3 n = normal(p,d);\r\n\r\n        vec3 lpos = rd;\r\n        lpos.z-=tspeed;\r\n        lpos.xy+=path(lpos.z);\r\n        vec3 l = normalize(lpos-p);\r\n        float diff = clamp(dot(n,l),.001,.9);\r\n\r\n        vec3 h = vec3(.1);\r\n\r\n        float hs = hash21(gid);\r\n        if(hs<.65) h = hsv2rgb(vec3(p.z*.05,1.,.5));\r\n\r\n        C = h *diff;\r\n\r\n    }\r\n\r\n    C = mix(vec3(.001),C, exp(-.00004*d*d*d));\r\n    C = mix(C,vec3(.9),clamp(glow*.5,0.,1.));\r\n    C = pow(C, vec3(.4545));\r\n    O = vec4(C,1.);\r\n}\r\n"},{id:"fsK3D1",name:"Purple spaghetti event horizon by wzdd",shader:"// https://www.shadertoy.com/view/fsK3D1\r\nconst float period = 6.0;\r\nconst float PI = 3.1415;\r\nfloat id;\r\n\r\nbool multicol = false;\r\n\r\nvec3 palette(float idx) {\r\n    return vec3(cos(2.1 * PI * idx), cos(2.2 * PI * idx), cos(2. * PI * idx));\r\n}\r\n\r\nfloat SDF_sphere(vec3 point, float intensity)\r\n{\r\n    point.z += (intensity * 2.) + sin(iTime) * 0.05;\r\n    float sphere = length(point) - .8;\r\n    return sphere;\r\n}\r\n\r\nfloat SDF_cylinder(vec3 point, float intensity)\r\n{\r\n    point.x = mod(point.x, period) - (period * 0.5);\r\n    point.y = abs(point.y) - 8.;\r\n\r\n    point.x += sin(point.z * id * 0.2 + iTime);\r\n    point.y += sin(point.z * id * 0.1 + iTime);\r\n\r\n    float cylinder = length(point.xy) - 0.6;\r\n    return cylinder;\r\n}\r\n\r\nfloat SDF(vec3 point, float intensity) {\r\n    id = floor(point.x / period);\r\n\r\n    float sphere = SDF_sphere(point, intensity);\r\n    float cylinder = SDF_cylinder(point, intensity);\r\n\r\n    if (cylinder < sphere) {\r\n        multicol = true;\r\n        return cylinder;\r\n    } else {\r\n        multicol = false;\r\n        return sphere;\r\n    }\r\n}\r\n\r\nfloat doSound(in vec2 fragCoord)\r\n{\r\n    // credit https://www.shadertoy.com/view/Xds3Rr\r\n\r\n    // Fetch sound data\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    int tx = int(uv.x * 512.0);\r\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x;\r\n\r\n    return fft;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    float intensity = doSound(fragCoord);\r\n\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord / iResolution.xy;\r\n\r\n    // Normalised pixel coordinates (from -1 to 1, taking into account aspect ratio)\r\n    vec2 centered_uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\r\n\r\n    // Background\r\n    vec3 col = vec3(0., 0., 0.);\r\n\r\n    // Camera\r\n    vec3 ray_origin = vec3(0., 0., -3.);\r\n\r\n    // Frustrum\r\n    vec3 ray_direction = normalize(vec3(centered_uv, 1.));\r\n\r\n    // The point we're at, starting at the camera.\r\n    vec3 point = ray_origin;\r\n\r\n    // Walk along the ray.\r\n    for(float i = 0.; i < 64.; i++) {\r\n        float dist = SDF(point, intensity);\r\n\r\n        if(dist < 0.0001) {\r\n            // We hit it (or close enough)\r\n            float shade = 1. - (i / 64.);\r\n            if(multicol) {\r\n                col = palette(id) * shade;\r\n            } else {\r\n                col = vec3(shade);\r\n            }\r\n            break;\r\n        }\r\n\r\n        point += (dist * ray_direction);\r\n    }\r\n\r\n    // Output to screen\r\n    fragColor = vec4(col,1.0);\r\n\r\n\r\n\r\n\r\n}\r\n"},{id:"ft2SWW",name:"Music_Spheres by Liners",shader:"// https://www.shadertoy.com/view/ft2SWW\r\n\r\nfloat stepping(float t){\r\n    if(t<0.)return -1.+pow(1.+t,2.);\r\n    else return 1.-pow(1.-t,2.);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\r\n    fragColor = vec4(0.);\r\n    uv = normalize(uv) * length(uv);\r\n    for(int i=0;i<10;i++){\r\n        float t = iTime + float(i)+(5.+1.*stepping(cos(iTime*3.)));\r\n        vec2 p = vec2((cos(t+iResolution.x)*(iMouse.x / iResolution.x)*2. , sin(t+iResolution.y)*(iMouse.y / iResolution.y)*2.), (sin(iResolution.x * .0005 + iResolution.y),cos(iResolution.y * .0005 + iResolution.x)));\r\n        p *= cos(iTime + float(i)*3.141592*cos(iTime/10.));\r\n        vec3 col = cos(vec3(0,1,-1)*3.141592*2./3.+3.141925*(iTime/2.+float(i)/9.)) * 0.5 + 0.5;\r\n        int tx = int(p.x);\r\n        float react = texelFetch( iChannel0, ivec2(tx,0), 0 ).x;\r\n\r\n        fragColor += vec4(0.025 * react * 5.25/length(uv-p*1.5-react*.005)*col,1.0);\r\n    }\r\n\r\n    // fragColor.xyz = pow(fragColor.xyz,vec3(3.));\r\n    // fragColor.w = 0.0;\r\n    fragColor = vec4(pow(fragColor.xyz,vec3(3.)), 0.0);\r\n}\r\n"},{id:"wtffDl",name:"Shadow dancing by bwestlin",shader:"// https://www.shadertoy.com/view/wtffDl\r\n#define SHOW_LIGHTS 1\r\n#define LIGHT_SIZE  0.2\r\n\r\n#define M_NONE\t\t0.0\r\n#define M_FLOOR\t\t1.0\r\n#define M_SPHERE\t2.0\r\n#define M_SPHERE2\t3.0\r\n#define M_L1\t\t4.0\r\n#define M_L2\t\t5.0\r\n\r\nfloat m(float i) {\r\n    return texture(iChannel0, vec2(i, 0.0)).x * 2.0;\r\n}\r\n\r\nvec3 camera(vec2 uv, vec3 origin, vec3 target) {\r\n    vec3 forward = normalize((target - origin) * vec3(1.0, 1.0, 2.5));\r\n\tvec3 side = cross(forward, vec3(0.0, 1.0, 0.0));\r\n\tvec3 up = cross(side, forward);\r\n\tvec3 rayDir = forward + uv.x * side + uv.y * up;\r\n\treturn normalize(rayDir);\r\n}\r\n\r\nfloat sdSphere( vec3 p, float s ) {\r\n\treturn length(p) - s;\r\n}\r\n\r\nfloat sdPlane(vec3 p, vec4 n) {\r\n\treturn dot(p, n.xyz) + n.w;\r\n}\r\n\r\n// Smooth minimum : https://iquilezles.org/articles/smin\r\nfloat smin(float a, float b, float k) {\r\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\r\n    return mix(b, a, h) - k * h * (1.0 - h);\r\n}\r\n\r\nfloat smin08( float a, float b) {\r\n    return smin(a, b, 0.8);\r\n}\r\n\r\nvec3 l1pos() {\r\n    return vec3((-3.0 + m(0.1)) * cos(iTime), m(0.6), -5.0);\r\n}\r\n\r\nvec3 l2pos() {\r\n    return vec3((3.0 + m(0.2)) * cos(iTime), m(0.5), -5.0);\r\n}\r\n\r\nvec2 map(vec3 p, bool lights) {\r\n    float sphere = sdSphere(p - vec3(0.0, sin(iTime) * 0.2 * m(0.2) * 5.0, -3.0), 1.0);\r\n    float plane = sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));\r\n\r\n    float sphere2 = smin08(\r\n        sdSphere(p - vec3( 1.5, -1.0 + sin(iTime * 4.0) * 0.2, -2.5), 1.0),\r\n        sdSphere(p - vec3(-1.5,-1.0 + sin(iTime * 4.0 + 3.14) * 0.2, -2.5), 1.0)\r\n    );\r\n\r\n    #if (SHOW_LIGHTS == 0)\r\n    lights = false;\r\n    #endif\r\n    float l1 = lights ? sdSphere(p - l1pos(), LIGHT_SIZE) : 100000.0;\r\n    float l2 = lights ? sdSphere(p - l2pos(), LIGHT_SIZE) : 100000.0;\r\n\r\n    float d = min(min(smin08(sphere2, smin08(sphere, plane)), l1), l2);\r\n\r\n    if (d == sphere) return vec2(d, M_SPHERE);\r\n    if (d == sphere2)return vec2(d, M_SPHERE2);\r\n    if (d == plane)  return vec2(d, M_FLOOR);\r\n    if (d == l1)  return vec2(d, M_L1);\r\n    if (d == l2)  return vec2(d, M_L2);\r\n\r\n    return vec2(d, M_NONE);\r\n}\r\n\r\nvec3 normal(vec3 p) {\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float x = map(p, true).x;\r\n    return normalize(vec3(\r\n        map(p + eps.xzz, true).x - x,\r\n        map(p + eps.zxz, true).x - x,\r\n        map(p + eps.zzx, true).x - x\r\n    ));\r\n}\r\n\r\nvec2 intersect(vec3 origin, vec3 rayDir) {\r\n    float eps = 0.01;\r\n    float maxDistance = 100.0;\r\n    float t = 0.0;\r\n\r\n    vec2 dm = vec2(0.1, M_NONE);\r\n\r\n    for (int i = 0; i < 200; i++) {\r\n        t += dm.x;\r\n        dm = map(t * rayDir + origin, true);\r\n\r\n        if (abs(dm.x) <= eps) {\r\n            break;\r\n        }\r\n        if (t > maxDistance) {\r\n            return vec2(0.0, M_NONE);\r\n        }\r\n    }\r\n    return vec2(t, dm.y);\r\n}\r\n\r\n// Soft shadows: https://iquilezles.org/articles/rmshadows\r\nfloat shadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k) {\r\n    float res = 1.0;\r\n    for (float t = mint; t < maxt;) {\r\n        float h = map(ro + rd * t, false).x;\r\n        if (h < 0.001)\r\n            return 0.0;\r\n        res = min(res, k * h / t);\r\n        t += h;\r\n    }\r\n    return res;\r\n}\r\n\r\nfloat is_shadow(vec3 hit, vec3 lightpos) {\r\n    vec3 rayDir = normalize(lightpos - hit);\r\n    float maxDistance = abs(length(lightpos - hit));\r\n    return shadow(hit, rayDir, 0.1, maxDistance, 32.0);\r\n}\r\n\r\nvec3 diffuseLightning(vec3 n, vec3 lightDir, vec3 lightColor) {\r\n    float diffuse = dot(n, lightDir);\r\n    return lightColor * max(0.0, diffuse);\r\n}\r\n\r\nvec3 specularLightning(vec3 n, vec3 rayDir, vec3 lightDir, vec3 lightColor, float shininess) {\r\n    float ratio = dot(rayDir, -reflect(lightDir, n));\r\n\treturn lightColor * pow(max(0., ratio), shininess);\r\n}\r\n\r\nvec3 light(vec3 lightPos, vec3 lightColor, vec3 color, vec3 hit, vec3 n, vec3 rayDir) {\r\n    vec3 lightDir = normalize(hit - lightPos);\r\n    vec3 refLight = reflect(lightDir, n);\r\n\r\n    float dist = length(hit - lightPos);\r\n    float attenuation = (1.0 / (dist * dist)) * (sin(iTime) * 150.0 + 175.0);\r\n    lightColor *= attenuation;\r\n    color += diffuseLightning(n, refLight, lightColor) / 5.0;\r\n    color *= diffuseLightning(n, refLight, lightColor);\r\n    color += specularLightning(n, rayDir, lightDir, lightColor, 50.);\r\n    return color;\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n\r\n    vec3 cameraOrigin = vec3(-(sin(iTime * 0.2) * 3.0 + 2.0), sin(iTime * 0.33) * 3.0 + 2.0, 3.0) * (sin(iTime * 0.66) * 0.25 + 0.75);\r\n    vec3 cameraTarget = vec3(0.0, -3.0, 0.0);\r\n\r\n\tvec2 mPos = vec2(0.0);\r\n    if (iMouse.x > 0.0 && iMouse.y > 0.0) {\r\n        mPos = 2.0 * iMouse.xy / iResolution.xy - 1.0;\r\n    }\r\n\r\n    cameraTarget.xy -= mPos * 8.;\r\n\r\n    vec3 rayDir = camera(uv, cameraOrigin, cameraTarget);\r\n\r\n    vec3 color = vec3(0.0);\r\n\r\n    vec2 dm = intersect(cameraOrigin, rayDir);\r\n    float t = dm.x;\r\n    float material = dm.y;\r\n\r\n    if (t > 0.0) {\r\n        vec3 hit = cameraOrigin + t * rayDir;\r\n\r\n        vec3 n = normal(hit);\r\n        vec3 origColor = vec3(1.0, 0.5, 0.7);\r\n\r\n        vec3 l1color = vec3(sin(iTime * 2.1111) * 0.5 + 0.5, 0.5, sin(iTime * 5.1111) * 0.5 + 0.5);\r\n        vec3 l1 = light(l1pos(),\r\n                        l1color,\r\n                        origColor,\r\n                        hit,\r\n                        n,\r\n                        rayDir) * is_shadow(hit, l1pos());\r\n\r\n        vec3 l2color = vec3(sin(iTime * 8.1111) * 0.5 + 0.5, 0.5, sin(iTime * 1.333) * 0.5 + 0.5);\r\n        vec3 l2 = light(l2pos(),\r\n                        l2color,\r\n                        origColor,\r\n                        hit,\r\n                        n,\r\n                        rayDir) * is_shadow(hit, l2pos());\r\n\r\n        color = l1 + l2;\r\n\r\n        #if (SHOW_LIGHTS == 1)\r\n        if (material == M_L1) color = l1color * 5.0;\r\n        if (material == M_L2) color = l2color * 5.0;\r\n        #endif\r\n    }\r\n\r\n    fragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"MtKyDR",name:"Noise + Noise raymarching by DeadMan",shader:"// https://www.shadertoy.com/view/MtKyDR\r\n#define DISTANCE 50.0\r\n#define STEP 0.0\r\n#define STEPINC 0.00005\r\n#define SEED 10283.2\r\n#define PERSISTENCE 1.0\r\n#define SPEED 3.0\r\n#define BRIGHTNESS 1.0\r\n#define SPEC_POW 100.0\r\n#define SPEC_INTENSITY 10.0\r\n\r\nstruct Ray{\r\n    vec3 origin;\r\n    vec3 direction;\r\n};\r\n\r\nfloat hash(float n) { return fract(sin(n) * 1e4); }\r\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\r\n\r\n\r\nfloat noise(vec3 x) {\r\n\tconst vec3 Step = vec3(110, 241, 171);\r\n\r\n\tvec3 i = floor(x);\r\n\tvec3 f = fract(x);\r\n\r\n\t// For performance, compute the base input to a 1D hash from the integer part of the argument and the\r\n\t// incremental change to the 1D based on the 3D -> 1D wrapping\r\n    float n = dot(i, Step);\r\n\r\n\tvec3 u = f * f * (3.0 - 2.0 * f);\r\n\treturn mix(mix(mix( hash(n + dot(Step, vec3(0, 0, 0))), hash(n + dot(Step, vec3(1, 0, 0))), u.x),\r\n                   mix( hash(n + dot(Step, vec3(0, 1, 0))), hash(n + dot(Step, vec3(1, 1, 0))), u.x), u.y),\r\n               mix(mix( hash(n + dot(Step, vec3(0, 0, 1))), hash(n + dot(Step, vec3(1, 0, 1))), u.x),\r\n                   mix( hash(n + dot(Step, vec3(0, 1, 1))), hash(n + dot(Step, vec3(1, 1, 1))), u.x), u.y), u.z);\r\n}\r\n\r\nfloat getNoise(vec3 loc){\r\n    return noise(vec3(loc * PERSISTENCE) + vec3(SEED + texture(iChannel0, (loc.xy * 0.01) - vec2(0.5)) * 10.0)) * (length(loc.xy));\r\n}\r\n\r\nvec3 getNormal(vec3 pos){\r\n\tvec2 eps = vec2(1.0, 0.0);\r\n\r\n\tvec3 nor = vec3(getNoise(pos + eps.xyy) - getNoise(pos - eps.xyy),\r\n\t\t\tgetNoise(pos + eps.yxy) - getNoise(pos - eps.yxy),\r\n\t\t\tgetNoise(pos + eps.yyx) - getNoise(pos - eps.yyx));\r\n\treturn normalize(nor);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 UV = fragCoord / iResolution.xy;\r\n    vec2 screenPos = UV * 2.0 - vec2(1.0);\r\n\tvec3 camLoc = vec3(0, 0, iTime * SPEED);\r\n    vec3 calcDir = vec3(screenPos.x, screenPos.y * (iResolution.y / iResolution.x), 1.0);\r\n\r\n    Ray mainRay;\r\n    mainRay.origin = camLoc;\r\n    mainRay.direction = calcDir;\r\n\r\n    float dist = 0.0;\r\n\r\n    float brightness = 0.0;\r\n\r\n    float stepDist = STEP;\r\n    vec3 location;\r\n\r\n    for(float t = 0.0; t < DISTANCE; t += stepDist){\r\n        location = mainRay.origin + (mainRay.direction * t);\r\n        if(getNoise(location) > 0.99){\r\n            /*while(getNoise(location) > 0.5){\r\n                t -= 0.01;\r\n                location = mainRay.origin + (mainRay.direction * t);\r\n            }*/\r\n            dist = t / DISTANCE;\r\n            vec3 norm = getNormal(location);\r\n\r\n            vec3 dirToCam = normalize(location - camLoc);\r\n\r\n            brightness = clamp(dot(dirToCam, norm), 0.0, 1.0);\r\n\r\n            vec3 refVec = reflect(norm, dirToCam);\r\n\r\n            float spec = pow(clamp(-dot(refVec, dirToCam), 0.0, 1.0), SPEC_POW) * SPEC_INTENSITY;\r\n\r\n            brightness += spec;\r\n\r\n            brightness *= 1.0 / (t);\r\n\r\n            brightness *= BRIGHTNESS;\r\n\r\n            break;\r\n        }\r\n        stepDist += STEPINC;\r\n    }\r\n\r\n    vec3 color = 0.5 + 0.5*cos((iTime*2.0)+location+vec3(0,2,4));\r\n\r\n    // Output to screen\r\n    //fragColor = vec4(snoise(vec4(UV * PERSISTENCE, 1023.0, 210.4)));\r\n    fragColor = vec4(brightness * color, 1.0);\r\n}\r\n"},{id:"XsXfzN",name:"Fractal Brownian Motion Techno by DonKarlssonSan",shader:"// https://www.shadertoy.com/view/XsXfzN\r\n// Simplex 2D noise\r\n// from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\r\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\r\n\r\nfloat snoise(vec2 v){\r\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\r\n           -0.577350269189626, 0.024390243902439);\r\n  vec2 i  = floor(v + dot(v, C.yy) );\r\n  vec2 x0 = v -   i + dot(i, C.xx);\r\n  vec2 i1;\r\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\r\n  vec4 x12 = x0.xyxy + C.xxzz;\r\n  x12.xy -= i1;\r\n  i = mod(i, 289.0);\r\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\r\n  + i.x + vec3(0.0, i1.x, 1.0 ));\r\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\r\n    dot(x12.zw,x12.zw)), 0.0);\r\n  m = m*m ;\r\n  m = m*m ;\r\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\r\n  vec3 h = abs(x) - 0.5;\r\n  vec3 ox = floor(x + 0.5);\r\n  vec3 a0 = x - ox;\r\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\r\n  vec3 g;\r\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\r\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n  return 130.0 * dot(m, g);\r\n}\r\n\r\n// Fractal Brownian Motion from https://www.shadertoy.com/view/lsl3RH\r\n// By inigo quilez\r\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\r\nfloat fbm(vec2 p)\r\n{\r\n    float f = 0.0;\r\n    f += 0.5000 * snoise(p);\r\n    p = m*p*2.02;\r\n    f += 0.2500 * snoise(p);\r\n    p = m*p*2.03;\r\n    f += 0.1250 * snoise(p);\r\n    p = m*p*2.01;\r\n    f += 0.0625 * snoise(p);\r\n    return f/0.9375;\r\n}\r\n\r\n////// My code below\r\n\r\n\r\nfloat getAverage(float start, float end) {\r\n    float sum = 0.0;\r\n    int count = 0;\r\n    for(float i = start; i < end; i += 1.0/512.0) {\r\n        sum += texture(iChannel0, vec2(i, 0.25)).x;\r\n        count++;\r\n    }\r\n    float average = sum/float(count);\r\n    return average;\r\n}\r\n\r\nvec2 liquid(vec2 uv) {\r\n    float t0 = iTime / 2.0;\r\n    float bass = getAverage(0.001, 0.04);\r\n    float mids = getAverage(0.3, 0.6);\r\n    float highs = getAverage(0.8, 1.0);\r\n    float t = t0 + mids / 4.0;\r\n    float s1 = fbm(uv + t / 2.0 + fbm(uv + fbm(uv + (t + highs) / 4.0) / 10.0));\r\n    float s2 = fbm(uv + s1 + bass * 1.5);\r\n\r\n    float f = sin(t0);\r\n    float f2 = sin(t0 * 2.3);\r\n    return vec2(mix(s1, s2, f), mix(s2, s1, f2));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord.xy / iResolution.xy;\r\n    vec2 liq = liquid(uv);\r\n\tfragColor = vec4(0.0, liq, 1.0);\r\n}\r\n"},{id:"MdlSzB",name:"symmetrical sound visualiser by thelinked",shader:"// https://www.shadertoy.com/view/MdlSzB\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = fragCoord.xy / iResolution.xy;\r\n\tif(uv.x > 0.5)\r\n\t{\r\n\t\tuv -= 0.5;\r\n\t\tuv *= 2.;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tuv *= 2.;\r\n\t\tuv = 1. - uv;\r\n\t}\r\n\r\n\tfloat fft  = texture( iChannel0, vec2(uv.x,0.25) ).x;\r\n\tfloat dr = length(uv);\r\n\tfloat radius = 1.8;\r\n\r\n\tvec3 col = vec3(0.);\r\n\tif( abs(uv.y)<fft )\r\n\t{\r\n\t\tcol = mix( vec3(0.), vec3( fft, fft*(1.0-fft), 1.0-fft ) * fft * fft, fft);\r\n\t}\r\n\r\n\r\n\tfragColor.x = 0.5 - smoothstep(dr, 0.0, radius * col.x);\r\n\tfragColor.y = 1.0 - smoothstep(dr, 0.0, radius * col.z);\r\n\tfragColor.z = 1.0 - smoothstep(dr, 0.0, radius * col.x);\r\n}\r\n"},{id:"cdySDy",name:"Audio Visualizer #4 - Lasers by kishimisu",shader:'// https://www.shadertoy.com/view/cdySDy\r\n/* Audio Visualizer #4 - "Lasers" by @kishimisu (2023) - https://www.shadertoy.com/view/cdySDy\r\n\r\n   A pretty crazy 3D scene reacting to live music and featuring *Lasers*\r\n\r\n   Restart the shader if the music doesn\'t play!\r\n*/\r\n\r\n// <!> Decrease this if you experience low performances <!>\r\n#define ITERATIONS 40.\r\n\r\n/*   Distance functions    */\r\nfloat box( vec2 p, vec2 b ) {\r\n  vec2 q = abs(p) - b;\r\n  return length(max(q,0.)) + min(max(q.x,q.y),0.);\r\n}\r\nfloat boxf( vec3 p, vec3 b) {\r\n  vec3 q = abs(abs(p)-b);\r\n  return min(length(max(vec3(q.x-b.x,q.y,q.z),0.)),\r\n             length(max(vec3(q.x,q.y-b.y,q.z),0.)));\r\n}\r\nfloat line(vec3 p, vec3 a, vec3 b, float r) {\r\n  vec3 pa = p-a, ba = b-a;\r\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\r\n  return length(pa - ba*h) - r;\r\n}\r\n\r\n/* Audio-related functions */\r\n#define getLevel(x) (texelFetch(iChannel0, ivec2(int(x*512.), 0), 0).r)\r\n#define getPitch(f) logisticAmp(getLevel(pow(2., f) * .02175))\r\n#define logX(x,a,c) (1./(exp(-a*(x-c))+1.))\r\nfloat logisticAmp(float amp){\r\n   const float c = 1., a = 20.;\r\n   return (logX(amp, a, c) - logX(0.0, a, c)) / (logX(1.0, a, c) - logX(0.0, a, c));\r\n}\r\nfloat getVol(float samples) {\r\n    float avg = 0.;\r\n    for (float i = 0.; i < samples; i++) avg += getLevel(i/samples);\r\n    return avg / samples;\r\n}\r\n\r\n/*    Helper functions     */\r\n#define rep(p,r) (mod(p+r, r*2.)-r)\r\n#define rid(p,r) floor((p+r)/(r*2.));\r\n#define light(d, itn, att, p) itn / (1. + pow(abs(d)*att, p))\r\n\r\nvoid mainImage(out vec4 O, vec2 F) {\r\n    vec2 R = iResolution.xy, u = (F+F-R)/R.y;\r\n\r\n    vec3 p, q, g = vec3(0);\r\n    float i = 0., d = i, t = iTime;\r\n\r\n    float v    = getVol(12.);\r\n    float beat = getPitch(.7);\r\n\r\n    float pitches[20];\r\n    for (float j = 0.; j < 20.; j++) {\r\n        pitches[int(j)] = getPitch(fract(j/20.)*2.5);\r\n    }\r\n\r\n    for (O *= i; i < ITERATIONS; i++) {\r\n        p = d*normalize(vec3(u,.8));\r\n        p.z += t*2.+v*1.5;\r\n        q = p;\r\n\r\n        // Walls\r\n        float scene = -box(p.xy, vec2(4));\r\n\r\n        // Corner lights\r\n        float id = rid(p.z, 1.);\r\n        p.z = rep(p.z, 1.);\r\n        float corners = box(abs(abs(p.xy) - 4.), vec2(.01));\r\n        g += (1.+cos(q.z/10. + v*10.+ beat + vec3(0,1,2))) * light(corners, v*beat*.1, 20., 1.4);\r\n\r\n        // Rectangle lights\r\n        p.z = abs(abs(p.z) - 1.);\r\n        float rects = boxf(p, vec3(4, 4, 0));\r\n        g += (1.+cos(q.z/10. + 1.+ v*10. + vec3(0,1,2))) * light(rects, v*beat*.5, 20., 1.4);\r\n\r\n        // Lasers\r\n        p = q;\r\n        const float n = 3.; // Number of neighbors to check in each direction\r\n        const float zrep = .3;\r\n        float zid0 = rid(p.z, zrep);\r\n        p.z = rep(p.z, zrep);\r\n\r\n        for (float k = -n; k <= n; k++) {\r\n            float zid = zid0 + k;                 // Neighbor ID\r\n            float a = pitches[int(mod(zid,20.))]; // Neighbor pitch\r\n\r\n            // Calculate line start and end points\r\n            float spm = (fract(zid*34.243425)*2.-1.) * smoothstep(0., 1., t/50.)*1.3;\r\n            float x1 = 6. * cos(t*spm + zid*.7 - a*.25);\r\n            float z1 = 6. * sin(t*spm + zid*.7 - a*.25);\r\n            float x2 = 6. * cos(t*spm + zid*.7 + 3.141592 + .25 + a*.25);\r\n            float z2 = 6. * sin(t*spm + zid*.7 + 3.141592 + .25 + a*.25);\r\n\r\n            // Add laser\r\n            float l = line(p - vec3(0,0,k*zrep*2.), vec3(x1, z1, 0), vec3(x2, z2, 0), sin(t+zid)*.02-.01+a*.1);\r\n            g += (cos(zid*.2+t + a*3. + vec3(0,1,2))+1.) * light(l, a*2., 20.,2.);\r\n            scene = min(scene, l);\r\n        }\r\n\r\n        d += scene;\r\n\r\n        if (d > ITERATIONS*.7) break;\r\n    }\r\n\r\n    O.rgb = pow(g, vec3(.5));\r\n}\r\n'},{id:"WlB3zc",name:"Burn Sound Wave by edo_m18",shader:"// https://www.shadertoy.com/view/WlB3zc\r\n///\r\n/// This post cloned from below post.\r\n/// I also reduce code and add a sound.\r\n/// I respect the post.\r\n///\r\n/// [[ Fire Storm Cube ]]\r\n///\r\n/// https://www.shadertoy.com/view/ldyyWm\r\n///\r\n\r\n#define R iResolution\r\n\r\nfloat burn;\r\n\r\nmat2 rot(float a)\r\n{\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n\r\n    return mat2(s, c, -c, s);\r\n}\r\n\r\nfloat map(vec3 p)\r\n{\r\n    float i = texture(iChannel0, vec2(0.3, 0.5)).x;\r\n\r\n    float d1 = length(p) - 1. * i;\r\n\r\n    //mat2 r = rot(-iTime / 3.0 + length(p));\r\n    mat2 r = rot(iTime * 2.0 + length(p));\r\n    p.xy *= r;\r\n    p.zy *= r;\r\n\r\n    p = abs(p);// - iTime;\r\n    p = abs(p - round(p)) *  2.5 * i;\r\n\r\n    //r = rot(iTime);\r\n    //p.xy *= r;\r\n    //p.xz *= r;\r\n\r\n    float l1 = length(p.xy);\r\n    float l2 = length(p.yz);\r\n    float l3 = length(p.xz);\r\n\r\n    float g = 0.01;\r\n    float d2 = min(min(l1, l2), l3) + g;\r\n\r\n    burn = pow(d2 - d1, 2.0);\r\n\r\n    return min(d1, d2);\r\n}\r\n\r\nvoid mainImage( out vec4 O, in vec2 U )\r\n{\r\n    vec2 uv = (2.0 * U - R.xy) / R.y;\r\n    vec3 ro = normalize(vec3(uv, 1.5));\r\n\r\n    vec3 ta = vec3(0, 0, -2);\r\n\r\n    float t = 0.;\r\n    for  (int i = 0; i < 30; i++)\r\n    {\r\n        t += map(ta + ro * t) * 0.5;\r\n    }\r\n\r\n    O = vec4(1.0 - burn, 0, exp(-t), 0.0);\r\n}\r\n"},{id:"MsdXzl",name:"Pinwheel by bwestlin",shader:"// https://www.shadertoy.com/view/MsdXzl\r\n// Used to have https://soundcloud.com/twistedmusic/younger-brother-crumblenaut but not working anymore\r\n#define M_PI 3.1415926535897932384626433832795\r\n#define r iResolution\r\n#define t iChannelTime[0]\r\n#define lw 1.5\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\r\n{\r\n\tvec2 uv = fragCoord.xy / r.x;\r\n    float s1 = 0.01 + 0.99 * min(texture(iChannel0, vec2(0.65, 0.0)).x * 1.5, 1.0);\r\n    float s2 = 0.1 + 0.9 * min(texture(iChannel0, vec2(0.9, 0.0)).x * 1.5, 1.0);\r\n    float s3 = 0.2 * min(texture(iChannel0, vec2(0.0, 0.0)).x * 1.5, 1.0);\r\n    vec2 m = vec2(1.0, r.y / r.x) / 2.0;\r\n    float d = distance(uv, m);\r\n    float rd = (m.y / 1.5) + (s1 / 10.0);\r\n    float ad = abs(d - rd);\r\n    float a = mod(atan(uv.y - m.y, uv.x - m.x) + (t / 1.0), M_PI / ceil(32.0 * s2));\r\n    ad += a / 10.;\r\n\r\n    float c = 0.0;\r\n    if (ad < lw * s1) c = (lw * s1 / ad) / 6.0;\r\n\r\n\tfragColor = vec4(c, c * s3, c * s1, 0.0);\r\n}\r\n"},{id:"4dXcWB",name:"Mellow rainbow blob by bwestlin",shader:"// https://www.shadertoy.com/view/4dXcWB\r\n#define t iTime\r\n#define ic0 iChannel0\r\n\r\nconst float EPS = 0.001;\r\nconst float MAX_ITER = 40.0;\r\nconst float MAX_T = 100.0;\r\n\r\nvec3 simple_camera(vec2 uv) {\r\n    vec3 forward = vec3(0.0, 0.0, -1.0);\r\n    vec3 up = vec3(0.0, 1.0, 0.0);\r\n    vec3 side = vec3(1.0, 0.0, 0.0);\r\n    return normalize(forward + uv.x * side + uv.y * up);\r\n}\r\n\r\nfloat opU( float d1, float d2 ) {\r\n  return min(d1, d2);\r\n}\r\n\r\n// Smooth minimum : https://iquilezles.org/articles/smin\r\nfloat smin( float a, float b, float k ) {\r\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\r\n    return mix( b, a, h ) - k*h*(1.0-h);\r\n}\r\n\r\n\r\nfloat sdSphere(vec3 p, float s) {\r\n  return length(p)-s;\r\n}\r\n\r\nfloat sdPlane(vec3 p, vec4 n) {\r\n    return dot(p, n.xyz) + n.w;\r\n}\r\n\r\n/*\r\n\tReturn the closest distance to any surface from point p.\r\n */\r\nfloat map(vec3 p) {\r\n    //float s1 = sdSphere(p - vec3(0.0, 0.0 + sin(iTime * 2.0), -3.0), 1.0);\r\n    float s1 = sdSphere(p - vec3(0.0, -0.5 + texture(ic0, vec2(.1, 0.)).x * 2. + sin(iTime * 2.0)/ 5., -3.0), 0.7 + texture(ic0, vec2(.4, 0.)).x);\r\n    float s2 = sdPlane(p - vec3(0.0, -1.0, 0.0), vec4(0.0, 1.0, 0.0, 1.0));\r\n    return smin(s1, s2, 4.0);\r\n}\r\n\r\n\r\nfloat intersect(vec3 origin, vec3 rayDir)\r\n{\r\n    float t = 0.0;\r\n    float dt = 0.1;\r\n\r\n    for (float i = 0.0; i < MAX_ITER; i += 1.0) {\r\n        t += dt;\r\n\r\n        dt = map(t * rayDir + origin);\r\n        if (abs(t) < EPS) {\r\n            break;\r\n        }\r\n\r\n        if (t > MAX_T) {\r\n            t = 0.0;\r\n            break;\r\n        }\r\n\r\n    }\r\n\treturn t;\r\n}\r\n\r\n\r\n\r\nvec3 plasma(vec2 uv) {\r\n    float s1 = .5 + .5 * min(texture(ic0, vec2(.1, 0.) ).x * 1.5, 1.);\r\n    float s2 = .5 + .5 * min(texture(ic0, vec2(.4, 0.) ).x * 1.5, 1.);\r\n    float s3 = .5 + .5 * min(texture(ic0, vec2(.6, 0.) ).x * 1.5, 1.);\r\n    float s4 = .5 + .5 * min(texture(ic0, vec2(.9, 0.) ).x * 1.5, 1.);\r\n\r\n    vec2 p1 = vec2(0., 0.);\r\n    vec2 p2 = vec2(0., 1.);\r\n    vec2 p3 = vec2(1., 1.0);\r\n    vec2 p4 = vec2(1., 0.);\r\n\r\n    float c1 = .5 + .5 * sin(distance(uv, p1) * 10. * s1 + t + s1 / 4.);\r\n    float c2 = .5 + .5 * sin(distance(uv, p2) * 10. * s2 + t + s2 / 4.);\r\n    float c3 = .5 + .5 * sin(distance(uv, p3) * 10. * s3 + t + s3 / 4.);\r\n    float c4 = .5 + .5 * sin(distance(uv, p4) * 25. * s4 + t * 3. + s4 / 4.);\r\n\r\n\treturn vec3(c1 + c4 * .33, c2 + c4 * .33, c3 + c4 * .33);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n\r\n    vec3 cameraOrigin = vec3(0.0);\r\n    vec3 rayDir = simple_camera(uv);\r\n\r\n    vec3 color = vec3((uv.y - 0.5) * (1.5 + sin(t * .2) * .5), 0.0, uv.y);\r\n\r\n    float t = intersect(cameraOrigin, rayDir);\r\n\r\n    if (t > 0.0) {\r\n        // calculate intersection point\r\n        vec3 hit = cameraOrigin + t * rayDir;\r\n\r\n        // get the color of the pixel\r\n        //color = texture(iChannel0, hit.xy).xyz;\r\n        color = plasma(hit.xy / 7.);\r\n\r\n        // fade with distance\r\n        color *= vec3(6.0 / (t*t));\r\n    }\r\n\r\n\r\n    fragColor = vec4(color, 1.0);\r\n}\r\n"},{id:"dllBWn",name:"Brokowi by zhonkvision",shader:"// https://www.shadertoy.com/view/dllBWn\r\nuniform float musicAmplitude; // Audio analysis data representing amplitude\r\n\r\nvec3 palette(float d, float audioAmplitude) {\r\n    vec3 yellow = vec3(0.6, 0.1, 0.0); // Yellow\r\n    vec3 green = vec3(0.2, 1.7, 0.5); // Green\r\n\r\n    d *= audioAmplitude * 0.1 + 0.5;\r\n    vec3 color = mix(yellow, green, d);\r\n    return color;\r\n}\r\n\r\nvec2 rotate(vec2 p, float a) {\r\n    float c = cos(a);\r\n    float s = sin(a);\r\n    return p * mat2(c, s, -s, c);\r\n}\r\n\r\nfloat map(vec3 p, float audioAmplitude) {\r\n    float angle = iTime * 0.05 * (0.2 + musicAmplitude * 0.8) + sin(iTime * 0.2) * 0.0;\r\n    for (int i = 0; i < 12; ++i) {\r\n        float t = angle;\r\n        p.xz = rotate(p.xz, t * 10.666);\r\n        p.xy = rotate(p.xy, t * 40.666);\r\n        p.xz = rotate(p.xz, t * 10.666);\r\n        p.xy = rotate(p.xy, t * 50.666);\r\n        p.xz = abs(p.xz);\r\n        p.xz -= 0.5;\r\n    }\r\n\r\n    float sphere = length(p) - (0.5 + audioAmplitude * 0.1); // Adjust size based on audio amplitude\r\n\r\n    return sphere;\r\n}\r\n\r\nvec4 rm(vec3 ro, vec3 rd, float audioAmplitude) {\r\n    float t = 0.0;\r\n    vec3 col = vec3(0.0);\r\n    float d;\r\n    for (float i = 0.0; i < 64.0; i++) {\r\n        vec3 p = ro + rd * t;\r\n        d = map(p, audioAmplitude) * 0.5;\r\n        if (d < 0.02) {\r\n            break;\r\n        }\r\n        if (d > 200.0) {\r\n            break;\r\n        }\r\n        col += palette(length(p) * 0.1, audioAmplitude) / (400.0 * d);\r\n        t += d;\r\n    }\r\n    return vec4(col, 1.0 / (d * 300.0));\r\n}\r\n\r\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\r\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.x;\r\n    float spiralTime = iTime * 0.05 * (0.2 + musicAmplitude * 0.8);\r\n    vec3 ro = vec3(0.0, 0.0, -28.0);\r\n    ro.xz = rotate(ro.xz, spiralTime);\r\n\r\n    vec3 cf = normalize(-ro);\r\n    vec3 cs = normalize(cross(cf, vec3(0.0, 4.0, 0.0)));\r\n    vec3 cu = normalize(cross(cf, cs));\r\n\r\n    float audioData = texture(iChannel0, vec2(iTime * 0.2, 0.0)).r; // Sample audio data from iChannel0\r\n    float uuvScale = 0.7 + audioData * 0.2; // Scale adjusted with audio amplitude\r\n\r\n    vec3 uuv = ro + cf * uuvScale + uv.x * cs + uv.y * cu;\r\n\r\n    vec3 rd = normalize(uuv - ro);\r\n\r\n    vec4 col = rm(ro, rd, musicAmplitude);\r\n\r\n    fragColor = col;\r\n}\r\n"},{id:"mlsfzB",name:"Lelabah by zhonkvision",shader:"// https://www.shadertoy.com/view/mlsfzB\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\r\n    vec3 col = vec3(0.0);\r\n    float t = iTime;\r\n\r\n    vec2 n = vec2(0.0);\r\n    vec2 q = vec2(0.0);\r\n    vec2 p = uv;\r\n    float d = dot(p, p);\r\n    float S = 14.0;\r\n    float a = 0.002;\r\n    mat2 m = mat2(2.0, 0.0, 0.0, 1.0); // Identity matrix\r\n\r\n    // Apply mirroring transformations for each quadrant\r\n    if (uv.x < 2.0) {\r\n        uv.x = -uv.x;\r\n        m[0][0] = -m[0][0];\r\n    }\r\n    if (uv.y < 1.0) {\r\n        uv.y = -uv.y;\r\n        m[1][1] = -m[1][1];\r\n    }\r\n\r\n    // Apply shape scaling and rotation\r\n    p *= 1.0; // Change the initial shapeScale here\r\n    p = mat2(cos(0.0), -sin(0.0), sin(0.0), cos(0.0)) * p; // Change the initial shapeRotation here\r\n\r\n    // Audio input\r\n    float audioValue = texture(iChannel0, vec2(0.5)).r; // Sample audio input\r\n    float numIterations = mix(2.1, 20.0, audioValue); // Modify the number of iterations based on audio\r\n    float animationSpeed = mix(1.01, 1.2, audioValue); // Modify the animation speed based on audio\r\n\r\n    for (float j = 2.1; j < numIterations; j++) {\r\n        p = m * p;\r\n        n = m * n;\r\n        q = p * S + t * 3.8 + sin(t * 2.15 - d * 8.0) * 4.0 + j + a - n;\r\n        a += dot(cos(q) / S, vec2(0.4));\r\n        n -= sin(q);\r\n        S *= animationSpeed; // Adjust animation speed\r\n\r\n        // Apply zoom-in effect by increasing the shapeScale\r\n        p *= 1.01; // Adjust this increment to control the zoom speed\r\n\r\n        m = mat2(m[0][0] * 2.05, m[0][1] * 1.05, m[1][0] * 1.05, m[1][1] * 1.05);\r\n    }\r\n\r\n    col = vec3(1.1, 2.6, 3.4) * ((a * 3.0) + 0.2) + a + a - d;\r\n\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n"},{id:"dtSBR1",name:"Audio Reactive Fractal by FaustianBargainForTop",shader:"// https://www.shadertoy.com/view/dtSBR1\r\n#define freq(f) texture(iChannel0, vec2(f, 0.25)).x * 0.8\r\nfloat avgFreq(float start, float end, float step) {\r\n    float div = 0.0;\r\n    float total = 0.0;\r\n    for (float pos = start; pos < end; pos += step) {\r\n        div += 1.0;\r\n        total += freq(pos);\r\n    }\r\n    return total / div;\r\n}\r\n\r\n\r\nvec3 palette( float t ) {\r\n\r\n    float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.2);\r\n    float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\r\n    float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.85);\r\n\r\n    vec3 a = vec3(0.5, 0.5, 0.5)/sin(bassFreq);\r\n    vec3 b = vec3(0.5, 0.5, 0.5);\r\n    vec3 c = vec3(1.0, 1.0, 1.0);\r\n    vec3 d = vec3(0.263,0.416,0.557)/sin(bassFreq/2.);\r\n\r\n    return a + b*cos( 6.28318*(c*t+d) );\r\n}\r\n\r\n\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\r\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\r\n    vec3 coll = palette(length(uv));\r\n\r\n    vec3 col = vec3(0);\r\n\r\n    float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.2);\r\n    float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\r\n    float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.85);\r\n\r\n    float a = .7853982;\r\n    float s = sin(a);\r\n    float c = cos(a);\r\n    uv *= mat2(c, -s, s, c);\r\n    uv *= 20.;\r\n    vec2 gv = fract(uv)-.5;\r\n    vec2 id = floor( uv);\r\n\r\n    float m = 0.-bassFreq;\r\n    float t = iTime+sin(medFreq);\r\n\r\n\r\n\r\n    for(float y=-1. ; y<=1. ; y++) {\r\n        for(float x=-1. ; x<=1. ; x++) {\r\n            vec2 offs = vec2(x, y);\r\n\r\n            float bassFreq = pow(avgFreq(0.0, 0.1, 0.01), 0.85);\r\n            float medFreq = pow(avgFreq(0.1, 0.6, 0.01), 0.85);\r\n            float topFreq = pow(avgFreq(0.6, 1.0, 0.01), 0.85);\r\n\r\n\r\n            float d = length(gv-offs)+mix(.1, .5, sin(medFreq));\r\n            float dist = length(id+offs)*.4;\r\n\r\n            float r = mix(.3, 1.5, sin(dist-t)*.5+.5)+mix(.1, .8, sin(bassFreq));\r\n            m += smoothstep(r,r*.9, d)-sin(bassFreq/6.);\r\n\r\n            }\r\n        }\r\n    float y=-1. ; y<=1. ; y++;\r\n    float x=-1. ; x<=1. ; x++;\r\n    vec2 offs = vec2(x, y);\r\n\r\n    float dist = length(id+offs)*.4;\r\n    //col.rg = gv;\r\n    col += mod(m, 1.2);\r\n    col *= coll + sin(dist-t)*medFreq;\r\n\r\n    fragColor = vec4(col,1.0);\r\n}"},{id:"clVyWR",name:"Carel S' Audio Visualizer by carel_s",shader:"// https://www.shadertoy.com/view/msVBRc\r\n\r\n/*\r\n Strobing lights effect warning! Discretion is advised.\r\n This is a (trippy) Audio Visualizer. Reads the audio file from iChannel0, extracts the fft coefficients and use it for the visuals.\r\n Also, uses the energy for additional effects.\r\n*/\r\n\r\n#define SAMPLERATE iSampleRate\r\n// These brackets are required because the preprocessor is dumb\r\n#define MAX_F (0.25*SAMPLERATE)\r\n// Reference note for the conversions between note/octave and frequency, a good default is C4, aka middle C, 261.63 Hz\r\n#define REF_NOTE 261.63\r\n\r\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\r\n    return a + b*cos( 6.28318*(c*t+d) );\r\n}\r\n\r\nfloat cubicInOut(float t) {\r\n    if (t < 0.5) {\r\n        return 4.0 * t * t * t;\r\n    } else {\r\n        float f = ((2.0 * t) - 2.0);\r\n        return 0.5 * f * f * f + 1.0;\r\n    }\r\n}\r\n\r\nfloat progress(float t) {\r\n    return mix(smoothstep(0.0, 1.0, t), cubicInOut(t), t);\r\n}\r\n\r\nvec2 fishEyeLens(vec2 uv, float strength) {\r\n\r\n    float aspectRatio = iResolution.x / iResolution.y;\r\n\r\n    // Convert UV to polar coordinates\r\n    float radius = length(uv);\r\n    float angle = atan(uv.y, uv.x);\r\n\r\n    // Apply fisheye distortion\r\n    radius = sqrt(1.0 - exp(-radius * strength)) / sqrt(1.0 - exp(-strength));\r\n\r\n    // Convert back to Cartesian coordinates\r\n    uv.x = radius * cos(angle);\r\n    uv.y = radius * sin(angle);\r\n    uv = 0.5 * (uv + 1.0);\r\n\r\n    // Remap the UV coordinates back to the screen space\r\n    return uv;\r\n}\r\n\r\nfloat sdEquilateralTriangle( in vec2 p, in float r )\r\n{\r\n    const float k = sqrt(3.0);\r\n    p.x = abs(p.x) - r;\r\n    p.y = p.y + r/k;\r\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\r\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\n\r\nfloat sdSnowflakeTriangle(in vec2 p, in float r, in float iterations) {\r\n    float k = sqrt(3.0);\r\n    p.x = abs(p.x) - r;\r\n    p.y = p.y + r / k;\r\n    if (p.x + k * p.y > 0.0) {\r\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\r\n    }\r\n    p.x -= clamp(p.x, -2.0 * r, 0.0);\r\n\r\n    // Apply the snowflake fractal\r\n    for (float i = 0.; i < iterations; i++) {\r\n        p = abs(p) - r;\r\n        p *= 0.5;\r\n        p = mat2(cos(3.14159 / 3.0), -sin(3.14159 / 3.0), sin(3.14159 / 3.0), cos(3.14159 / 3.0)) * p;\r\n    }\r\n\r\n    return -length(p) * sign(p.y);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    // Normalized pixel coordinates (from 0 to 1)\r\n    vec2 uv = fragCoord/iResolution.xy; // Clip space\r\n    vec2 uv0 = uv*2.-1.;\r\n    uv0.x *= iResolution.x/iResolution.y; // Normalized clip space + aspect ratio\r\n    vec2 uv1 = uv0;\r\n\r\n    //Init color variable\r\n    vec3 finalColor = vec3(1.0);\r\n\r\n    float buff = 512.; // Audio buffer size\r\n    float bpm = 78.; // Tempo in bpm\r\n    float f = bpm / 60.; // Tempo in Hz\r\n    float T = 1./f;\r\n    float w = 2.*3.14159*f; // Tempo in rad/s\r\n\r\n    //Fetch frequency data from audio in iCh0\r\n    //Make it radial\r\n    float rad = pow(length(uv0),2.)*.24;\r\n    float rad_buff = rad * buff;\r\n    float fft = texelFetch(iChannel0, ivec2(rad_buff,0), 0 ).x;\r\n\r\n    //fft(freq/MAX_F);\r\n\r\n    //convert freq to color\r\n    vec3 col = vec3(fft);\r\n    col = smoothstep(.0,0.7,col);\r\n    col *= pal(rad,vec3(0.520,0.520,0.520),vec3(0.500,0.500,0.500),vec3(1.000,1.000,1.000),vec3(6.067,6.350,6.683) );\r\n    //Compute average energy and energy per band\r\n    float energy = .0, lows= 0., mids = 0., highs = 0.;\r\n    for (int i = 0; i<int(buff);++i)\r\n    {\r\n        energy += texelFetch(iChannel0, ivec2(i,0),0).x;\r\n        if (i<int(buff/3.))\r\n            lows += texelFetch(iChannel0, ivec2(i,0),0).x;\r\n        else if (i<int(2.*buff/3.))\r\n            mids += texelFetch(iChannel0, ivec2(i,0),0).x;\r\n        else\r\n            highs += texelFetch(iChannel0, ivec2(i,0),0).x;\r\n    }\r\n    energy /= buff;\r\n    lows /= buff/3.;\r\n    mids /= buff/3.;\r\n    highs /= buff/3.;\r\n\r\n    //energy will have kind of a sigmoidal shape in the range X(0,1) -> Y(0,1)\r\n    energy = progress(energy);\r\n    lows = progress(lows);\r\n    mids = progress(mids);\r\n    highs = progress(highs);\r\n    float numIterations = energy * 3.0; //same shape scaled X(0,1) -> Y(0,3)\r\n    numIterations = smoothstep(0.,1.,numIterations);\r\n\r\n    //spherical contour\r\n    float r = 0.3;\r\n    float sph = 1.0;\r\n    sph = length(uv1* lows);\r\n    sph -= 6.*r;\r\n    sph = abs(sph);\r\n    sph = smoothstep(0.2,1.,sph);\r\n\r\n    finalColor *= sph;\r\n    finalColor *= col;\r\n    //for (float i = 0.; i<1.;i++){\r\n        float tri= 1.0;\r\n        tri = sdSnowflakeTriangle(uv1,r*energy*T,3.);\r\n        tri = abs(tri);\r\n        tri = smoothstep(.0,1.,tri);\r\n        //tri = smoothstep(0.,1.,tri);\r\n        //tri = sdEquilateralTriangle(uv1,r*energy*1.5);\r\n        tri = sin(100.*tri + sin(0.5*T*iTime)*2./T)/100.;\r\n        tri = abs(tri);\r\n        tri = energy*0.02/tri;\r\n        //tri *= 1./numIterations;\r\n\r\n        col*=tri;\r\n    //}\r\n    finalColor*=col;\r\n    //HDR\r\n    finalColor = finalColor / (finalColor + vec3(1.0));\r\n    finalColor = pow(finalColor, vec3(1.0/2.2));\r\n\r\n    fragColor = vec4(finalColor, 1.);\r\n\r\n\r\n}\r\n"},{id:"msVBRc",name:"First shader test // Music by skill347",shader:"// https://www.shadertoy.com/view/clVyWR\r\nvec3 palette(float t)\r\n{\r\n    // [[0.802 0.201 0.691] [0.162 0.865 0.540] [0.223 0.275 0.791] [5.346 1.019 3.072]]\r\n    vec3 a = vec3(0.802, 0.201, 0.691);\r\n    vec3 b = vec3(0.162, 0.865, 0.540);\r\n    vec3 c = vec3(0.223, 0.275, 0.79);\r\n    vec3 d = vec3(5.346, 1.019, 3.072);\r\n\r\n    return a + b*cos( 6.28318*(c*t+d) );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n    vec2 uv0 = uv;\r\n    vec3 finalColor = vec3(0.0);\r\n\r\n\r\n\r\n    for(float i=0.0;i < 4.; i++)\r\n    {\r\n        float wave = texture( iChannel0, vec2(uv.x,0.75) ).x;\r\n        float fft  = texture( iChannel0, vec2(uv.x,0.25) ).x;\r\n        uv = fract(uv * 1.5) - 0.5;\r\n\r\n        float d = length(uv) * exp(-length(uv0));\r\n        //vec3 col = palette(length(uv0) + i*.4 + iTime);\r\n\r\n\r\n\r\n        d = sin(d*8. + iTime + wave)/8.;\r\n        d = abs(d);\r\n        d = pow(0.01/d, fft);\r\n\r\n        vec3 col = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\r\n        finalColor += col*=d;\r\n    }\r\n\r\n\r\n    fragColor = vec4(finalColor, 1.0);\r\n}\r\n"},{id:"ds2yWh",name:"First visualiser by globaldusk",shader:"// https://www.shadertoy.com/view/ds2yWh\r\nvec3 palette( float t ){\r\n\r\n\r\n    vec3 a = vec3(0.5, 0.5, 0.5);\r\n    vec3 b = vec3(0.5, 0.5, 0.5);\r\n    vec3 c = vec3(1.0, 1.0, 1.0);\r\n    vec3 d = vec3(0.263, 0.416, 0.557);\r\n\r\n    return a + b*cos( 6.28318*(c*t+d) );\r\n}\r\n\r\nfloat sample_at(float f)\r\n{\r\n    return texture(iChannel0, vec2(f / 10.0, 0.25)).x;\r\n}\r\n\r\nfloat sm(float f)\r\n{\r\n    float delta = .1;\r\n    return 0.2 * (sample_at(f - 2. * delta) + sample_at(f - delta) + sample_at(f) + sample_at(f + delta) + sample_at(f + 2. * delta));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = (fragCoord *2.0 - iResolution.xy) / iResolution.y; //Centering and coord scaling\r\n\r\n    vec2 uv0 = uv;//Temp storage\r\n\r\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);// backcolour\r\n\r\n    for (float i = 0.0; i <2.0; i++){\r\n\r\n        uv = fract(uv *sm(1.5)) - 0.5;//amount of fractals\r\n\r\n        float d = length(uv) * sm(exp(-length(uv0))); //circle placement\r\n\r\n        vec3 col = palette(length(uv0) + i*.4 + iTime*.4);//changing colour scheme\r\n\r\n        d = sin(d*8. +iTime)/8.;//circle movement direction and speed\r\n        d = abs(d); //ring brightness\r\n\r\n        d = pow(0.01/ d, 1.2); //colour glow\r\n\r\n\r\n        finalColor += col * d;// Applying the colour to the algorithm\r\n    }\r\n\r\n    fragColor =  vec4(finalColor, 1.0);//setting the output\r\n\r\n}\r\n"},{id:"DlVXDc",name:"Spaceship Console by QuantumSuper",shader:'// https://www.shadertoy.com/view/DlVXDc\r\n// Spaceship Console 0.6.230610 by QuantumSuper\r\n// auto-vj of a 2d spaceship ui flying through pseudo-3d space with gauges, fft textures, and bass reactive animations\r\n//\r\n// - use with music in iChannel0 -\r\n\r\n#define PI 3.14159265359\r\n#define aTime 2.133333*iTime\r\n\r\nvec4 fft, ffts; //compressed frequency amplitudes\r\n\r\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\r\n    fft = vec4(0), ffts = vec4(0);\r\n\r\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\r\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\r\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\r\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\r\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\r\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\r\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\r\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\r\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\r\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\r\n\r\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\r\n}\r\n\r\nvec3 getCol(float id){ //color definitions, for triplets\r\n    vec3 setCol = vec3(0);\r\n    id = mod(id,15.);\r\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\r\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\r\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\r\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\r\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\r\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\r\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\r\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\r\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\r\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\r\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\r\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\r\n    else if (id<13.) setCol = vec3( 28,142, 77); //matrix green\r\n    else if (id<14.) setCol = vec3( 66,120, 91); //matrix green 2\r\n    else if (id<15.) setCol = vec3(173,  0, 27); //matrix red\r\n    return setCol/256.;\r\n}\r\n\r\nfloat hash21(vec2 p){ //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\r\n    p = fract(p*vec2(13.81, 741.76));\r\n    p += dot(p, p+42.23);\r\n    return fract(p.x*p.y);\r\n}\r\n\r\nfloat aaStep( float fun){return smoothstep( fwidth(fun), .0, fun);} //simple antialiasing\r\nfloat aaStep( float fun, float minWidth){return smoothstep( max(fwidth(fun),minWidth), .0, fun);} //overload to set minimum width\r\n\r\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\r\n\r\nfloat sdCircle( vec2 p, float r){\r\n    return length(p)-r;\r\n}\r\n\r\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\r\n    vec2 d = abs(p) - b;\r\n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\r\n}\r\n\r\nfloat sdSegment( vec2 p, vec2 a, vec2 b){//source: https://iquilezles.org/articles/distfunctions2d/\r\n    vec2 pa = p - a, ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\r\n    return length(pa - ba*h);\r\n}\r\n\r\nvec3 getStar(vec2 p, vec2 id){\r\n    id = vec2( hash21(id), hash21(id+id.yx));\r\n    p *= 1. + id.y*2.; //different sizes\r\n    p += id.y*vec2(sin(id.x*aTime/8.),sin(id.y*iTime*.1)); //different postions\r\n    return smoothstep( .85, 1., id.x) //brightness\r\n        * (.8 + .2 * vec3( sin(id*aTime/4.), sin(dot(id,vec2(.5))*iTime))) * vec3(1.5,1.,1.5) //color\r\n        * ((.5 + .5 * sin(2.*aTime*id.x+2.*PI*id.x) * sin(iTime)) //brightness varying over time\r\n        * aaStep(1. - dot( .1/(abs(p)+fwidth(p)+.12), vec2(1))) //"lens flare" shape\r\n        + smoothstep( .2, .8, .07/length(p))); //round core\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\r\n\r\n    // General initialization\r\n    compressFft(); //initializes fft, ffts\r\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\r\n    float rho = atan(-abs(uv.x),uv.y)/PI+1.; //polar angle flipped & mirrored\r\n\r\n\r\n    // Animation definitions\r\n    vec4 bang = vec4(0);\r\n    for (int n=0;n<4;n++)\r\n        bang[n] = smoothstep( .91, 1., texelFetch( iChannel0, ivec2(n,0), 0 ).x);\r\n    float colId = 3. * floor(mod(aTime/16.,5.)); //color set id\r\n    mat2 spaceRot = rotM(.2*sin(aTime/8.+fft.x)*sin(iTime*.1)); //"outside" space rotation\r\n\r\n\r\n    // Object definitions\r\n    float winDistort = length(uv*vec2(1.2,2.)-vec2(0,.2)); //morphing window shape\r\n    vec4 tmp = vec4( uv*winDistort, vec2(.7,.3)); //temporary "throw-away" variable\r\n    float window = sdBox( tmp.xy, tmp.zw)-.1; //window frame\r\n    float frame = sdBox( .6*tmp.xy, tmp.zw)-.1; //frame of window frame\r\n    float sideBox = sdBox( vec2(abs(tmp.x),tmp.y)+vec2(-1.4,1.), vec2(.5)); //bottom edges\r\n    tmp.x = uv.x;\r\n    float vent = sdBox( tmp.xy-vec2(-.5,.75), vec2(.15,.3)); //top left "vent" shape\r\n    float ventAmp = sdSegment( fract(tmp.xy*33.), vec2(0), vec2(0,1))-.3; //vertical line texture\r\n\r\n    tmp = vec4( uv*winDistort+vec2(0,.53), vec2(.8,.09));\r\n    float bBar = sdBox( tmp.xy, tmp.zw); //bottom "screen"\r\n    float bBarAmp = texelFetch( iChannel0, ivec2(1024.*abs(tmp.x/(2.*tmp.z)),0),0).x; // sound texture, full\r\n    tmp = vec4( uv*winDistort+vec2(1.05,.0), vec2(.2,.4));\r\n    float lBar = sdBox( tmp.xy, tmp.zw); //left "screen"\r\n    float lBarAmp = texelFetch( iChannel0, ivec2(24.+71.*(tmp.y+tmp.w)/(2.*tmp.w),0),0).x; // sound texture, presence\r\n    tmp.x = uv.x*winDistort-1.05;\r\n    float rBar = sdBox( tmp.xy, tmp.zw); //right "screen"\r\n    float rBarAmp = texelFetch( iChannel0, ivec2(95.+417.*(tmp.y+tmp.w)/(2.*tmp.w),0),0).x; // sound texture, brilliance\r\n\r\n    tmp = vec4( uv*spaceRot, .1/fft.y, 0.);\r\n    float reticle = sdCircle( uv, tmp.z); //reticle\r\n    float horBars = sdSegment( abs(tmp.xy), vec2(.1+tmp.z,.0), vec2(.4+tmp.z,.0)); //horizontal bars\r\n    float reticleAmp = (length(uv)<.1/fft.y+.1)? //inner/outer\r\n        texelFetch(iChannel0,ivec2(6.+17.*rho,0),0).x : //sound texture, speech\r\n        (tmp.x>.0)? //left/right\r\n            texelFetch(iChannel0,ivec2(94.-71.*(tmp.x-.1-tmp.z)/.3,0),0).x : //sound texture, -presence\r\n            texelFetch(iChannel0,ivec2(5.-5.*(-tmp.x-.1-tmp.z)/.3,0),0).x; //sound texture, -bass\r\n\r\n    vec4 cannonAngle = vec4(2.4,PI-2.4,2.5,PI-2.5); //orientation\r\n    vec4 cannons = vec4(\r\n        sdBox( (uv+vec2(.8,.6))*rotM(cannonAngle.x)-vec2(0,.1*bang.x), vec2(.1,.55)-.5*vec2(uv.y+.3,-.1)) - .02, //left bottom cannon\r\n        sdBox( (uv+vec2(-.8,.6))*rotM(cannonAngle.y)+vec2(0,.1*bang.y), vec2(.1,.55)-.5*vec2(uv.y+.3,-.1)) - .02, //right bottom cannon\r\n        sdBox( (uv*3.+vec2(-2.,-1.5))*rotM(cannonAngle.z)+vec2(0,.2*bang.z), vec2(.01,.8)+.8*vec2(uv.y-.25,.1)) - .05, //right top cannon\r\n        sdBox( (uv*3.+vec2(2.,-1.5))*rotM(cannonAngle.w)-vec2(0,.2*bang.w), vec2(.01,.8)+.8*vec2(uv.y-.25,.1)) - .05); //left top cannon\r\n\r\n    tmp = vec4( -.9, .39, .02, .0);\r\n    vec4 led = vec4( //dot lights\r\n        sdCircle( uv-tmp.xy-vec2(-.02,.0), tmp.z),\r\n        sdCircle( uv-tmp.xy-vec2(.07,.02), tmp.z),\r\n        sdCircle( uv-tmp.xy-vec2(.09,.08), tmp.z),\r\n        sdCircle( uv-tmp.xy-vec2(.0,.06), tmp.z));\r\n\r\n    tmp = vec4( uv*rotM(2.9)+vec2(.8,.6), .005, -.02);\r\n    float strip1 = sdSegment( tmp.xy, vec2(.0), vec2(.5,.0)) - tmp.z; //strip light 1 carve-out\r\n    float strip2 = sdSegment( tmp.xy, vec2(.0,tmp.w), vec2(.4,tmp.w)) - tmp.z; //strip light 2 carve-out\r\n    float strip3 = sdSegment( tmp.xy, vec2(.0,2.*tmp.w), vec2(.3,2.*tmp.w)) - tmp.z; //strip light 3 carve-out\r\n    float strip1fill = sdSegment( tmp.xy, vec2(.0), vec2(.5*ffts.x,.0)) - tmp.z; //strip light 1 fill, speech I\r\n    float strip2fill = sdSegment( tmp.xy, vec2(.0,tmp.w), vec2(.4*ffts.y,tmp.w)) - tmp.z; //strip light 2 fill, speech II\r\n    float strip3fill = sdSegment( tmp.xy, vec2(.0,2.*tmp.w), vec2(.3*ffts.z,2.*tmp.w)) - tmp.z; //strip light 3 fill, speech III\r\n\r\n\r\n    // Draw starfield\r\n    vec3 col = vec3(0);\r\n    vec2 myUv;\r\n    float aFrac;\r\n    for (float n=0.;n<4.;n++){\r\n        aFrac = fract(-aTime/32.+.25*n) - .03*fft.w*fft.w*fft.w;\r\n        myUv = 30. * (.3+aFrac) * uv * spaceRot;\r\n        col += getStar(fract(myUv)-.5, ceil(myUv)+sin(n))\r\n            * smoothstep(1.,.33,aFrac) //fade in\r\n            * smoothstep(.0,.33,aFrac); //fade out (not very graceful)\r\n    }\r\n\r\n\r\n    // Draw screen overlay\r\n    reticle = clamp( .005/abs(reticle), .0, 1.) + clamp( .005/abs(horBars), .0, 1.); //glow\r\n    reticle = reticle * mix( 1., smoothstep(.2,.8,reticleAmp), .75*smoothstep(.66,1.,reticle)); //mix with texture\r\n    col += mix(reticle,pow(reticle,20.),reticle) * getCol(colId+0.); //heighten contrast & color\r\n\r\n    col -= clamp(-1.,.0,texelFetch( iChannel0, ivec2(512.*2.*abs(fragCoord.x/iResolution.x-.5)*winDistort,0),0).x\r\n        - 1.5*abs(fragCoord.y/iResolution.y-.5)*winDistort) * (.8+.2*getCol(colId)); //sound texture "shield"\r\n\r\n\r\n    // Draw cannons\r\n    vec4 flashX = vec4(.4,-.4,-.51,.51); //x position\r\n    vec4 flashY = vec4(.21,.21,-.3,-.3); //y position\r\n    vec4 flashMorphX = vec4(1,1,4,4); //x stretch\r\n    vec4 flashMorphY = vec4(5,5,20,20); //y stretch\r\n    for (int n=0;n<4;n++) //draw "nuzzle" flash\r\n        col += .1 * (clamp( .1 / clamp(\r\n            length( (uv+vec2(flashX[n],flashY[n]))*rotM(cannonAngle[n])*vec2(flashMorphX[n],flashMorphY[n]) - sign(flashX[n])*vec2(0,.18*bang[n])) - .05\r\n            , .001, 1.) * pow(bang[n],9.), .08, 10.) - .08);\r\n    for (int n=0;n<4;n++)\r\n        tmp[n] = aaStep(cannons[n]);\r\n    col *= 1. - dot(tmp,vec4(1)); //delete col at cannon positions\r\n    for (int n=0;n<4;n++)\r\n           col += tmp[n] * (.05-cannons[n]) * (.6+.4*getCol(colId)) * (.5+.5*bang[n]); //cannons\r\n\r\n\r\n    // Draw inside\r\n    col *= aaStep(window); //delete\r\n    col += (1.-aaStep(window)) * (.8+.2*getCol(colId)) * (.3+.7*ffts.w) * .1; //window frame\r\n    col -= (1.-aaStep(frame)) * (.8+.2*getCol(colId)) * (.3+.7*ffts.w) * .05; //frame of window frame\r\n\r\n    col *= 1. - aaStep(sideBox); //delete\r\n    col += aaStep(sideBox) * (.15+sideBox) * (.7+.3*getCol(colId)) * (.3+.7*ffts.w) * 1.5; //bottom side elements\r\n\r\n    col *= 1. - aaStep(vent) * aaStep(ventAmp); //vent\r\n\r\n    col *= 1.-(aaStep(bBar)+aaStep(lBar)+aaStep(rBar)); //delete\r\n    col += aaStep(bBar) * bBarAmp*bBarAmp*bBarAmp * getCol(colId+1.) //bottom "screen"\r\n        + aaStep(lBar) * lBarAmp*lBarAmp*lBarAmp*lBarAmp * getCol(colId) //left "screen"\r\n        + aaStep(rBar) * rBarAmp*rBarAmp * getCol(colId); //right "screen"\r\n\r\n    tmp = vec4(bBar,lBar,rBar,0);\r\n    for (int n=0;n<3;n++)\r\n        col *= 1. - aaStep(abs(tmp[n]),.01)  * .9; //"screen" frames\r\n\r\n    col *= 1. - (aaStep(led.x)+aaStep(led.y)+aaStep(led.z)+aaStep(led.w)); //delete\r\n    for (int n=0;n<4;n++)\r\n        col += (aaStep(led[n]) + .001/length(led[n])) * (.2+.8*step(.6,fft[n])) * getCol(colId+float(n)); //round led lights\r\n\r\n    col *= 1. - (aaStep(strip1) + aaStep(strip2) + aaStep(strip3)); //delete\r\n    col += aaStep(strip1fill) * getCol(colId+0.) * .7; //top right line 1\r\n    col += aaStep(strip2fill) * getCol(colId+1.) * .7; //top right line 2\r\n    col += aaStep(strip3fill) * getCol(colId+2.) * .7; //top right line 3\r\n\r\n\r\n    // Finalizations\r\n    col -= length(uv) * .03; //vignette\r\n    col = pow(col, vec3(.4545)); //gamma correction\r\n\r\n    fragColor = vec4(col,1.);\r\n}\r\n'},{id:"DsjcRD",name:"Gauges by QuantumSuper",shader:"// https://www.shadertoy.com/view/DsjcRD\r\n// Gauges 0.8.230622 by QuantumSuper\r\n// auto-vj including a variety of gauges each working on their own\r\n//\r\n// - use with music in iChannel0 -\r\n\r\n#define PI 3.14159265359\r\n#define aTime 2.133333*iTime\r\nvec4 fft, ffts; //compressed frequency amplitudes\r\n\r\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\r\n    fft = vec4(0), ffts = vec4(0);\r\n\r\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\r\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\r\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\r\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\r\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\r\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\r\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\r\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\r\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\r\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\r\n\r\n\tfor (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\r\n}\r\n\r\nvec3 getCol(float id){ //color definitions, for triplets\r\n    vec3 setCol = vec3(0);\r\n    id = mod(id,15.);\r\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\r\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\r\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\r\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\r\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\r\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\r\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\r\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\r\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\r\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\r\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\r\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\r\n    else if (id<13.) setCol = vec3( 28,142, 77); //matrix green\r\n    else if (id<14.) setCol = vec3( 66,120, 91); //matrix green 2\r\n    else if (id<15.) setCol = vec3(173,  0, 27); //matrix red\r\n    return setCol/256.;\r\n}\r\n\r\nfloat aaStep( float fun){return smoothstep( fwidth(fun), .0, fun);} //simple antialiasing\r\nvec2 aaStep( vec2 fun){return vec2( aaStep(fun.x), aaStep(fun.y));} //overload\r\n\r\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\r\n\r\nfloat hash21(vec2 p){ //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\r\n    p = fract(p*vec2(13.81, 741.76));\r\n    p += dot(p, p+42.23);\r\n    return fract(p.x*p.y);\r\n}\r\n\r\nfloat sdCircle( vec2 p, float r){\r\n    return length(p)-r;\r\n}\r\n\r\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\r\n    vec2 d = abs(p) - b;\r\n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\r\n}\r\n\r\nfloat sdSegment( vec2 p, vec2 a, vec2 b){//source: https://iquilezles.org/articles/distfunctions2d/\r\n    vec2 pa = p - a, ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\r\n    return length(pa - ba*h);\r\n}\r\n\r\nfloat sdEquilateralTriangle(vec2 p){ //source: https://iquilezles.org/articles/distfunctions2d/\r\n    const float k = sqrt(3.);\r\n    p.x = abs(p.x) - 1.;\r\n    p.y = p.y + 1./k;\r\n    if (p.x+k*p.y > 0.) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\r\n    p.x -= clamp( p.x, -2., 0.);\r\n    return -length(p)*sign(p.y);\r\n}\r\n\r\nvec3 getCircScale( vec2 p, float a, float s){ //in( position, amplitude, scale scale); out( circle, scale, indicator)\r\n    float rho = atan(p.x,p.y)/PI/2.+.5; //polar angle flipped & shifted, 0..1\r\n    return vec3(aaStep( sdCircle( p, .5)), //circle\r\n        (aaStep( abs(sdCircle( p, .46))-.01) //ring\r\n        + aaStep( fract((rho-1./8.)*s*10.*4./3.)-.03) * aaStep( abs(sdCircle( p, .39))-.06) //large scale, 10%\r\n        + aaStep( fract((rho-1./8.)*s*10.*4./3.+.5)-.01) * aaStep( abs(sdCircle( p, .41))-.04) //mid scale, 5%\r\n        + aaStep( fract((rho-1./8.)*s*100.*4./3.)-.03) * aaStep( abs(sdCircle( p, .43))-.02)) //small scale 1%\r\n        * aaStep( fract(rho-1.01/8.)-3./4.), //bottom cutout\r\n        aaStep( sdSegment( p*rotM(-(a-1./6.)*3./2.*PI), vec2(0), vec2(-.4,0)) - .01/length(p/.1))); //indicator\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\r\n\r\n    // General initialization\r\n    compressFft(); //initializes fft, ffts\r\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1..1, square aspect ratio\r\n\tfloat rho = atan(uv.x,uv.y)/PI/2.+.5; //polar angle flipped & shifted, 0..1\r\n    float colId = 3. * floor(mod(aTime/16.,5.)); //color set id\r\n    vec3 col = getCol(colId+2.) * fft.x * .05; //background\r\n    vec4 tmp; //temporary values\r\n\r\n\r\n    // Gauge, left\r\n    tmp.xyz = getCircScale( uv*1.6+vec2(.79,.18), fft.x, 1.);\r\n    col *= 1.-tmp.x; //delete col\r\n    col += tmp.x*(1.-tmp.y)*(1.-tmp.z) * getCol(colId+2.) * (1.-.5*fft.x) * .5 + tmp.y*(1.-tmp.z) * getCol(colId+1.) * (.2+.8*fft.x) * .8 + tmp.z*getCol(colId);\r\n\r\n\r\n     // Double gauge, top mid\r\n    tmp.xyz = clamp((getCircScale( (uv*vec2(1,-1)+vec2(.125, .5))*rotM( PI/4.), 1.-fft.z*.27, 1./.27)  * vec3(1.-aaStep(uv.xx),1.) //right half of double scale\r\n        + getCircScale( (uv*vec2(1,-1)-vec2(.125,-.5))*rotM(-PI/4.), fft.y*.27, 1./2.7) * vec3(aaStep(uv.xx),1.))//left half of double scale\r\n        * aaStep(uv.y-.58),.0,1.); //cut of unused part\r\n    col *= 1.-tmp.x; //delete col\r\n    col += tmp.x*(1.-tmp.y)*(1.-tmp.z) * getCol(colId+1.) * (1.-.2*(fft.y+fft.z)) * .5 //circle\r\n        + tmp.y*(1.-tmp.z) * getCol(colId+0.) * (.6+.2*(fft.y+fft.z)) * .8 //scale\r\n        + tmp.z * getCol(colId+2.); //indicator\r\n\r\n\r\n    // Led lights\r\n    col *= 1.-aaStep(sdCircle( uv-vec2(.31,.07), .07)); //delete col\r\n    tmp.x = sdCircle( uv-vec2(.31,.07), .07*ffts.w);\r\n    col += (aaStep( sdCircle( uv-vec2(.31,.07), .07*ffts.w)) + .002/max(.002,tmp.x)) * getCol(colId+2.) * (.2+.8*fft.x); //extending circle near center\r\n\r\n    for (float n=0.;n<4.;n++){ //lower left set of integrated four\r\n        tmp.x = sdCircle( uv+vec2(.449+.1*floor(n/2.),.22+.1*mod(ceil(n/2.),2.)), .03); //circles\r\n        col *= 1.-aaStep(tmp.x); //delete col\r\n        col += .002/max(.002,tmp.x) * getCol(colId+n) * (.2+.8*step( .91, texelFetch( iChannel0, ivec2(n,0), 0 ).x)); //light, bass channels\r\n    }\r\n\r\n\r\n    // Spectrum bars I, indicators, bottom right\r\n    tmp = vec4( //spectrum indicators (ugly but quick code)\r\n         aaStep(sdSegment( uv, -vec2(-.375-(.6* 6./512.),.4-.05), -vec2(.22,.13)-vec2(-.75-.002,.18-.002))-.002) //speech lower\r\n        +aaStep(sdSegment( uv, -vec2(-.375-(.6*24./512.),.4-.05), vec2(.22,-.13)-vec2(-.75+.002,.18-.002))-.002), //speech higher\r\n         aaStep(sdSegment( uv, -vec2(-.375+(.6*24./512.),.4-.05), vec2(.3,-.05)-vec2(-.18+.002,.1-.002))-.002) //presence lower\r\n        +aaStep(sdSegment( uv, -vec2(-.375+(.6*95./512.),.4-.05), -vec2(.3,.05)-vec2(-.18-.002,.1-.002))-.002), //presence higher\r\n         aaStep(sdSegment( uv, -vec2(-.375-(.6*95./512.)-.002,.4+.05-.002), -vec2(.45,-.02)-vec2(-.52-.002,.5-.002))-.002) //brilliance lower\r\n        +aaStep(sdSegment( uv, -vec2(-.375-(.6         )+.002,.4+.05-.002), vec2(.45,.02)-vec2(-.52+.002,.5-.002))-.002), //brilliance higher\r\n        0);\r\n    col *= 1.-clamp(dot(tmp,vec4(1)),.0,1.);\r\n    for (int n=0;n<3;n++) col += tmp[n] * getCol(colId+float(n)) * .2;\r\n\r\n\r\n    // Waveform\r\n    tmp = vec4( uv+vec2(-.16,.25), vec2(.32,.06));\r\n    float wave = texelFetch( iChannel0, ivec2((tmp.x+tmp.z)*512./(2.*tmp.z)*.98+1.,1), 0).x; //get waveform from texture, trim edges\r\n    if (wave == 0.){ //catch if no waveform found\r\n        for (int n=0;n<9;n++) //synthesize crude approximation\r\n            wave += texelFetch( iChannel0, ivec2(n,0), 0 ).x * sin((tmp.x+tmp.z)*PI/tmp.z * float(n*n*n) + aTime*2.*PI);\r\n        wave = wave/18. + .5; //scale & shift\r\n    }\r\n    tmp.z = aaStep(sdBox( tmp.xy, tmp.zw)); //empty box\r\n    col *= 1.-tmp.z; //delete col\r\n    col += aaStep(abs(wave-.5-tmp.y/(2.*tmp.w))-.1) * tmp.z * getCol(colId+0.) * (.2+.8*ffts.w); //waveform in black box\r\n\r\n    wave = .0;\r\n    tmp = vec4( uv+vec2(.499,.47), vec2(.23,.04));\r\n    for (int n=0;n<int(6.*fract(aTime));n++) //synthesize crude approximation\r\n        wave += texelFetch( iChannel0, ivec2(n,0), 0 ).x * sin((tmp.x+tmp.z)*PI/tmp.z * float(n));\r\n    wave = wave/(6.*fract(aTime)) + .5; //scale & shift\r\n    wave = aaStep(abs(wave-.5-tmp.y/(2.*tmp.w))-.01) * aaStep(abs(tmp.x)-tmp.z+.001);\r\n    col *= 1. - wave - aaStep( sdCircle( abs(tmp.xy)-vec2(tmp.z,.0), .01)); //delete col\r\n    col += wave * getCol(colId+2.); //bottom left waveform\r\n\r\n\r\n    // Spectrum bars II, bars itself, bottom right\r\n    tmp = vec4( uv+vec2(-.375,.4), vec2(.6,.05)); //spectrum bar mid\r\n    tmp.y = aaStep(sdBox( tmp.xy, tmp.zw));\r\n    col *= 1.-tmp.y; //delete col\r\n    col += tmp.y * texelFetch( iChannel0, ivec2(1024.*abs(tmp.x/(2.*tmp.z)),0),0).x  * getCol(colId+2.); //sound texture, full, mirrored\r\n\r\n    tmp = vec4( uv+vec2(-.75,.18), vec2(.22,.13)); //spectrum bar top right\r\n    tmp.y = aaStep(sdBox( tmp.xy, tmp.zw));\r\n    col *= 1.-tmp.y; //delete col\r\n    tmp.x = texelFetch( iChannel0, ivec2(6.+18.*(tmp.x+tmp.z)/(2.*tmp.z),0),0).x; //sound texture, speech\r\n    col += tmp.x*tmp.x*tmp.x*tmp.x * tmp.y * getCol(colId+0.);\r\n\r\n    tmp = vec4( uv+vec2(-.18,.1), vec2(.3,.05)); //spectrum bar top left\r\n    tmp.y = aaStep(sdBox( tmp.xy, tmp.zw));\r\n    col *= 1.-tmp.y; //delete col\r\n    tmp.x = texelFetch( iChannel0, ivec2(24.+71.*(tmp.x+tmp.z)/(2.*tmp.z),0),0).x; //sound texture, presence\r\n    col += tmp.x*tmp.x*tmp.x * tmp.y * getCol(colId+1.);\r\n\r\n    tmp = vec4( uv+vec2(-.52,.5), vec2(.45,.02)); //spectrum bar bottom\r\n    tmp.y = aaStep(sdBox( tmp.xy, tmp.zw));\r\n    col *= 1.-tmp.y; //delete col\r\n    col += texelFetch( iChannel0, ivec2(95.+417.*(tmp.x+tmp.z)/(2.*tmp.z),0),0).x * tmp.y * getCol(colId+2.); //sound texture, brilliance\r\n\r\n\r\n    // Spectrum screen, top right\r\n    tmp = vec4( uv-vec2(.7,.26), vec2(.27));\r\n    tmp.z = aaStep(sdBox( tmp.xy, tmp.zw)); //empty box\r\n    col *= 1.-tmp.z; //delete col\r\n    tmp.xy /= 2.*tmp.w;\r\n    col += (texelFetch( iChannel0, ivec2(int(512.*2.*abs(tmp.x)),0),0).x - 2.*abs(tmp.y)) * tmp.z * getCol(colId+1.); //mirrored sound texture spectrum\r\n\r\n\r\n    // Fill bars, top left\r\n    tmp = vec4( -.94, .32, -.38, .012);\r\n    for (float n=0.;n<4.;n++){\r\n        col *= 1. - aaStep( sdSegment( uv, tmp.xy, tmp.zy) - tmp.w); //delete col\r\n        col += aaStep( sdSegment( uv, tmp.xy, tmp.zy) - tmp.w) * aaStep(fract((uv.x-tmp.x)/abs(-tmp.x+tmp.z)*4.) - .03) * getCol(colId+n) * ffts.w; //add scale\r\n        col += aaStep( sdSegment( uv, tmp.xy, vec2( tmp.x+fft[int(n)]*abs(tmp.z-tmp.x), tmp.y)) - tmp.w) * getCol(colId+n) * .5; //light bar\r\n        tmp.y += 4.5*tmp.w; //shift to the top\r\n        tmp.z -= .02/(n+n+1.); //shorten\r\n    }\r\n\r\n\r\n    // Shifter, bottom left\r\n    tmp = vec4( -.94, -.5, .0, 0);\r\n    for (float n=0.;n<3.;n++){\r\n        tmp.w = sdSegment( uv, tmp.xy, tmp.xz+vec2(.0,.16-n*.085))-.001;\r\n        col *= 1. - aaStep(tmp.w); //delete col\r\n        col += .002/max(.002,tmp.w) * getCol(colId+n+0.) * ffts[int(n)] //glow lines\r\n        * (1.-aaStep(fract((uv.y-tmp.y)/abs(-tmp.y+tmp.z)*2.04) - .01) * aaStep(abs(uv.x-tmp.x)-.004) * step(tmp.y-tmp.x,abs(uv.y)-tmp.y)); //indicators\r\n        tmp.w = aaStep( sdCircle( uv-tmp.xy-vec2(0.,ffts[int(n)]*(tmp.z-tmp.y)), .015));\r\n        col *= 1. - tmp.w; //delete col\r\n        col += tmp.w * getCol(colId+n+1.) * .5; //knob\r\n        tmp.x += .04;\r\n    }\r\n\r\n\r\n    // Triangle\r\n    tmp = vec4( (vec2(uv.x,-uv.y)+vec2(.81,.19))*7., 0, 0);\r\n    tmp.z = aaStep( sdEquilateralTriangle( tmp.xy));\r\n    col *= 1. - tmp.z; //delete col\r\n    col += tmp.z * mat3(getCol(colId+0.),getCol(colId+1.),getCol(colId+2.))*(.5+.5*vec3(tmp.xy,-tmp.x)) * .33; //triangle\r\n    col += .01/max(.01, sdCircle( tmp.xy-vec2( (ffts.z-ffts.y)*(1.-ffts.x*1.9), (2.*ffts.x-ffts.z-ffts.y)*.56), .08*fft.y)) //dot\r\n        * mat3(getCol(colId+0.),getCol(colId+1.),getCol(colId+2.)) * vec3(ffts.x>ffts.y && ffts.x>ffts.z,ffts.y>ffts.z && ffts.y>ffts.x,ffts.z>ffts.x && ffts.z>ffts.y); //coloring\r\n\r\n\r\n    // Finalizations\r\n    col *= .8+.3*hash21(uv*aTime); //noise\r\n    col -= length(uv) * .03; //vignette\r\n\tcol = pow(col, vec3(.4545)); //gamma correction\r\n    fragColor = vec4(col,1.);\r\n}\r\n"},{id:"XsjXRm",name:"Plasma Globe by nimitz",shader:"// https://www.shadertoy.com/view/XsjXRm\r\n// Plasma Globe by nimitz (twitter: @stormoid)\r\n// https://www.shadertoy.com/view/XsjXRm\r\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\r\n// Contact the author for other licensing options\r\n\r\n//looks best with around 25 rays\r\n#define NUM_RAYS 13.\r\n\r\n#define VOLUMETRIC_STEPS 19\r\n\r\n#define MAX_ITER 35\r\n#define FAR 6.\r\n\r\n#define time iTime*1.1\r\n\r\n\r\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\r\nfloat noise( in float x ){return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;}\r\n\r\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\r\n\r\nfloat noise(in vec3 p)\r\n{\r\n\tvec3 ip = floor(p);\r\n    vec3 fp = fract(p);\r\n\tfp = fp*fp*(3.0-2.0*fp);\r\n\r\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\r\n\tvec2 rg = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\r\n\treturn mix(rg.x, rg.y, fp.z);\r\n}\r\n\r\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\r\n              -0.80,  0.36, -0.48,\r\n              -0.60, -0.48,  0.64 );\r\n\r\n\r\n//See: https://www.shadertoy.com/view/XdfXRj\r\nfloat flow(in vec3 p, in float t)\r\n{\r\n\tfloat z=2.;\r\n\tfloat rz = 0.;\r\n\tvec3 bp = p;\r\n\tfor (float i= 1.;i < 5.;i++ )\r\n\t{\r\n\t\tp += time*.1;\r\n\t\trz+= (sin(noise(p+t*0.8)*6.)*0.5+0.5) /z;\r\n\t\tp = mix(bp,p,0.6);\r\n\t\tz *= 2.;\r\n\t\tp *= 2.01;\r\n        p*= m3;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//could be improved\r\nfloat sins(in float x)\r\n{\r\n \tfloat rz = 0.;\r\n    float z = 2.;\r\n    for (float i= 0.;i < 3.;i++ )\r\n\t{\r\n        rz += abs(fract(x*1.4)-0.5)/z;\r\n        x *= 1.3;\r\n        z *= 1.15;\r\n        x -= time*.65*z;\r\n    }\r\n    return rz;\r\n}\r\n\r\nfloat segm( vec3 p, vec3 a, vec3 b)\r\n{\r\n    vec3 pa = p - a;\r\n\tvec3 ba = b - a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\r\n\treturn length( pa - ba*h )*.5;\r\n}\r\n\r\nvec3 path(in float i, in float d)\r\n{\r\n    vec3 en = vec3(0.,0.,1.);\r\n    float sns2 = sins(d+i*0.5)*0.22;\r\n    float sns = sins(d+i*.6)*0.21;\r\n    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);\r\n    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);\r\n    return en;\r\n}\r\n\r\nvec2 map(vec3 p, float i)\r\n{\r\n\tfloat lp = length(p);\r\n    vec3 bg = vec3(0.);\r\n    vec3 en = path(i,lp);\r\n\r\n    float ins = smoothstep(0.11,.46,lp);\r\n    float outs = .15+smoothstep(.0,.15,abs(lp-1.));\r\n    p *= ins*outs;\r\n    float id = ins*outs;\r\n\r\n    float rz = segm(p, bg, en)-0.011;\r\n    return vec2(rz,id);\r\n}\r\n\r\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j)\r\n{\r\n\tfloat precis = 0.001;\r\n    float h=0.5;\r\n    float d = startf;\r\n    for( int i=0; i<MAX_ITER; i++ )\r\n    {\r\n        if( abs(h)<precis||d>maxd ) break;\r\n        d += h*1.2;\r\n\t    float res = map(ro+rd*d, j).x;\r\n        h = res;\r\n    }\r\n\treturn d;\r\n}\r\n\r\n//volumetric marching\r\nvec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig)\r\n{\r\n    vec3 p = ro;\r\n    vec2 r = vec2(0.);\r\n    vec3 sum = vec3(0);\r\n    float w = 0.;\r\n    for( int i=0; i<VOLUMETRIC_STEPS; i++ )\r\n    {\r\n        r = map(p,j);\r\n        p += rd*.03;\r\n        float lp = length(p);\r\n\r\n        vec3 col = sin(vec3(1.05,2.5,1.52)*3.94+r.y)*.85+0.4;\r\n        col.rgb *= smoothstep(.0,.015,-r.x);\r\n        col *= smoothstep(0.04,.2,abs(lp-1.1));\r\n        col *= smoothstep(0.1,.34,lp);\r\n        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);\r\n    }\r\n    return sum;\r\n}\r\n\r\n//returns both collision dists of unit sphere\r\nvec2 iSphere2(in vec3 ro, in vec3 rd)\r\n{\r\n    vec3 oc = ro;\r\n    float b = dot(oc, rd);\r\n    float c = dot(oc,oc) - 1.;\r\n    float h = b*b - c;\r\n    if(h <0.0) return vec2(-1.);\r\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\r\n\tp.x*=iResolution.x/iResolution.y;\r\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\r\n\r\n\t//camera\r\n\tvec3 ro = vec3(0.,0.,5.);\r\n    vec3 rd = normalize(vec3(p*.7,-1.5));\r\n    mat2 mx = mm2(time*.4+um.x*6.);\r\n    mat2 my = mm2(time*0.3+um.y*6.);\r\n    ro.xz *= mx;rd.xz *= mx;\r\n    ro.xy *= my;rd.xy *= my;\r\n\r\n    vec3 bro = ro;\r\n    vec3 brd = rd;\r\n\r\n    vec3 col = vec3(0.0125,0.,0.025);\r\n    #if 1\r\n    for (float j = 1.;j<NUM_RAYS+1.;j++)\r\n    {\r\n        ro = bro;\r\n        rd = brd;\r\n        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);\r\n        ro.xy *= mm;rd.xy *= mm;\r\n        ro.xz *= mm;rd.xz *= mm;\r\n        float rz = march(ro,rd,2.5,FAR,j);\r\n\t\tif ( rz >= FAR)continue;\r\n    \tvec3 pos = ro+rz*rd;\r\n    \tcol = max(col,vmarch(pos,rd,j, bro));\r\n    }\r\n    #endif\r\n\r\n    ro = bro;\r\n    rd = brd;\r\n    vec2 sph = iSphere2(ro,rd);\r\n\r\n    if (sph.x > 0.)\r\n    {\r\n        vec3 pos = ro+rd*sph.x;\r\n        vec3 pos2 = ro+rd*sph.y;\r\n        vec3 rf = reflect( rd, pos );\r\n        vec3 rf2 = reflect( rd, pos2 );\r\n        float nz = (-log(abs(flow(rf*1.2,time)-.01)));\r\n        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));\r\n        col += (0.1*nz*nz* vec3(0.12,0.12,.5) + 0.05*nz2*nz2*vec3(0.55,0.2,.55))*0.8;\r\n    }\r\n\r\n\tfragColor = vec4(col*1.3, 1.0);\r\n}\r\n"}].map((({id:r,name:n,shader:e})=>({providerId:"ampshader",name:n,shader:e,externalUrl:`https://www.shadertoy.com/view/${r}`})))}}]);